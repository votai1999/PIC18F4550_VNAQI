CCS PCH C Compiler, Version 5.051, 5967               26-May-21 09:23

               Filename:   E:\PIC_MASTER\main.lst

               ROM used:   29882 bytes (91%)
                           Largest free fragment is 2882
               RAM used:   1189 (58%) at main() level
                           1546 (75%) worst case
               Stack used: 10 locations (8 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   6B66
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   027A
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   0314
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0214
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... // yeu cau nguon cap cho sim808 la 12 V_v5 of sim 2h neu nguoi duoi 10.6V 
.................... //V6 testWDT neu chip bi treo quá 2 phút (128s) 
.................... // THAY DOI SO VOI V3 CHO SDA B2->A3. 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 6E,75
00D8:  DATA 6C,6C
00DA:  DATA 00,00
00DC:  CLRF   FF7
00DE:  ADDLW  EC
00E0:  MOVWF  FF6
00E2:  MOVLW  00
00E4:  ADDWFC FF7,F
00E6:  TBLRD*+
00E8:  MOVF   FF5,W
00EA:  RETURN 0
00EC:  DATA 2F,75
00EE:  DATA 72,6C
00F0:  DATA 2E,74
00F2:  DATA 78,74
00F4:  DATA 00,00
00F6:  DATA 0D,0A
00F8:  DATA 2D,2D
00FA:  DATA 25,73
00FC:  DATA 2D,2D
00FE:  DATA 00,00
0100:  DATA 0D,0A
0102:  DATA 0D,0A
0104:  DATA 20,20
0106:  DATA 20,20
0108:  DATA 20,20
010A:  DATA 20,20
010C:  DATA 20,00
010E:  DATA 0D,0A
0110:  DATA 0D,0A
0112:  DATA 2D,2D
0114:  DATA 46,41
0116:  DATA 54,20
0118:  DATA 53,74
011A:  DATA 61,74
011C:  DATA 73,2D
011E:  DATA 2D,0D
0120:  DATA 0A,00
0122:  DATA 46,69
0124:  DATA 72,73
0126:  DATA 74,20
0128:  DATA 46,41
012A:  DATA 54,20
012C:  DATA 73,74
012E:  DATA 61,72
0130:  DATA 74,73
0132:  DATA 20,61
0134:  DATA 74,3A
0136:  DATA 20,30
0138:  DATA 78,25
013A:  DATA 6C,58
013C:  DATA 0D,0A
013E:  DATA 00,00
0140:  DATA 44,61
0142:  DATA 74,61
0144:  DATA 20,53
0146:  DATA 74,61
0148:  DATA 72,74
014A:  DATA 73,20
014C:  DATA 41,74
014E:  DATA 3A,20
0150:  DATA 30,78
0152:  DATA 25,6C
0154:  DATA 58,0D
0156:  DATA 0A,00
0158:  DATA 52,6F
015A:  DATA 6F,74
015C:  DATA 20,44
015E:  DATA 69,72
0160:  DATA 65,63
0162:  DATA 74,6F
0164:  DATA 72,79
0166:  DATA 20,49
0168:  DATA 73,20
016A:  DATA 41,74
016C:  DATA 3A,20
016E:  DATA 30,78
0170:  DATA 25,6C
0172:  DATA 58,0D
0174:  DATA 0A,00
0176:  DATA 42,79
0178:  DATA 74,65
017A:  DATA 73,20
017C:  DATA 50,65
017E:  DATA 72,20
0180:  DATA 43,6C
0182:  DATA 75,73
0184:  DATA 74,65
0186:  DATA 72,3A
0188:  DATA 20,30
018A:  DATA 78,25
018C:  DATA 6C,58
018E:  DATA 0D,0A
0190:  DATA 00,00
0192:  DATA 0D,0A
0194:  DATA 0D,0A
0196:  DATA 2D,2D
0198:  DATA 00,00
019A:  DATA 20,49
019C:  DATA 6E,66
019E:  DATA 6F,2D
01A0:  DATA 2D,00
01A2:  DATA 0D,0A
01A4:  DATA 41,74
01A6:  DATA 74,72
01A8:  DATA 69,62
01AA:  DATA 75,74
01AC:  DATA 65,73
01AE:  DATA 3A,20
01B0:  DATA 30,78
01B2:  DATA 25,58
01B4:  DATA 00,00
01B6:  DATA 0D,0A
01B8:  DATA 43,72
01BA:  DATA 65,61
01BC:  DATA 74,65
01BE:  DATA 64,3A
01C0:  DATA 20,00
01C2:  DATA 0D,0A
01C4:  DATA 4D,6F
01C6:  DATA 64,69
01C8:  DATA 66,69
01CA:  DATA 65,64
01CC:  DATA 3A,20
01CE:  DATA 00,00
01D0:  DATA 0D,0A
01D2:  DATA 53,74
01D4:  DATA 61,72
01D6:  DATA 74,69
01D8:  DATA 6E,67
01DA:  DATA 20,63
01DC:  DATA 6C,75
01DE:  DATA 73,74
01E0:  DATA 65,72
01E2:  DATA 3A,20
01E4:  DATA 25,6C
01E6:  DATA 58,00
01E8:  DATA 0D,0A
01EA:  DATA 53,74
01EC:  DATA 61,72
01EE:  DATA 74,69
01F0:  DATA 6E,67
01F2:  DATA 20,61
01F4:  DATA 64,64
01F6:  DATA 72,65
01F8:  DATA 73,73
01FA:  DATA 3A,20
01FC:  DATA 25,6C
01FE:  DATA 58,00
0200:  DATA 0D,0A
0202:  DATA 53,69
0204:  DATA 7A,65
0206:  DATA 3A,20
0208:  DATA 25,6C
020A:  DATA 75,20
020C:  DATA 42,79
020E:  DATA 74,65
0210:  DATA 73,0D
0212:  DATA 0A,00
*
0324:  DATA 0D,0A
0326:  DATA 45,72
0328:  DATA 72,6F
032A:  DATA 72,20
032C:  DATA 6F,70
032E:  DATA 65,6E
0330:  DATA 69,6E
0332:  DATA 67,20
0334:  DATA 66,69
0336:  DATA 6C,65
0338:  DATA 20,27
033A:  DATA 25,73
033C:  DATA 27,00
033E:  DATA 45,72
0340:  DATA 72,6F
0342:  DATA 72,20
0344:  DATA 63,6C
0346:  DATA 6F,73
0348:  DATA 69,6E
034A:  DATA 67,20
034C:  DATA 66,69
034E:  DATA 6C,65
0350:  DATA 20,27
0352:  DATA 25,73
0354:  DATA 27,00
0356:  DATA 4E,6F
0358:  DATA 20,53
035A:  DATA 44,0A
035C:  DATA 00,00
035E:  DATA 4C,6F
0360:  DATA 69,20
0362:  DATA 43,61
0364:  DATA 6D,20
0366:  DATA 42,69
0368:  DATA 65,6E
036A:  DATA 20,25
036C:  DATA 64,20
036E:  DATA 21,21
0370:  DATA 21,0A
0372:  DATA 00,00
0374:  DATA 4C,6F
0376:  DATA 69,20
0378:  DATA 43,61
037A:  DATA 6D,20
037C:  DATA 42,69
037E:  DATA 65,6E
0380:  DATA 20,25
0382:  DATA 64,20
0384:  DATA 21,21
0386:  DATA 21,0A
0388:  DATA 00,00
038A:  DATA 2A,74
038C:  DATA 69,6D
038E:  DATA 65,23
0390:  DATA 00,00
0392:  DATA 6C,6F
0394:  DATA 69,20
0396:  DATA 67,65
0398:  DATA 74,20
039A:  DATA 74,69
039C:  DATA 6D,65
039E:  DATA 00,00
03A0:  DATA 55,52
03A2:  DATA 4C,65
03A4:  DATA 65,70
03A6:  DATA 72,6F
03A8:  DATA 6D,3A
03AA:  DATA 20,2A
03AC:  DATA 25,73
03AE:  DATA 2A,0A
03B0:  DATA 00,00
03B2:  DATA 2A,6F
03B4:  DATA 6E,64
03B6:  DATA 61,74
03B8:  DATA 61,23
03BA:  DATA 00,00
03BC:  DATA 2A,6F
03BE:  DATA 6E,64
03C0:  DATA 61,74
03C2:  DATA 61,23
03C4:  DATA 00,00
03C6:  DATA 43,6F
03C8:  DATA 75,6E
03CA:  DATA 74,20
03CC:  DATA 63,68
03CE:  DATA 65,63
03D0:  DATA 6B,20
03D2:  DATA 3A,20
03D4:  DATA 25,64
03D6:  DATA 00,00
03D8:  DATA 2A,6F
03DA:  DATA 6E,64
03DC:  DATA 61,74
03DE:  DATA 61,23
03E0:  DATA 00,00
03E2:  DATA 26,75
03E4:  DATA 72,6C
03E6:  DATA 3B,25
03E8:  DATA 73,3F
03EA:  DATA 74,65
03EC:  DATA 6D,70
03EE:  DATA 3D,25
03F0:  DATA 66,26
03F2:  DATA 68,75
03F4:  DATA 6D,69
03F6:  DATA 3D,25
03F8:  DATA 66,26
03FA:  DATA 6C,69
03FC:  DATA 67,68
03FE:  DATA 74,3D
0400:  DATA 25,66
0402:  DATA 26,6E
0404:  DATA 6F,69
0406:  DATA 73,65
0408:  DATA 3D,25
040A:  DATA 66,26
040C:  DATA 70,61
040E:  DATA 3D,25
0410:  DATA 66,26
0412:  DATA 70,6D
0414:  DATA 32,35
0416:  DATA 3D,25
0418:  DATA 66,26
041A:  DATA 73,6F
041C:  DATA 32,3D
041E:  DATA 25,73
0420:  DATA 26,6E
0422:  DATA 6F,32
0424:  DATA 3D,25
0426:  DATA 73,26
0428:  DATA 63,6F
042A:  DATA 3D,25
042C:  DATA 73,26
042E:  DATA 70,6D
0430:  DATA 31,30
0432:  DATA 3D,25
0434:  DATA 66,26
0436:  DATA 77,69
0438:  DATA 6E,64
043A:  DATA 3D,25
043C:  DATA 64,26
043E:  DATA 70,6F
0440:  DATA 77,65
0442:  DATA 72,3D
0444:  DATA 25,66
0446:  DATA 26,74
0448:  DATA 65,6D
044A:  DATA 70,69
044C:  DATA 6E,3D
044E:  DATA 25,6C
0450:  DATA 75,26
0452:  DATA 68,75
0454:  DATA 6D,69
0456:  DATA 69,6E
0458:  DATA 3D,25
045A:  DATA 6C,75
045C:  DATA 23,00
045E:  DATA 2A,67
0460:  DATA 65,74
0462:  DATA 23,00
0464:  DATA 46,69
0466:  DATA 6E,69
0468:  DATA 73,68
046A:  DATA 20,67
046C:  DATA 65,74
046E:  DATA 64,61
0470:  DATA 74,61
0472:  DATA 00,00
0474:  DATA 45,72
0476:  DATA 72,6F
0478:  DATA 72,20
047A:  DATA 67,65
047C:  DATA 74,64
047E:  DATA 61,74
0480:  DATA 61,00
*
0D32:  MOVLB  4
0D34:  MOVF   xCA,W
0D36:  MULWF  xCC
0D38:  MOVFF  FF3,01
0D3C:  MOVFF  FF4,00
0D40:  MULWF  xCD
0D42:  MOVF   FF3,W
0D44:  ADDWF  00,F
0D46:  MOVF   xCB,W
0D48:  MULWF  xCC
0D4A:  MOVF   FF3,W
0D4C:  ADDWFC 00,W
0D4E:  MOVWF  02
0D50:  MOVLB  0
0D52:  RETURN 0
0D54:  MOVLB  5
0D56:  CLRF   xD2
0D58:  CLRF   xD3
0D5A:  MOVLW  01
0D5C:  MOVWF  xD4
0D5E:  CLRF   FDA
0D60:  CLRF   FD9
0D62:  MOVLW  05
0D64:  MOVWF  xD7
0D66:  MOVLW  CA
0D68:  MOVWF  xD6
0D6A:  MOVLW  05
0D6C:  MOVWF  FEA
0D6E:  MOVLW  CE
0D70:  MOVWF  FE9
0D72:  MOVFF  5D7,FE2
0D76:  MOVFF  5D6,FE1
0D7A:  MOVFF  5D4,5D5
0D7E:  BCF    FD8.0
0D80:  MOVF   FE5,W
0D82:  MULWF  FEE
0D84:  MOVF   FF3,W
0D86:  ADDWFC xD2,F
0D88:  MOVF   FF4,W
0D8A:  ADDWFC xD3,F
0D8C:  DECFSZ xD5,F
0D8E:  BRA    0D7E
0D90:  MOVFF  5D2,FDE
0D94:  MOVFF  5D3,5D2
0D98:  CLRF   xD3
0D9A:  BTFSC  FD8.0
0D9C:  INCF   xD3,F
0D9E:  INCF   xD6,F
0DA0:  BTFSC  FD8.2
0DA2:  INCF   xD7,F
0DA4:  INCF   xD4,F
0DA6:  MOVF   xD4,W
0DA8:  SUBLW  05
0DAA:  BNZ   0D6A
0DAC:  MOVLB  0
0DAE:  RETURN 0
*
0FE8:  TBLRD*+
0FEA:  MOVF   FF5,F
0FEC:  BZ    1008
0FEE:  MOVFF  FF6,4A4
0FF2:  MOVFF  FF7,4A5
0FF6:  MOVFF  FF5,4CB
0FFA:  CALL   04AC
0FFE:  MOVFF  4A4,FF6
1002:  MOVFF  4A5,FF7
1006:  BRA    0FE8
1008:  RETURN 0
*
11D2:  BTFSC  FD8.1
11D4:  BRA    11DE
11D6:  MOVLW  05
11D8:  MOVWF  FEA
11DA:  MOVLW  CC
11DC:  MOVWF  FE9
11DE:  CLRF   00
11E0:  CLRF   01
11E2:  CLRF   02
11E4:  CLRF   03
11E6:  MOVLB  5
11E8:  CLRF   xCC
11EA:  CLRF   xCD
11EC:  CLRF   xCE
11EE:  CLRF   xCF
11F0:  MOVF   xCB,W
11F2:  IORWF  xCA,W
11F4:  IORWF  xC9,W
11F6:  IORWF  xC8,W
11F8:  BZ    1252
11FA:  MOVLW  20
11FC:  MOVWF  xD0
11FE:  BCF    FD8.0
1200:  RLCF   xC4,F
1202:  RLCF   xC5,F
1204:  RLCF   xC6,F
1206:  RLCF   xC7,F
1208:  RLCF   xCC,F
120A:  RLCF   xCD,F
120C:  RLCF   xCE,F
120E:  RLCF   xCF,F
1210:  MOVF   xCB,W
1212:  SUBWF  xCF,W
1214:  BNZ   1226
1216:  MOVF   xCA,W
1218:  SUBWF  xCE,W
121A:  BNZ   1226
121C:  MOVF   xC9,W
121E:  SUBWF  xCD,W
1220:  BNZ   1226
1222:  MOVF   xC8,W
1224:  SUBWF  xCC,W
1226:  BNC   1246
1228:  MOVF   xC8,W
122A:  SUBWF  xCC,F
122C:  MOVF   xC9,W
122E:  BTFSS  FD8.0
1230:  INCFSZ xC9,W
1232:  SUBWF  xCD,F
1234:  MOVF   xCA,W
1236:  BTFSS  FD8.0
1238:  INCFSZ xCA,W
123A:  SUBWF  xCE,F
123C:  MOVF   xCB,W
123E:  BTFSS  FD8.0
1240:  INCFSZ xCB,W
1242:  SUBWF  xCF,F
1244:  BSF    FD8.0
1246:  RLCF   00,F
1248:  RLCF   01,F
124A:  RLCF   02,F
124C:  RLCF   03,F
124E:  DECFSZ xD0,F
1250:  BRA    11FE
1252:  MOVFF  5CC,FEF
1256:  MOVFF  5CD,FEC
125A:  MOVFF  5CE,FEC
125E:  MOVFF  5CF,FEC
1262:  MOVLB  0
1264:  RETURN 0
*
33E6:  MOVFF  23A,FEA
33EA:  MOVFF  239,FE9
33EE:  MOVLB  5
33F0:  MOVFF  5AF,FEF
33F4:  INCF   FE9,F
33F6:  BTFSC  FD8.2
33F8:  INCF   FEA,F
33FA:  CLRF   FEF
33FC:  MOVLB  2
33FE:  INCF   x39,F
3400:  BTFSC  FD8.2
3402:  INCF   x3A,F
3404:  MOVLB  0
3406:  RETURN 0
3408:  MOVF   FEF,F
340A:  BZ    342A
340C:  MOVFF  FEA,5AE
3410:  MOVFF  FE9,5AD
3414:  MOVFF  FEF,5AF
3418:  RCALL  33E6
341A:  MOVFF  5AE,FEA
341E:  MOVFF  5AD,FE9
3422:  INCF   FE9,F
3424:  BTFSC  FD8.2
3426:  INCF   FEA,F
3428:  BRA    3408
342A:  RETURN 0
*
3AD8:  TBLRD*+
3ADA:  MOVFF  FF6,4C6
3ADE:  MOVFF  FF7,4C7
3AE2:  MOVFF  FF5,4CB
3AE6:  CALL   04AC
3AEA:  MOVFF  4C6,FF6
3AEE:  MOVFF  4C7,FF7
3AF2:  MOVLB  4
3AF4:  DECFSZ xC5,F
3AF6:  BRA    3AFA
3AF8:  BRA    3AFE
3AFA:  MOVLB  0
3AFC:  BRA    3AD8
3AFE:  MOVLB  0
3B00:  RETURN 0
3B02:  MOVF   FEF,F
3B04:  BZ    3B26
3B06:  MOVFF  FEA,4A2
3B0A:  MOVFF  FE9,4A1
3B0E:  MOVFF  FEF,4CB
3B12:  CALL   04AC
3B16:  MOVFF  4A2,FEA
3B1A:  MOVFF  4A1,FE9
3B1E:  INCF   FE9,F
3B20:  BTFSC  FD8.2
3B22:  INCF   FEA,F
3B24:  BRA    3B02
3B26:  RETURN 0
3B28:  TBLRD*+
3B2A:  MOVF   FF5,F
3B2C:  BZ    3B48
3B2E:  MOVFF  FF6,4A4
3B32:  MOVFF  FF7,4A5
3B36:  MOVF   FF5,W
3B38:  BTFSS  F9E.4
3B3A:  BRA    3B38
3B3C:  MOVWF  FAD
3B3E:  MOVFF  4A4,FF6
3B42:  MOVFF  4A5,FF7
3B46:  BRA    3B28
3B48:  RETURN 0
*
3D0E:  CLRF   00
3D10:  CLRF   01
3D12:  MOVLB  4
3D14:  MOVF   xAD,W
3D16:  BCF    FD8.0
3D18:  BTFSC  xAE.0
3D1A:  ADDWF  00,F
3D1C:  RRCF   00,F
3D1E:  RRCF   01,F
3D20:  BTFSC  xAE.1
3D22:  ADDWF  00,F
3D24:  RRCF   00,F
3D26:  RRCF   01,F
3D28:  BTFSC  xAE.2
3D2A:  ADDWF  00,F
3D2C:  RRCF   00,F
3D2E:  RRCF   01,F
3D30:  BTFSC  xAE.3
3D32:  ADDWF  00,F
3D34:  RRCF   00,F
3D36:  RRCF   01,F
3D38:  BTFSC  xAE.4
3D3A:  ADDWF  00,F
3D3C:  RRCF   00,F
3D3E:  RRCF   01,F
3D40:  BTFSC  xAE.5
3D42:  ADDWF  00,F
3D44:  RRCF   00,F
3D46:  RRCF   01,F
3D48:  BTFSC  xAE.6
3D4A:  ADDWF  00,F
3D4C:  RRCF   00,F
3D4E:  RRCF   01,F
3D50:  BTFSC  xAE.7
3D52:  ADDWF  00,F
3D54:  RRCF   00,F
3D56:  RRCF   01,F
3D58:  MOVLB  0
3D5A:  GOTO   3E2E (RETURN)
*
3EF0:  MOVLB  4
3EF2:  MOVF   xCC,W
3EF4:  CLRF   01
3EF6:  SUBWF  xCB,W
3EF8:  BC    3F00
3EFA:  MOVFF  4CB,00
3EFE:  BRA    3F18
3F00:  CLRF   00
3F02:  MOVLW  08
3F04:  MOVWF  xCD
3F06:  RLCF   xCB,F
3F08:  RLCF   00,F
3F0A:  MOVF   xCC,W
3F0C:  SUBWF  00,W
3F0E:  BTFSC  FD8.0
3F10:  MOVWF  00
3F12:  RLCF   01,F
3F14:  DECFSZ xCD,F
3F16:  BRA    3F06
3F18:  MOVLB  0
3F1A:  RETURN 0
3F1C:  MOVF   01,W
3F1E:  MOVFF  4A4,4CB
3F22:  MOVLW  64
3F24:  MOVLB  4
3F26:  MOVWF  xCC
3F28:  MOVLB  0
3F2A:  RCALL  3EF0
3F2C:  MOVFF  00,4A4
3F30:  MOVF   01,W
3F32:  MOVLW  30
3F34:  BNZ   3F46
3F36:  MOVLB  4
3F38:  BTFSS  xA5.1
3F3A:  BRA    3F5C
3F3C:  BTFSC  xA5.3
3F3E:  BRA    3F5C
3F40:  BTFSC  xA5.4
3F42:  MOVLW  20
3F44:  BRA    3F4E
3F46:  MOVLB  4
3F48:  BCF    xA5.3
3F4A:  BCF    xA5.4
3F4C:  BSF    xA5.0
3F4E:  ADDWF  01,F
3F50:  MOVFF  01,4CB
3F54:  MOVLB  0
3F56:  CALL   04AC
3F5A:  MOVLB  4
3F5C:  MOVFF  4A4,4CB
3F60:  MOVLW  0A
3F62:  MOVWF  xCC
3F64:  MOVLB  0
3F66:  RCALL  3EF0
3F68:  MOVFF  00,4A4
3F6C:  MOVF   01,W
3F6E:  MOVLW  30
3F70:  BNZ   3F82
3F72:  MOVLB  4
3F74:  BTFSC  xA5.3
3F76:  BRA    3F8E
3F78:  BTFSS  xA5.0
3F7A:  BRA    3F8E
3F7C:  BTFSC  xA5.4
3F7E:  MOVLW  20
3F80:  MOVLB  0
3F82:  ADDWF  01,F
3F84:  MOVFF  01,4CB
3F88:  CALL   04AC
3F8C:  MOVLB  4
3F8E:  MOVLW  30
3F90:  ADDWF  xA4,F
3F92:  MOVFF  4A4,4CB
3F96:  MOVLB  0
3F98:  CALL   04AC
3F9C:  RETURN 0
*
44A8:  MOVLW  8E
44AA:  MOVWF  00
44AC:  MOVFF  4CA,01
44B0:  MOVFF  4C9,02
44B4:  CLRF   03
44B6:  MOVF   01,F
44B8:  BNZ   44CC
44BA:  MOVFF  02,01
44BE:  CLRF   02
44C0:  MOVLW  08
44C2:  SUBWF  00,F
44C4:  MOVF   01,F
44C6:  BNZ   44CC
44C8:  CLRF   00
44CA:  BRA    44DC
44CC:  BCF    FD8.0
44CE:  BTFSC  01.7
44D0:  BRA    44DA
44D2:  RLCF   02,F
44D4:  RLCF   01,F
44D6:  DECF   00,F
44D8:  BRA    44CC
44DA:  BCF    01.7
44DC:  RETURN 0
44DE:  MOVLB  4
44E0:  MOVF   xC9,W
44E2:  BTFSC  FD8.2
44E4:  BRA    45C8
44E6:  MOVWF  00
44E8:  MOVF   xCD,W
44EA:  BTFSC  FD8.2
44EC:  BRA    45C8
44EE:  ADDWF  00,F
44F0:  BNC   44FA
44F2:  MOVLW  81
44F4:  ADDWF  00,F
44F6:  BC    45C8
44F8:  BRA    4502
44FA:  MOVLW  7F
44FC:  SUBWF  00,F
44FE:  BNC   45C8
4500:  BZ    45C8
4502:  MOVFF  4CA,4D1
4506:  MOVF   xCE,W
4508:  XORWF  xD1,F
450A:  BSF    xCA.7
450C:  BSF    xCE.7
450E:  MOVF   xCC,W
4510:  MULWF  xD0
4512:  MOVFF  FF4,4D3
4516:  MOVF   xCB,W
4518:  MULWF  xCF
451A:  MOVFF  FF4,03
451E:  MOVFF  FF3,4D2
4522:  MULWF  xD0
4524:  MOVF   FF3,W
4526:  ADDWF  xD3,F
4528:  MOVF   FF4,W
452A:  ADDWFC xD2,F
452C:  MOVLW  00
452E:  ADDWFC 03,F
4530:  MOVF   xCC,W
4532:  MULWF  xCF
4534:  MOVF   FF3,W
4536:  ADDWF  xD3,F
4538:  MOVF   FF4,W
453A:  ADDWFC xD2,F
453C:  MOVLW  00
453E:  CLRF   02
4540:  ADDWFC 03,F
4542:  ADDWFC 02,F
4544:  MOVF   xCA,W
4546:  MULWF  xD0
4548:  MOVF   FF3,W
454A:  ADDWF  xD2,F
454C:  MOVF   FF4,W
454E:  ADDWFC 03,F
4550:  MOVLW  00
4552:  ADDWFC 02,F
4554:  MOVF   xCA,W
4556:  MULWF  xCF
4558:  MOVF   FF3,W
455A:  ADDWF  03,F
455C:  MOVF   FF4,W
455E:  ADDWFC 02,F
4560:  MOVLW  00
4562:  CLRF   01
4564:  ADDWFC 01,F
4566:  MOVF   xCC,W
4568:  MULWF  xCE
456A:  MOVF   FF3,W
456C:  ADDWF  xD2,F
456E:  MOVF   FF4,W
4570:  ADDWFC 03,F
4572:  MOVLW  00
4574:  ADDWFC 02,F
4576:  ADDWFC 01,F
4578:  MOVF   xCB,W
457A:  MULWF  xCE
457C:  MOVF   FF3,W
457E:  ADDWF  03,F
4580:  MOVF   FF4,W
4582:  ADDWFC 02,F
4584:  MOVLW  00
4586:  ADDWFC 01,F
4588:  MOVF   xCA,W
458A:  MULWF  xCE
458C:  MOVF   FF3,W
458E:  ADDWF  02,F
4590:  MOVF   FF4,W
4592:  ADDWFC 01,F
4594:  INCF   00,F
4596:  BTFSC  01.7
4598:  BRA    45A4
459A:  RLCF   xD2,F
459C:  RLCF   03,F
459E:  RLCF   02,F
45A0:  RLCF   01,F
45A2:  DECF   00,F
45A4:  MOVLW  00
45A6:  BTFSS  xD2.7
45A8:  BRA    45BE
45AA:  INCF   03,F
45AC:  ADDWFC 02,F
45AE:  ADDWFC 01,F
45B0:  MOVF   01,W
45B2:  BNZ   45BE
45B4:  MOVF   02,W
45B6:  BNZ   45BE
45B8:  MOVF   03,W
45BA:  BNZ   45BE
45BC:  INCF   00,F
45BE:  BTFSC  xD1.7
45C0:  BSF    01.7
45C2:  BTFSS  xD1.7
45C4:  BCF    01.7
45C6:  BRA    45D0
45C8:  CLRF   00
45CA:  CLRF   01
45CC:  CLRF   02
45CE:  CLRF   03
45D0:  MOVLB  0
45D2:  RETURN 0
45D4:  MOVLB  4
45D6:  MOVF   xC9,W
45D8:  BTFSC  FD8.2
45DA:  BRA    4726
45DC:  MOVWF  xD5
45DE:  MOVF   xCD,W
45E0:  BTFSC  FD8.2
45E2:  BRA    4726
45E4:  SUBWF  xD5,F
45E6:  BNC   45F2
45E8:  MOVLW  7F
45EA:  ADDWF  xD5,F
45EC:  BTFSC  FD8.0
45EE:  BRA    4726
45F0:  BRA    45FE
45F2:  MOVLW  81
45F4:  SUBWF  xD5,F
45F6:  BTFSS  FD8.0
45F8:  BRA    4726
45FA:  BTFSC  FD8.2
45FC:  BRA    4726
45FE:  MOVFF  4D5,00
4602:  CLRF   01
4604:  CLRF   02
4606:  CLRF   03
4608:  CLRF   xD4
460A:  MOVFF  4CA,4D3
460E:  BSF    xD3.7
4610:  MOVFF  4CB,4D2
4614:  MOVFF  4CC,4D1
4618:  MOVLW  19
461A:  MOVWF  xD5
461C:  MOVF   xD0,W
461E:  SUBWF  xD1,F
4620:  BC    463C
4622:  MOVLW  01
4624:  SUBWF  xD2,F
4626:  BC    463C
4628:  SUBWF  xD3,F
462A:  BC    463C
462C:  SUBWF  xD4,F
462E:  BC    463C
4630:  INCF   xD4,F
4632:  INCF   xD3,F
4634:  INCF   xD2,F
4636:  MOVF   xD0,W
4638:  ADDWF  xD1,F
463A:  BRA    468C
463C:  MOVF   xCF,W
463E:  SUBWF  xD2,F
4640:  BC    4666
4642:  MOVLW  01
4644:  SUBWF  xD3,F
4646:  BC    4666
4648:  SUBWF  xD4,F
464A:  BC    4666
464C:  INCF   xD4,F
464E:  INCF   xD3,F
4650:  MOVF   xCF,W
4652:  ADDWF  xD2,F
4654:  MOVF   xD0,W
4656:  ADDWF  xD1,F
4658:  BNC   468C
465A:  INCF   xD2,F
465C:  BNZ   468C
465E:  INCF   xD3,F
4660:  BNZ   468C
4662:  INCF   xD4,F
4664:  BRA    468C
4666:  MOVF   xCE,W
4668:  IORLW  80
466A:  SUBWF  xD3,F
466C:  BC    468A
466E:  MOVLW  01
4670:  SUBWF  xD4,F
4672:  BC    468A
4674:  INCF   xD4,F
4676:  MOVF   xCE,W
4678:  IORLW  80
467A:  ADDWF  xD3,F
467C:  MOVF   xCF,W
467E:  ADDWF  xD2,F
4680:  BNC   4654
4682:  INCF   xD3,F
4684:  BNZ   4654
4686:  INCF   xD4,F
4688:  BRA    4654
468A:  BSF    03.0
468C:  DECFSZ xD5,F
468E:  BRA    4692
4690:  BRA    46A8
4692:  BCF    FD8.0
4694:  RLCF   xD1,F
4696:  RLCF   xD2,F
4698:  RLCF   xD3,F
469A:  RLCF   xD4,F
469C:  BCF    FD8.0
469E:  RLCF   03,F
46A0:  RLCF   02,F
46A2:  RLCF   01,F
46A4:  RLCF   xD6,F
46A6:  BRA    461C
46A8:  BTFSS  xD6.0
46AA:  BRA    46B8
46AC:  BCF    FD8.0
46AE:  RRCF   01,F
46B0:  RRCF   02,F
46B2:  RRCF   03,F
46B4:  RRCF   xD6,F
46B6:  BRA    46BC
46B8:  DECF   00,F
46BA:  BZ    4726
46BC:  BTFSC  xD6.7
46BE:  BRA    46FC
46C0:  BCF    FD8.0
46C2:  RLCF   xD1,F
46C4:  RLCF   xD2,F
46C6:  RLCF   xD3,F
46C8:  RLCF   xD4,F
46CA:  MOVF   xD0,W
46CC:  SUBWF  xD1,F
46CE:  BC    46DE
46D0:  MOVLW  01
46D2:  SUBWF  xD2,F
46D4:  BC    46DE
46D6:  SUBWF  xD3,F
46D8:  BC    46DE
46DA:  SUBWF  xD4,F
46DC:  BNC   4712
46DE:  MOVF   xCF,W
46E0:  SUBWF  xD2,F
46E2:  BC    46EE
46E4:  MOVLW  01
46E6:  SUBWF  xD3,F
46E8:  BC    46EE
46EA:  SUBWF  xD4,F
46EC:  BNC   4712
46EE:  MOVF   xCE,W
46F0:  IORLW  80
46F2:  SUBWF  xD3,F
46F4:  BC    46FC
46F6:  MOVLW  01
46F8:  SUBWF  xD4,F
46FA:  BNC   4712
46FC:  INCF   03,F
46FE:  BNZ   4712
4700:  INCF   02,F
4702:  BNZ   4712
4704:  INCF   01,F
4706:  BNZ   4712
4708:  INCF   00,F
470A:  BZ    4726
470C:  RRCF   01,F
470E:  RRCF   02,F
4710:  RRCF   03,F
4712:  MOVFF  4CA,4D5
4716:  MOVF   xCE,W
4718:  XORWF  xD5,F
471A:  BTFSS  xD5.7
471C:  BRA    4722
471E:  BSF    01.7
4720:  BRA    472E
4722:  BCF    01.7
4724:  BRA    472E
4726:  CLRF   00
4728:  CLRF   01
472A:  CLRF   02
472C:  CLRF   03
472E:  MOVLB  0
4730:  RETURN 0
*
47FC:  MOVFF  4B5,4BC
4800:  MOVLB  4
4802:  MOVF   xB9,W
4804:  XORWF  xBC,F
4806:  BTFSS  xBC.7
4808:  BRA    4814
480A:  BCF    FD8.2
480C:  BCF    FD8.0
480E:  BTFSC  xB5.7
4810:  BSF    FD8.0
4812:  BRA    4872
4814:  MOVFF  4B5,4BC
4818:  MOVFF  4B8,4BD
481C:  MOVF   xB4,W
481E:  SUBWF  xBD,F
4820:  BZ    482E
4822:  BTFSS  xBC.7
4824:  BRA    4872
4826:  MOVF   FD8,W
4828:  XORLW  01
482A:  MOVWF  FD8
482C:  BRA    4872
482E:  MOVFF  4B9,4BD
4832:  MOVF   xB5,W
4834:  SUBWF  xBD,F
4836:  BZ    4844
4838:  BTFSS  xBC.7
483A:  BRA    4872
483C:  MOVF   FD8,W
483E:  XORLW  01
4840:  MOVWF  FD8
4842:  BRA    4872
4844:  MOVFF  4BA,4BD
4848:  MOVF   xB6,W
484A:  SUBWF  xBD,F
484C:  BZ    485A
484E:  BTFSS  xBC.7
4850:  BRA    4872
4852:  MOVF   FD8,W
4854:  XORLW  01
4856:  MOVWF  FD8
4858:  BRA    4872
485A:  MOVFF  4BB,4BD
485E:  MOVF   xB7,W
4860:  SUBWF  xBD,F
4862:  BZ    4870
4864:  BTFSS  xBC.7
4866:  BRA    4872
4868:  MOVF   FD8,W
486A:  XORLW  01
486C:  MOVWF  FD8
486E:  BRA    4872
4870:  BCF    FD8.0
4872:  MOVLB  0
4874:  RETURN 0
*
4D36:  MOVLW  80
4D38:  BTFSS  FD8.1
4D3A:  BRA    4D40
4D3C:  MOVLB  4
4D3E:  XORWF  xCC,F
4D40:  MOVLB  4
4D42:  CLRF   xD1
4D44:  CLRF   xD2
4D46:  MOVFF  4C8,4D0
4D4A:  MOVF   xCC,W
4D4C:  XORWF  xD0,F
4D4E:  MOVF   xC7,W
4D50:  BTFSC  FD8.2
4D52:  BRA    4F12
4D54:  MOVWF  xCF
4D56:  MOVWF  00
4D58:  MOVF   xCB,W
4D5A:  BTFSC  FD8.2
4D5C:  BRA    4F24
4D5E:  SUBWF  xCF,F
4D60:  BTFSC  FD8.2
4D62:  BRA    4E6A
4D64:  BNC   4DE2
4D66:  MOVFF  4CC,4D5
4D6A:  BSF    xD5.7
4D6C:  MOVFF  4CD,4D4
4D70:  MOVFF  4CE,4D3
4D74:  CLRF   xD2
4D76:  BCF    FD8.0
4D78:  RRCF   xD5,F
4D7A:  RRCF   xD4,F
4D7C:  RRCF   xD3,F
4D7E:  RRCF   xD2,F
4D80:  DECFSZ xCF,F
4D82:  BRA    4D74
4D84:  BTFSS  xD0.7
4D86:  BRA    4D8E
4D88:  BSF    xD1.0
4D8A:  BRA    4F4C
4D8C:  BCF    xD1.0
4D8E:  BCF    xCF.0
4D90:  BSF    xD1.4
4D92:  MOVLW  04
4D94:  MOVWF  FEA
4D96:  MOVLW  CA
4D98:  MOVWF  FE9
4D9A:  BRA    4F72
4D9C:  BCF    xD1.4
4D9E:  BTFSC  xD0.7
4DA0:  BRA    4DB6
4DA2:  BTFSS  xCF.0
4DA4:  BRA    4DCC
4DA6:  RRCF   xD5,F
4DA8:  RRCF   xD4,F
4DAA:  RRCF   xD3,F
4DAC:  RRCF   xD2,F
4DAE:  INCF   00,F
4DB0:  BTFSC  FD8.2
4DB2:  BRA    4F42
4DB4:  BRA    4DCC
4DB6:  BTFSC  xD5.7
4DB8:  BRA    4DD2
4DBA:  BCF    FD8.0
4DBC:  RLCF   xD2,F
4DBE:  RLCF   xD3,F
4DC0:  RLCF   xD4,F
4DC2:  RLCF   xD5,F
4DC4:  DECF   00,F
4DC6:  BTFSC  FD8.2
4DC8:  BRA    4F42
4DCA:  BRA    4DB6
4DCC:  BSF    xD1.6
4DCE:  BRA    4EAA
4DD0:  BCF    xD1.6
4DD2:  MOVFF  4C8,4D0
4DD6:  BTFSS  xC8.7
4DD8:  BRA    4DDE
4DDA:  BSF    xD5.7
4DDC:  BRA    4F34
4DDE:  BCF    xD5.7
4DE0:  BRA    4F34
4DE2:  MOVFF  4CB,4CF
4DE6:  MOVFF  4CB,00
4DEA:  MOVF   xC7,W
4DEC:  SUBWF  xCF,F
4DEE:  MOVFF  4C8,4D5
4DF2:  BSF    xD5.7
4DF4:  MOVFF  4C9,4D4
4DF8:  MOVFF  4CA,4D3
4DFC:  CLRF   xD2
4DFE:  BCF    FD8.0
4E00:  RRCF   xD5,F
4E02:  RRCF   xD4,F
4E04:  RRCF   xD3,F
4E06:  RRCF   xD2,F
4E08:  DECFSZ xCF,F
4E0A:  BRA    4DFC
4E0C:  BTFSS  xD0.7
4E0E:  BRA    4E16
4E10:  BSF    xD1.1
4E12:  BRA    4F4C
4E14:  BCF    xD1.1
4E16:  BCF    xCF.0
4E18:  BSF    xD1.5
4E1A:  MOVLW  04
4E1C:  MOVWF  FEA
4E1E:  MOVLW  CE
4E20:  MOVWF  FE9
4E22:  BRA    4F72
4E24:  BCF    xD1.5
4E26:  BTFSC  xD0.7
4E28:  BRA    4E3E
4E2A:  BTFSS  xCF.0
4E2C:  BRA    4E54
4E2E:  RRCF   xD5,F
4E30:  RRCF   xD4,F
4E32:  RRCF   xD3,F
4E34:  RRCF   xD2,F
4E36:  INCF   00,F
4E38:  BTFSC  FD8.2
4E3A:  BRA    4F42
4E3C:  BRA    4E54
4E3E:  BTFSC  xD5.7
4E40:  BRA    4E5A
4E42:  BCF    FD8.0
4E44:  RLCF   xD2,F
4E46:  RLCF   xD3,F
4E48:  RLCF   xD4,F
4E4A:  RLCF   xD5,F
4E4C:  DECF   00,F
4E4E:  BTFSC  FD8.2
4E50:  BRA    4F42
4E52:  BRA    4E3E
4E54:  BSF    xD1.7
4E56:  BRA    4EAA
4E58:  BCF    xD1.7
4E5A:  MOVFF  4CC,4D0
4E5E:  BTFSS  xCC.7
4E60:  BRA    4E66
4E62:  BSF    xD5.7
4E64:  BRA    4F34
4E66:  BCF    xD5.7
4E68:  BRA    4F34
4E6A:  MOVFF  4CC,4D5
4E6E:  BSF    xD5.7
4E70:  MOVFF  4CD,4D4
4E74:  MOVFF  4CE,4D3
4E78:  BTFSS  xD0.7
4E7A:  BRA    4E84
4E7C:  BCF    xD5.7
4E7E:  BSF    xD1.2
4E80:  BRA    4F4C
4E82:  BCF    xD1.2
4E84:  CLRF   xD2
4E86:  BCF    xCF.0
4E88:  MOVLW  04
4E8A:  MOVWF  FEA
4E8C:  MOVLW  CA
4E8E:  MOVWF  FE9
4E90:  BRA    4F72
4E92:  BTFSC  xD0.7
4E94:  BRA    4ECE
4E96:  MOVFF  4C8,4D0
4E9A:  BTFSS  xCF.0
4E9C:  BRA    4EAA
4E9E:  RRCF   xD5,F
4EA0:  RRCF   xD4,F
4EA2:  RRCF   xD3,F
4EA4:  RRCF   xD2,F
4EA6:  INCF   00,F
4EA8:  BZ    4F42
4EAA:  BTFSS  xD2.7
4EAC:  BRA    4EC4
4EAE:  INCF   xD3,F
4EB0:  BNZ   4EC4
4EB2:  INCF   xD4,F
4EB4:  BNZ   4EC4
4EB6:  INCF   xD5,F
4EB8:  BNZ   4EC4
4EBA:  RRCF   xD5,F
4EBC:  RRCF   xD4,F
4EBE:  RRCF   xD3,F
4EC0:  INCF   00,F
4EC2:  BZ    4F42
4EC4:  BTFSC  xD1.6
4EC6:  BRA    4DD0
4EC8:  BTFSC  xD1.7
4ECA:  BRA    4E58
4ECC:  BRA    4F06
4ECE:  MOVLW  80
4ED0:  XORWF  xD5,F
4ED2:  BTFSS  xD5.7
4ED4:  BRA    4EDE
4ED6:  BRA    4F4C
4ED8:  MOVFF  4CC,4D0
4EDC:  BRA    4EF2
4EDE:  MOVFF  4C8,4D0
4EE2:  MOVF   xD5,F
4EE4:  BNZ   4EF2
4EE6:  MOVF   xD4,F
4EE8:  BNZ   4EF2
4EEA:  MOVF   xD3,F
4EEC:  BNZ   4EF2
4EEE:  CLRF   00
4EF0:  BRA    4F34
4EF2:  BTFSC  xD5.7
4EF4:  BRA    4F06
4EF6:  BCF    FD8.0
4EF8:  RLCF   xD2,F
4EFA:  RLCF   xD3,F
4EFC:  RLCF   xD4,F
4EFE:  RLCF   xD5,F
4F00:  DECFSZ 00,F
4F02:  BRA    4EF2
4F04:  BRA    4F42
4F06:  BTFSS  xD0.7
4F08:  BRA    4F0E
4F0A:  BSF    xD5.7
4F0C:  BRA    4F34
4F0E:  BCF    xD5.7
4F10:  BRA    4F34
4F12:  MOVFF  4CB,00
4F16:  MOVFF  4CC,4D5
4F1A:  MOVFF  4CD,4D4
4F1E:  MOVFF  4CE,4D3
4F22:  BRA    4F34
4F24:  MOVFF  4C7,00
4F28:  MOVFF  4C8,4D5
4F2C:  MOVFF  4C9,4D4
4F30:  MOVFF  4CA,4D3
4F34:  MOVFF  4D5,01
4F38:  MOVFF  4D4,02
4F3C:  MOVFF  4D3,03
4F40:  BRA    4FAA
4F42:  CLRF   00
4F44:  CLRF   01
4F46:  CLRF   02
4F48:  CLRF   03
4F4A:  BRA    4FAA
4F4C:  CLRF   xD2
4F4E:  COMF   xD3,F
4F50:  COMF   xD4,F
4F52:  COMF   xD5,F
4F54:  COMF   xD2,F
4F56:  INCF   xD2,F
4F58:  BNZ   4F64
4F5A:  INCF   xD3,F
4F5C:  BNZ   4F64
4F5E:  INCF   xD4,F
4F60:  BNZ   4F64
4F62:  INCF   xD5,F
4F64:  BTFSC  xD1.0
4F66:  BRA    4D8C
4F68:  BTFSC  xD1.1
4F6A:  BRA    4E14
4F6C:  BTFSC  xD1.2
4F6E:  BRA    4E82
4F70:  BRA    4ED8
4F72:  MOVF   FEF,W
4F74:  ADDWF  xD3,F
4F76:  BNC   4F82
4F78:  INCF   xD4,F
4F7A:  BNZ   4F82
4F7C:  INCF   xD5,F
4F7E:  BTFSC  FD8.2
4F80:  BSF    xCF.0
4F82:  MOVF   FED,F
4F84:  MOVF   FEF,W
4F86:  ADDWF  xD4,F
4F88:  BNC   4F90
4F8A:  INCF   xD5,F
4F8C:  BTFSC  FD8.2
4F8E:  BSF    xCF.0
4F90:  MOVF   FED,F
4F92:  MOVF   FEF,W
4F94:  BTFSC  FEF.7
4F96:  BRA    4F9A
4F98:  XORLW  80
4F9A:  ADDWF  xD5,F
4F9C:  BTFSC  FD8.0
4F9E:  BSF    xCF.0
4FA0:  BTFSC  xD1.4
4FA2:  BRA    4D9C
4FA4:  BTFSC  xD1.5
4FA6:  BRA    4E24
4FA8:  BRA    4E92
4FAA:  MOVLB  0
4FAC:  RETURN 0
4FAE:  MOVLW  20
4FB0:  MOVLB  4
4FB2:  BTFSS  xC6.4
4FB4:  MOVLW  30
4FB6:  MOVWF  xC7
4FB8:  MOVFF  4C5,00
4FBC:  BTFSS  xC5.7
4FBE:  BRA    4FD0
4FC0:  COMF   00,F
4FC2:  INCF   00,F
4FC4:  MOVFF  00,4C5
4FC8:  MOVLW  2D
4FCA:  MOVWF  xC7
4FCC:  BSF    xC6.7
4FCE:  BSF    xC6.0
4FD0:  MOVF   01,W
4FD2:  MOVFF  4C5,4CB
4FD6:  MOVLW  64
4FD8:  MOVWF  xCC
4FDA:  MOVLB  0
4FDC:  CALL   3EF0
4FE0:  MOVFF  00,4C5
4FE4:  MOVLW  30
4FE6:  ADDWF  01,W
4FE8:  MOVLB  4
4FEA:  MOVWF  xC8
4FEC:  MOVFF  4C5,4CB
4FF0:  MOVLW  0A
4FF2:  MOVWF  xCC
4FF4:  MOVLB  0
4FF6:  CALL   3EF0
4FFA:  MOVLW  30
4FFC:  ADDWF  00,W
4FFE:  MOVLB  4
5000:  MOVWF  xCA
5002:  MOVLW  30
5004:  ADDWF  01,W
5006:  MOVWF  xC9
5008:  MOVFF  4C7,00
500C:  MOVLW  30
500E:  SUBWF  xC8,W
5010:  BZ    501A
5012:  BSF    xC6.1
5014:  BTFSC  xC6.7
5016:  BSF    xC6.2
5018:  BRA    503E
501A:  MOVFF  4C7,4C8
501E:  MOVLW  20
5020:  MOVWF  xC7
5022:  MOVLW  30
5024:  SUBWF  xC9,W
5026:  BZ    5030
5028:  BSF    xC6.0
502A:  BTFSC  xC6.7
502C:  BSF    xC6.1
502E:  BRA    503E
5030:  BTFSS  FD8.2
5032:  BSF    xC6.0
5034:  BNZ   503E
5036:  MOVFF  4C8,4C9
503A:  MOVLW  20
503C:  MOVWF  xC8
503E:  BTFSC  xC6.2
5040:  BRA    504C
5042:  BTFSC  xC6.1
5044:  BRA    5056
5046:  BTFSC  xC6.0
5048:  BRA    5060
504A:  BRA    506A
504C:  MOVFF  4C7,4CB
5050:  MOVLB  0
5052:  CALL   04AC
5056:  MOVFF  4C8,4CB
505A:  MOVLB  0
505C:  CALL   04AC
5060:  MOVFF  4C9,4CB
5064:  MOVLB  0
5066:  CALL   04AC
506A:  MOVFF  4CA,4CB
506E:  MOVLB  0
5070:  CALL   04AC
5074:  RETURN 0
*
53EC:  CLRF   01
53EE:  CLRF   02
53F0:  CLRF   00
53F2:  CLRF   03
53F4:  MOVLB  4
53F6:  MOVF   xC2,W
53F8:  BNZ   53FE
53FA:  MOVF   xC1,W
53FC:  BZ    542E
53FE:  MOVLW  10
5400:  MOVWF  xC3
5402:  BCF    FD8.0
5404:  RLCF   xBF,F
5406:  RLCF   xC0,F
5408:  RLCF   00,F
540A:  RLCF   03,F
540C:  MOVF   xC2,W
540E:  SUBWF  03,W
5410:  BNZ   5416
5412:  MOVF   xC1,W
5414:  SUBWF  00,W
5416:  BNC   5426
5418:  MOVF   xC1,W
541A:  SUBWF  00,F
541C:  BTFSS  FD8.0
541E:  DECF   03,F
5420:  MOVF   xC2,W
5422:  SUBWF  03,F
5424:  BSF    FD8.0
5426:  RLCF   01,F
5428:  RLCF   02,F
542A:  DECFSZ xC3,F
542C:  BRA    5402
542E:  MOVLB  0
5430:  RETURN 0
*
557C:  MOVLB  4
557E:  MOVF   xBD,W
5580:  SUBLW  B6
5582:  MOVWF  xBD
5584:  CLRF   03
5586:  MOVFF  4BE,4C1
558A:  BSF    xBE.7
558C:  BCF    FD8.0
558E:  RRCF   xBE,F
5590:  RRCF   xBF,F
5592:  RRCF   xC0,F
5594:  RRCF   03,F
5596:  RRCF   02,F
5598:  RRCF   01,F
559A:  RRCF   00,F
559C:  DECFSZ xBD,F
559E:  BRA    558C
55A0:  BTFSS  xC1.7
55A2:  BRA    55BA
55A4:  COMF   00,F
55A6:  COMF   01,F
55A8:  COMF   02,F
55AA:  COMF   03,F
55AC:  INCF   00,F
55AE:  BTFSC  FD8.2
55B0:  INCF   01,F
55B2:  BTFSC  FD8.2
55B4:  INCF   02,F
55B6:  BTFSC  FD8.2
55B8:  INCF   03,F
55BA:  MOVLB  0
55BC:  GOTO   5618 (RETURN)
55C0:  MOVF   FE9,W
55C2:  MOVLB  4
55C4:  MOVWF  xB5
55C6:  MOVF   xB4,W
55C8:  MOVWF  xB7
55CA:  BZ    5604
55CC:  MOVFF  4B3,4CC
55D0:  MOVFF  4B2,4CB
55D4:  MOVFF  4B1,4CA
55D8:  MOVFF  4B0,4C9
55DC:  CLRF   xD0
55DE:  CLRF   xCF
55E0:  MOVLW  20
55E2:  MOVWF  xCE
55E4:  MOVLW  82
55E6:  MOVWF  xCD
55E8:  MOVLB  0
55EA:  CALL   44DE
55EE:  MOVFF  03,4B3
55F2:  MOVFF  02,4B2
55F6:  MOVFF  01,4B1
55FA:  MOVFF  00,4B0
55FE:  MOVLB  4
5600:  DECFSZ xB7,F
5602:  BRA    55CC
5604:  MOVFF  4B3,4C0
5608:  MOVFF  4B2,4BF
560C:  MOVFF  4B1,4BE
5610:  MOVFF  4B0,4BD
5614:  MOVLB  0
5616:  BRA    557C
5618:  MOVFF  03,4B3
561C:  MOVFF  02,4B2
5620:  MOVFF  01,4B1
5624:  MOVFF  00,4B0
5628:  MOVLB  4
562A:  BTFSS  xB3.7
562C:  BRA    5648
562E:  DECF   xB5,F
5630:  BSF    xB5.5
5632:  COMF   xB0,F
5634:  COMF   xB1,F
5636:  COMF   xB2,F
5638:  COMF   xB3,F
563A:  INCF   xB0,F
563C:  BTFSC  FD8.2
563E:  INCF   xB1,F
5640:  BTFSC  FD8.2
5642:  INCF   xB2,F
5644:  BTFSC  FD8.2
5646:  INCF   xB3,F
5648:  MOVLW  3B
564A:  MOVWF  xBC
564C:  MOVLW  9A
564E:  MOVWF  xBB
5650:  MOVLW  CA
5652:  MOVWF  xBA
5654:  CLRF   xB9
5656:  MOVLW  0A
5658:  MOVWF  xB7
565A:  MOVF   xB4,W
565C:  BTFSC  FD8.2
565E:  INCF   xB5,F
5660:  BSF    FD8.1
5662:  MOVLW  04
5664:  MOVWF  FEA
5666:  MOVLW  B0
5668:  MOVWF  FE9
566A:  MOVFF  4B3,5C7
566E:  MOVFF  4B2,5C6
5672:  MOVFF  4B1,5C5
5676:  MOVFF  4B0,5C4
567A:  MOVFF  4BC,5CB
567E:  MOVFF  4BB,5CA
5682:  MOVFF  4BA,5C9
5686:  MOVFF  4B9,5C8
568A:  MOVLB  0
568C:  CALL   11D2
5690:  MOVF   01,W
5692:  MOVF   00,F
5694:  BNZ   56BC
5696:  MOVLB  4
5698:  INCF   xB4,W
569A:  SUBWF  xB7,W
569C:  BTFSS  FD8.2
569E:  BRA    56A4
56A0:  MOVLB  0
56A2:  BRA    56BC
56A4:  MOVF   xB5,W
56A6:  BZ    56C2
56A8:  ANDLW  0F
56AA:  SUBWF  xB7,W
56AC:  BZ    56B0
56AE:  BC    573E
56B0:  BTFSC  xB5.7
56B2:  BRA    573E
56B4:  BTFSC  xB5.6
56B6:  BRA    56C2
56B8:  MOVLW  20
56BA:  BRA    5730
56BC:  MOVLW  20
56BE:  MOVLB  4
56C0:  ANDWF  xB5,F
56C2:  BTFSS  xB5.5
56C4:  BRA    56E6
56C6:  BCF    xB5.5
56C8:  MOVF   xB4,W
56CA:  BTFSS  FD8.2
56CC:  DECF   xB5,F
56CE:  MOVF   00,W
56D0:  MOVWF  xB5
56D2:  MOVLW  2D
56D4:  MOVLB  5
56D6:  MOVWF  xAF
56D8:  MOVLB  0
56DA:  CALL   33E6
56DE:  MOVLB  4
56E0:  MOVF   xB5,W
56E2:  MOVWF  00
56E4:  CLRF   xB5
56E6:  MOVF   xB4,W
56E8:  SUBWF  xB7,W
56EA:  BNZ   5708
56EC:  MOVF   00,W
56EE:  MOVWF  xB5
56F0:  MOVLW  2E
56F2:  MOVLB  5
56F4:  MOVWF  xAF
56F6:  MOVLB  0
56F8:  CALL   33E6
56FC:  MOVLB  4
56FE:  MOVF   xB5,W
5700:  MOVWF  00
5702:  MOVLW  20
5704:  ANDWF  xB5,F
5706:  MOVLW  00
5708:  MOVLW  30
570A:  BTFSS  xB5.5
570C:  BRA    5730
570E:  BCF    xB5.5
5710:  MOVF   xB4,W
5712:  BTFSS  FD8.2
5714:  DECF   xB5,F
5716:  MOVF   00,W
5718:  MOVWF  xB5
571A:  MOVLW  2D
571C:  MOVLB  5
571E:  MOVWF  xAF
5720:  MOVLB  0
5722:  CALL   33E6
5726:  MOVLB  4
5728:  MOVF   xB5,W
572A:  MOVWF  00
572C:  CLRF   xB5
572E:  MOVLW  30
5730:  ADDWF  00,F
5732:  MOVFF  00,5AF
5736:  MOVLB  0
5738:  CALL   33E6
573C:  MOVLB  4
573E:  BCF    FD8.1
5740:  MOVFF  4BC,5C7
5744:  MOVFF  4BB,5C6
5748:  MOVFF  4BA,5C5
574C:  MOVFF  4B9,5C4
5750:  MOVLB  5
5752:  CLRF   xCB
5754:  CLRF   xCA
5756:  CLRF   xC9
5758:  MOVLW  0A
575A:  MOVWF  xC8
575C:  MOVLB  0
575E:  CALL   11D2
5762:  MOVFF  03,4BC
5766:  MOVFF  02,4BB
576A:  MOVFF  01,4BA
576E:  MOVFF  00,4B9
5772:  MOVLB  4
5774:  DECFSZ xB7,F
5776:  BRA    5660
5778:  MOVLB  0
577A:  RETURN 0
577C:  MOVLW  8E
577E:  MOVWF  00
5780:  MOVLB  4
5782:  MOVF   xB0,W
5784:  SUBWF  00,F
5786:  MOVFF  4B1,02
578A:  MOVFF  4B2,01
578E:  BSF    02.7
5790:  MOVF   00,F
5792:  BZ    57A6
5794:  BCF    FD8.0
5796:  MOVF   02,F
5798:  BNZ   579E
579A:  MOVF   01,F
579C:  BZ    57A6
579E:  RRCF   02,F
57A0:  RRCF   01,F
57A2:  DECFSZ 00,F
57A4:  BRA    5794
57A6:  BTFSS  xB1.7
57A8:  BRA    57B4
57AA:  COMF   01,F
57AC:  COMF   02,F
57AE:  INCF   01,F
57B0:  BTFSC  FD8.2
57B2:  INCF   02,F
57B4:  MOVLB  0
57B6:  RETURN 0
*
68FA:  TBLRD*+
68FC:  MOVFF  FF6,4A2
6900:  MOVFF  FF7,4A3
6904:  MOVFF  FF5,5AF
6908:  CALL   33E6
690C:  MOVFF  4A2,FF6
6910:  MOVFF  4A3,FF7
6914:  MOVLB  4
6916:  DECFSZ xA1,F
6918:  BRA    691C
691A:  BRA    6920
691C:  MOVLB  0
691E:  BRA    68FA
6920:  MOVLB  0
6922:  RETURN 0
6924:  MOVLW  20
6926:  MOVLB  4
6928:  BTFSS  xA2.4
692A:  MOVLW  30
692C:  MOVWF  xA3
692E:  MOVFF  4A1,00
6932:  BTFSS  xA1.7
6934:  BRA    6946
6936:  COMF   00,F
6938:  INCF   00,F
693A:  MOVFF  00,4A1
693E:  MOVLW  2D
6940:  MOVWF  xA3
6942:  BSF    xA2.7
6944:  BSF    xA2.0
6946:  MOVF   01,W
6948:  MOVFF  4A1,4CB
694C:  MOVLW  64
694E:  MOVWF  xCC
6950:  MOVLB  0
6952:  CALL   3EF0
6956:  MOVFF  00,4A1
695A:  MOVLW  30
695C:  ADDWF  01,W
695E:  MOVLB  4
6960:  MOVWF  xA4
6962:  MOVFF  4A1,4CB
6966:  MOVLW  0A
6968:  MOVWF  xCC
696A:  MOVLB  0
696C:  CALL   3EF0
6970:  MOVLW  30
6972:  ADDWF  00,W
6974:  MOVLB  4
6976:  MOVWF  xA6
6978:  MOVLW  30
697A:  ADDWF  01,W
697C:  MOVWF  xA5
697E:  MOVFF  4A3,00
6982:  MOVLW  30
6984:  SUBWF  xA4,W
6986:  BZ    6990
6988:  BSF    xA2.1
698A:  BTFSC  xA2.7
698C:  BSF    xA2.2
698E:  BRA    69B4
6990:  MOVFF  4A3,4A4
6994:  MOVLW  20
6996:  MOVWF  xA3
6998:  MOVLW  30
699A:  SUBWF  xA5,W
699C:  BZ    69A6
699E:  BSF    xA2.0
69A0:  BTFSC  xA2.7
69A2:  BSF    xA2.1
69A4:  BRA    69B4
69A6:  BTFSS  FD8.2
69A8:  BSF    xA2.0
69AA:  BNZ   69B4
69AC:  MOVFF  4A4,4A5
69B0:  MOVLW  20
69B2:  MOVWF  xA4
69B4:  BTFSC  xA2.2
69B6:  BRA    69C2
69B8:  BTFSC  xA2.1
69BA:  BRA    69CC
69BC:  BTFSC  xA2.0
69BE:  BRA    69D6
69C0:  BRA    69E0
69C2:  MOVFF  4A3,5AF
69C6:  MOVLB  0
69C8:  CALL   33E6
69CC:  MOVFF  4A4,5AF
69D0:  MOVLB  0
69D2:  CALL   33E6
69D6:  MOVFF  4A5,5AF
69DA:  MOVLB  0
69DC:  CALL   33E6
69E0:  MOVFF  4A6,5AF
69E4:  MOVLB  0
69E6:  CALL   33E6
69EA:  GOTO   7238 (RETURN)
69EE:  MOVFF  FEA,4A9
69F2:  MOVFF  FE9,4A8
69F6:  MOVLB  4
69F8:  SWAPF  xA2,W
69FA:  IORLW  F0
69FC:  MOVWF  xA4
69FE:  ADDWF  xA4,F
6A00:  ADDLW  E2
6A02:  MOVWF  xA5
6A04:  ADDLW  32
6A06:  MOVWF  xA7
6A08:  MOVF   xA2,W
6A0A:  ANDLW  0F
6A0C:  ADDWF  xA5,F
6A0E:  ADDWF  xA5,F
6A10:  ADDWF  xA7,F
6A12:  ADDLW  E9
6A14:  MOVWF  xA6
6A16:  ADDWF  xA6,F
6A18:  ADDWF  xA6,F
6A1A:  SWAPF  xA1,W
6A1C:  ANDLW  0F
6A1E:  ADDWF  xA6,F
6A20:  ADDWF  xA7,F
6A22:  RLCF   xA6,F
6A24:  RLCF   xA7,F
6A26:  COMF   xA7,F
6A28:  RLCF   xA7,F
6A2A:  MOVF   xA1,W
6A2C:  ANDLW  0F
6A2E:  ADDWF  xA7,F
6A30:  RLCF   xA4,F
6A32:  MOVLW  07
6A34:  MOVWF  xA3
6A36:  MOVLW  0A
6A38:  DECF   xA6,F
6A3A:  ADDWF  xA7,F
6A3C:  BNC   6A38
6A3E:  DECF   xA5,F
6A40:  ADDWF  xA6,F
6A42:  BNC   6A3E
6A44:  DECF   xA4,F
6A46:  ADDWF  xA5,F
6A48:  BNC   6A44
6A4A:  DECF   xA3,F
6A4C:  ADDWF  xA4,F
6A4E:  BNC   6A4A
6A50:  MOVLW  04
6A52:  MOVWF  FEA
6A54:  MOVLW  A3
6A56:  MOVWF  FE9
6A58:  MOVLW  07
6A5A:  ANDWF  xA8,W
6A5C:  BCF    xA8.6
6A5E:  ADDWF  FE9,F
6A60:  MOVLW  00
6A62:  ADDWFC FEA,F
6A64:  MOVF   FE9,W
6A66:  SUBLW  A7
6A68:  BNZ   6A72
6A6A:  MOVF   FEA,W
6A6C:  SUBLW  04
6A6E:  BNZ   6A72
6A70:  BSF    xA8.6
6A72:  MOVF   FEF,W
6A74:  MOVWF  00
6A76:  BNZ   6A88
6A78:  BTFSC  xA8.6
6A7A:  BRA    6A88
6A7C:  BTFSC  xA8.4
6A7E:  BRA    6AAC
6A80:  BTFSC  xA8.3
6A82:  BRA    6A88
6A84:  MOVLW  20
6A86:  BRA    6A8E
6A88:  BSF    xA8.3
6A8A:  BCF    xA8.4
6A8C:  MOVLW  30
6A8E:  ADDWF  00,F
6A90:  MOVFF  FEA,4A2
6A94:  MOVFF  FE9,4A1
6A98:  MOVFF  00,5AF
6A9C:  MOVLB  0
6A9E:  CALL   33E6
6AA2:  MOVFF  4A2,FEA
6AA6:  MOVFF  4A1,FE9
6AAA:  MOVLB  4
6AAC:  MOVF   FEE,W
6AAE:  BTFSS  xA8.6
6AB0:  BRA    6A64
6AB2:  MOVLB  0
6AB4:  RETURN 0
6AB6:  MOVF   FEF,F
6AB8:  BZ    6ADA
6ABA:  MOVFF  FEA,4A2
6ABE:  MOVFF  FE9,4A1
6AC2:  MOVF   FEF,W
6AC4:  BTFSS  F9E.4
6AC6:  BRA    6AC4
6AC8:  MOVWF  FAD
6ACA:  MOVFF  4A2,FEA
6ACE:  MOVFF  4A1,FE9
6AD2:  INCF   FE9,F
6AD4:  BTFSC  FD8.2
6AD6:  INCF   FEA,F
6AD8:  BRA    6AB6
6ADA:  GOTO   72CC (RETURN)
*
6B14:  MOVLW  8E
6B16:  MOVWF  00
6B18:  MOVFF  4A4,01
6B1C:  MOVFF  4A3,02
6B20:  CLRF   03
6B22:  BTFSS  01.7
6B24:  BRA    6B30
6B26:  COMF   01,F
6B28:  COMF   02,F
6B2A:  INCF   02,F
6B2C:  BNZ   6B30
6B2E:  INCF   01,F
6B30:  MOVF   01,F
6B32:  BNZ   6B46
6B34:  MOVFF  02,01
6B38:  CLRF   02
6B3A:  MOVLW  08
6B3C:  SUBWF  00,F
6B3E:  MOVF   01,F
6B40:  BNZ   6B46
6B42:  CLRF   00
6B44:  BRA    6B60
6B46:  BCF    FD8.0
6B48:  BTFSC  01.7
6B4A:  BRA    6B54
6B4C:  RLCF   02,F
6B4E:  RLCF   01,F
6B50:  DECF   00,F
6B52:  BRA    6B46
6B54:  MOVLB  4
6B56:  BTFSS  xA4.7
6B58:  BRA    6B5E
6B5A:  MOVLB  0
6B5C:  BRA    6B60
6B5E:  BCF    01.7
6B60:  MOVLB  0
6B62:  GOTO   7438 (RETURN)
....................  
.................... #list 
....................  
.................... #device PASS_STRINGS = IN_RAM 
.................... #DEVICE ADC = 10 
.................... #fuses HSPLL, MCLR, WDT, NOPROTECT, NOLVP, NODEBUG, USBDIV, PLL5, CPUDIV1, VREGEN 
.................... #use delay(clock = 48000000) 
*
02EE:  MOVLW  01
02F0:  MOVLB  6
02F2:  SUBWF  x08,F
02F4:  BNC   0310
02F6:  MOVLW  06
02F8:  MOVWF  FEA
02FA:  MOVLW  08
02FC:  MOVWF  FE9
02FE:  MOVF   FEF,W
0300:  BZ    0310
0302:  MOVLW  02
0304:  MOVWF  00
0306:  DECFSZ 00,F
0308:  BRA    0306
030A:  BRA    030C
030C:  DECFSZ FEF,F
030E:  BRA    0302
0310:  MOVLB  0
0312:  RETURN 0
*
0482:  MOVLW  04
0484:  MOVWF  FEA
0486:  MOVLW  BA
0488:  MOVWF  FE9
048A:  MOVF   FEF,W
048C:  BZ    04AA
048E:  MOVLW  0F
0490:  MOVWF  01
0492:  CLRF   00
0494:  DECFSZ 00,F
0496:  BRA    0494
0498:  DECFSZ 01,F
049A:  BRA    0492
049C:  MOVLW  8F
049E:  MOVWF  00
04A0:  DECFSZ 00,F
04A2:  BRA    04A0
04A4:  NOP   
04A6:  DECFSZ FEF,F
04A8:  BRA    048E
04AA:  RETURN 0
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_D4, rcv = PIN_D5, bits = 8, stream = COM2) // thiet lap UART mem chuan rs485 bo moi nhat giao tiep voi RS485 
*
4876:  BCF    F95.4
4878:  BCF    F8C.4
487A:  MOVLW  08
487C:  MOVWF  01
487E:  BRA    4880
4880:  NOP   
4882:  BSF    01.7
4884:  BRA    48A6
4886:  BCF    01.7
4888:  MOVLB  4
488A:  RRCF   xCF,F
488C:  MOVLB  0
488E:  BTFSC  FD8.0
4890:  BSF    F8C.4
4892:  BTFSS  FD8.0
4894:  BCF    F8C.4
4896:  BSF    01.6
4898:  BRA    48A6
489A:  BCF    01.6
489C:  DECFSZ 01,F
489E:  BRA    4888
48A0:  BRA    48A2
48A2:  NOP   
48A4:  BSF    F8C.4
48A6:  MOVLW  01
48A8:  MOVWF  00
48AA:  CLRF   FE9
48AC:  DECFSZ FE9,F
48AE:  BRA    48AC
48B0:  DECFSZ 00,F
48B2:  BRA    48AA
48B4:  MOVLW  99
48B6:  MOVWF  FE9
48B8:  DECFSZ FE9,F
48BA:  BRA    48B8
48BC:  NOP   
48BE:  BTFSC  01.7
48C0:  BRA    4886
48C2:  BTFSC  01.6
48C4:  BRA    489A
48C6:  RETURN 0
*
4B5A:  BSF    F95.5
4B5C:  BTFSC  F83.5
4B5E:  BRA    4B5C
4B60:  MOVLW  08
4B62:  MOVWF  00
4B64:  MOVLB  4
4B66:  CLRF   xCE
4B68:  BSF    00.7
4B6A:  BRA    4B88
4B6C:  BCF    00.7
4B6E:  BRA    4B88
4B70:  BCF    FD8.0
4B72:  BTFSC  F83.5
4B74:  BSF    FD8.0
4B76:  RRCF   xCE,F
4B78:  BSF    00.6
4B7A:  BRA    4B88
4B7C:  BCF    00.6
4B7E:  DECFSZ 00,F
4B80:  BRA    4B70
4B82:  MOVFF  4CE,01
4B86:  BRA    4BB2
4B88:  MOVLW  01
4B8A:  MOVWF  FE9
4B8C:  MOVLW  00
4B8E:  BTFSC  00.7
4B90:  MOVLW  55
4B92:  MOVWF  01
4B94:  DECFSZ 01,F
4B96:  BRA    4B94
4B98:  DECFSZ FE9,F
4B9A:  BRA    4B8C
4B9C:  MOVLW  98
4B9E:  BTFSC  00.7
4BA0:  MOVLW  29
4BA2:  MOVWF  01
4BA4:  DECFSZ 01,F
4BA6:  BRA    4BA4
4BA8:  BTFSC  00.7
4BAA:  BRA    4B6C
4BAC:  BTFSC  00.6
4BAE:  BRA    4B7C
4BB0:  BRA    4B70
4BB2:  MOVLB  0
4BB4:  GOTO   4C16 (RETURN)
.................... #use rs232(baud = 4800, parity = N, xmit = PIN_D4, rcv = PIN_D5, bits = 8, stream = COM3) // thiet lap UART mem chuan rs485 bo moi nhat giao tiep voi RS485 
*
4ABE:  BCF    F95.4
4AC0:  BCF    F8C.4
4AC2:  MOVLW  08
4AC4:  MOVWF  01
4AC6:  BRA    4AC8
4AC8:  NOP   
4ACA:  BSF    01.7
4ACC:  BRA    4AEE
4ACE:  BCF    01.7
4AD0:  MOVLB  4
4AD2:  RRCF   xCF,F
4AD4:  MOVLB  0
4AD6:  BTFSC  FD8.0
4AD8:  BSF    F8C.4
4ADA:  BTFSS  FD8.0
4ADC:  BCF    F8C.4
4ADE:  BSF    01.6
4AE0:  BRA    4AEE
4AE2:  BCF    01.6
4AE4:  DECFSZ 01,F
4AE6:  BRA    4AD0
4AE8:  BRA    4AEA
4AEA:  NOP   
4AEC:  BSF    F8C.4
4AEE:  MOVLW  03
4AF0:  MOVWF  00
4AF2:  CLRF   FE9
4AF4:  DECFSZ FE9,F
4AF6:  BRA    4AF4
4AF8:  DECFSZ 00,F
4AFA:  BRA    4AF2
4AFC:  MOVLW  37
4AFE:  MOVWF  FE9
4B00:  DECFSZ FE9,F
4B02:  BRA    4B00
4B04:  BRA    4B06
4B06:  NOP   
4B08:  BTFSC  01.7
4B0A:  BRA    4ACE
4B0C:  BTFSC  01.6
4B0E:  BRA    4AE2
4B10:  GOTO   4B4E (RETURN)
*
4C46:  BSF    F95.5
4C48:  BTFSC  F83.5
4C4A:  BRA    4C48
4C4C:  MOVLW  08
4C4E:  MOVWF  00
4C50:  MOVLB  4
4C52:  CLRF   xCE
4C54:  BSF    00.7
4C56:  BRA    4C74
4C58:  BCF    00.7
4C5A:  BRA    4C74
4C5C:  BCF    FD8.0
4C5E:  BTFSC  F83.5
4C60:  BSF    FD8.0
4C62:  RRCF   xCE,F
4C64:  BSF    00.6
4C66:  BRA    4C74
4C68:  BCF    00.6
4C6A:  DECFSZ 00,F
4C6C:  BRA    4C5C
4C6E:  MOVFF  4CE,01
4C72:  BRA    4CA0
4C74:  MOVLW  03
4C76:  MOVWF  FE9
4C78:  MOVLW  00
4C7A:  BTFSC  00.7
4C7C:  MOVLW  55
4C7E:  MOVWF  01
4C80:  DECFSZ 01,F
4C82:  BRA    4C80
4C84:  DECFSZ FE9,F
4C86:  BRA    4C78
4C88:  MOVLW  34
4C8A:  BTFSC  00.7
4C8C:  MOVLW  0E
4C8E:  MOVWF  01
4C90:  DECFSZ 01,F
4C92:  BRA    4C90
4C94:  BRA    4C96
4C96:  BTFSC  00.7
4C98:  BRA    4C58
4C9A:  BTFSC  00.6
4C9C:  BRA    4C68
4C9E:  BRA    4C5C
4CA0:  MOVLB  0
4CA2:  GOTO   4D04 (RETURN)
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C0, rcv = PIN_D2, bits = 8, stream = UART2) 
*
04AC:  BCF    F94.0
04AE:  BCF    F8B.0
04B0:  MOVLW  08
04B2:  MOVWF  01
04B4:  BRA    04B6
04B6:  NOP   
04B8:  BSF    01.7
04BA:  BRA    04DC
04BC:  BCF    01.7
04BE:  MOVLB  4
04C0:  RRCF   xCB,F
04C2:  MOVLB  0
04C4:  BTFSC  FD8.0
04C6:  BSF    F8B.0
04C8:  BTFSS  FD8.0
04CA:  BCF    F8B.0
04CC:  BSF    01.6
04CE:  BRA    04DC
04D0:  BCF    01.6
04D2:  DECFSZ 01,F
04D4:  BRA    04BE
04D6:  BRA    04D8
04D8:  NOP   
04DA:  BSF    F8B.0
04DC:  MOVLW  01
04DE:  MOVWF  00
04E0:  CLRF   FE9
04E2:  DECFSZ FE9,F
04E4:  BRA    04E2
04E6:  DECFSZ 00,F
04E8:  BRA    04E0
04EA:  MOVLW  99
04EC:  MOVWF  FE9
04EE:  DECFSZ FE9,F
04F0:  BRA    04EE
04F2:  NOP   
04F4:  BTFSC  01.7
04F6:  BRA    04BC
04F8:  BTFSC  01.6
04FA:  BRA    04D0
04FC:  RETURN 0
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1SIM) 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include ".\_inc\types.h" 
.................... /*** FILEHEADER **************************************************************** 
....................  * 
....................  *	FILENAME:    types.h 
....................  *	DATE:        21.11.2004 
....................  *	AUTHOR:		 Christian Stadler 
....................  * 
....................  *	DESCRIPTION: Definition of common types. 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... /*** HISTORY OF CHANGE ********************************************************* 
....................  * 
....................  *	$Log: /pic/_inc/types.h $ 
....................  *  
....................  * 3     1.11.10 11:42 Stadler 
....................  * - type definitons dependend on compiler 
....................  *  
....................  * 2     26.02.05 18:44 Stadler 
....................  * added bool type 
....................  *  
....................  ******************************************************************************/ 
....................  
.................... #ifndef _TYPES_H 
.................... #define _TYPES_H 
....................  
.................... /*---------------------------------------------------------------------------*/ 
.................... /* Type definitions for Microchip C18 Compiler                               */ 
.................... /*---------------------------------------------------------------------------*/ 
.................... #if defined(__18CXX) 
....................  
.................... typedef unsigned char bool; 
.................... typedef signed char sint8; 
.................... typedef signed int sint16; 
.................... typedef signed long sint32; 
.................... typedef unsigned char  uint8; 
.................... typedef unsigned int uint16; 
.................... typedef unsigned long uint32; 
....................  
.................... #endif /* #if defined(__18CXX) */ 
....................  
....................  
....................  
.................... /*---------------------------------------------------------------------------*/ 
.................... /* Type definitions for CCS C Compiler                                       */ 
.................... /*---------------------------------------------------------------------------*/ 
.................... #if (defined(__PCB__) || defined(__PCH__) || defined(__PCM__)) 
....................  
.................... typedef int1 bool; 
.................... typedef signed int8 sint8; 
.................... typedef signed int16 sint16; 
.................... typedef signed int32 sint32; 
.................... typedef unsigned int8  uint8; 
.................... typedef unsigned int16 uint16; 
.................... typedef unsigned int32 uint32; 
....................  
.................... #endif /* (defined(__PCB__) || defined(__PCH__) || defined(__PCM__)) */ 
....................  
.................... #endif /*_TYPES_H */ 
....................  
.................... #include <stdlib.h> // for atoi32 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
17B0:  MOVLB  5
17B2:  MOVFF  572,FE9
17B6:  MOVFF  573,FEA
17BA:  MOVFF  FEF,576
17BE:  MOVFF  575,03
17C2:  MOVFF  574,FE9
17C6:  MOVFF  575,FEA
17CA:  MOVF   FEF,W
17CC:  SUBWF  x76,W
17CE:  BNZ   17FA
....................       if (*s1 == '\0') 
17D0:  MOVFF  573,03
17D4:  MOVFF  572,FE9
17D8:  MOVFF  03,FEA
17DC:  MOVF   FEF,F
17DE:  BNZ   17E6
....................          return(0); 
17E0:  MOVLW  00
17E2:  MOVWF  01
17E4:  BRA    1824
17E6:  MOVFF  573,03
17EA:  MOVF   x72,W
17EC:  INCF   x72,F
17EE:  BTFSC  FD8.2
17F0:  INCF   x73,F
17F2:  INCF   x74,F
17F4:  BTFSC  FD8.2
17F6:  INCF   x75,F
17F8:  BRA    17B2
....................    return((*s1 < *s2) ? -1: 1); 
17FA:  MOVFF  573,03
17FE:  MOVFF  572,FE9
1802:  MOVFF  573,FEA
1806:  MOVFF  FEF,576
180A:  MOVFF  575,03
180E:  MOVFF  574,FE9
1812:  MOVFF  575,FEA
1816:  MOVF   FEF,W
1818:  SUBWF  x76,W
181A:  BC    1820
181C:  MOVLW  FF
181E:  BRA    1822
1820:  MOVLW  01
1822:  MOVWF  01
1824:  MOVLB  0
1826:  GOTO   2952 (RETURN)
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3BDA:  MOVFF  4AF,4B3
3BDE:  MOVFF  4AE,4B2
3BE2:  MOVFF  4B3,03
3BE6:  MOVLB  4
3BE8:  MOVFF  4B2,FE9
3BEC:  MOVFF  4B3,FEA
3BF0:  MOVF   FEF,F
3BF2:  BZ    3C48
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
3BF4:  MOVFF  4B1,4B5
3BF8:  MOVFF  4B0,4B4
3BFC:  MOVFF  4B5,03
3C00:  MOVFF  4B4,FE9
3C04:  MOVFF  4B5,FEA
3C08:  MOVF   FEF,F
3C0A:  BZ    3C3C
....................          if (*sc1 == *sc2) 
3C0C:  MOVFF  4B2,FE9
3C10:  MOVFF  4B3,FEA
3C14:  MOVFF  FEF,4B6
3C18:  MOVFF  4B5,03
3C1C:  MOVFF  4B4,FE9
3C20:  MOVFF  4B5,FEA
3C24:  MOVF   FEF,W
3C26:  SUBWF  xB6,W
3C28:  BNZ   3C34
....................             return(sc1); 
3C2A:  MOVFF  4B2,01
3C2E:  MOVFF  4B3,02
3C32:  BRA    3C4E
3C34:  INCF   xB4,F
3C36:  BTFSC  FD8.2
3C38:  INCF   xB5,F
3C3A:  BRA    3BFC
3C3C:  INCF   xB2,F
3C3E:  BTFSC  FD8.2
3C40:  INCF   xB3,F
3C42:  MOVLB  0
3C44:  BRA    3BE2
3C46:  MOVLB  4
....................    return(0); 
3C48:  MOVLW  00
3C4A:  MOVWF  01
3C4C:  MOVWF  02
3C4E:  MOVLB  0
3C50:  GOTO   3CBA (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3B4A:  MOVFF  4AF,4B3
3B4E:  MOVFF  4AE,4B2
3B52:  MOVFF  4B3,03
3B56:  MOVLB  4
3B58:  MOVFF  4B2,FE9
3B5C:  MOVFF  4B3,FEA
3B60:  MOVF   FEF,F
3B62:  BZ    3BC4
....................       for (sc2 = s2; ; sc2++) 
3B64:  MOVFF  4B1,4B5
3B68:  MOVFF  4B0,4B4
....................     if (*sc2 == '\0') 
3B6C:  MOVFF  4B5,03
3B70:  MOVFF  4B4,FE9
3B74:  MOVFF  4B5,FEA
3B78:  MOVF   FEF,F
3B7A:  BNZ   3B90
....................        return(sc1 - s1); 
3B7C:  MOVF   xAE,W
3B7E:  SUBWF  xB2,W
3B80:  MOVWF  00
3B82:  MOVF   xAF,W
3B84:  SUBWFB xB3,W
3B86:  MOVWF  03
3B88:  MOVFF  00,01
3B8C:  BRA    3BD4
3B8E:  BRA    3BB0
....................          else if (*sc1 == *sc2) 
3B90:  MOVFF  4B2,FE9
3B94:  MOVFF  4B3,FEA
3B98:  MOVFF  FEF,4B6
3B9C:  MOVFF  4B5,03
3BA0:  MOVFF  4B4,FE9
3BA4:  MOVFF  4B5,FEA
3BA8:  MOVF   FEF,W
3BAA:  SUBWF  xB6,W
3BAC:  BNZ   3BB0
....................             break; 
3BAE:  BRA    3BB8
3BB0:  INCF   xB4,F
3BB2:  BTFSC  FD8.2
3BB4:  INCF   xB5,F
3BB6:  BRA    3B6C
3BB8:  INCF   xB2,F
3BBA:  BTFSC  FD8.2
3BBC:  INCF   xB3,F
3BBE:  MOVLB  0
3BC0:  BRA    3B52
3BC2:  MOVLB  4
....................    return(sc1 - s1); 
3BC4:  MOVF   xAE,W
3BC6:  SUBWF  xB2,W
3BC8:  MOVWF  00
3BCA:  MOVF   xAF,W
3BCC:  SUBWFB xB3,W
3BCE:  MOVWF  03
3BD0:  MOVFF  00,01
3BD4:  MOVLB  0
3BD6:  GOTO   3C84 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
105E:  MOVFF  5AE,5B0
1062:  MOVFF  5AD,5AF
1066:  MOVFF  5B0,03
106A:  MOVLB  5
106C:  MOVFF  5AF,FE9
1070:  MOVFF  5B0,FEA
1074:  MOVF   FEF,F
1076:  BZ    1084
1078:  INCF   xAF,F
107A:  BTFSC  FD8.2
107C:  INCF   xB0,F
107E:  MOVLB  0
1080:  BRA    1066
1082:  MOVLB  5
....................    return(sc - s); 
1084:  MOVF   xAD,W
1086:  SUBWF  xAF,W
1088:  MOVWF  00
108A:  MOVF   xAE,W
108C:  SUBWFB xB0,W
108E:  MOVWF  03
1090:  MOVFF  00,01
1094:  MOVWF  02
1096:  MOVLB  0
1098:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
3C54:  MOVLB  4
3C56:  MOVF   xA6,W
3C58:  IORWF  xA7,W
3C5A:  BZ    3C64
3C5C:  MOVFF  4A7,03
3C60:  MOVF   xA6,W
3C62:  BRA    3C6A
3C64:  MOVFF  1B,03
3C68:  MOVF   1A,W
3C6A:  MOVWF  xAA
3C6C:  MOVFF  03,4AB
....................    beg += strspn(beg, s2); 
3C70:  MOVFF  4AB,4AF
3C74:  MOVFF  4AA,4AE
3C78:  MOVFF  4A9,4B1
3C7C:  MOVFF  4A8,4B0
3C80:  MOVLB  0
3C82:  BRA    3B4A
3C84:  MOVF   01,W
3C86:  MOVLB  4
3C88:  ADDWF  xAA,F
3C8A:  MOVLW  00
3C8C:  ADDWFC xAB,F
....................    if (*beg == '\0') 
3C8E:  MOVFF  4AB,03
3C92:  MOVFF  4AA,FE9
3C96:  MOVFF  4AB,FEA
3C9A:  MOVF   FEF,F
3C9C:  BNZ   3CA6
....................       return(0); 
3C9E:  MOVLW  00
3CA0:  MOVWF  01
3CA2:  MOVWF  02
3CA4:  BRA    3D0A
....................        
....................    end = strpbrk(beg, s2); 
3CA6:  MOVFF  4AB,4AF
3CAA:  MOVFF  4AA,4AE
3CAE:  MOVFF  4A9,4B1
3CB2:  MOVFF  4A8,4B0
3CB6:  MOVLB  0
3CB8:  BRA    3BDA
3CBA:  MOVFF  02,4AD
3CBE:  MOVFF  01,4AC
....................    if (end != '\0') 
3CC2:  MOVLB  4
3CC4:  MOVF   xAC,F
3CC6:  BNZ   3CCC
3CC8:  MOVF   xAD,F
3CCA:  BZ    3CE6
....................    { 
....................       *end = '\0'; 
3CCC:  MOVFF  4AC,FE9
3CD0:  MOVFF  4AD,FEA
3CD4:  CLRF   FEF
....................       end++; 
3CD6:  INCF   xAC,F
3CD8:  BTFSC  FD8.2
3CDA:  INCF   xAD,F
....................       save = end; 
3CDC:  MOVFF  4AD,1B
3CE0:  MOVFF  4AC,1A
....................    } 
3CE4:  BRA    3D02
....................    else 
....................       save = beg + strlen(beg); 
3CE6:  MOVFF  4AB,5AE
3CEA:  MOVFF  4AA,5AD
3CEE:  MOVLB  0
3CF0:  CALL   105E
3CF4:  MOVF   01,W
3CF6:  MOVLB  4
3CF8:  ADDWF  xAA,W
3CFA:  MOVWF  1A
3CFC:  MOVF   02,W
3CFE:  ADDWFC xAB,W
3D00:  MOVWF  1B
....................     
....................    return(beg); 
3D02:  MOVFF  4AA,01
3D06:  MOVFF  4AB,02
3D0A:  MOVLB  0
3D0C:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
3D5E:  MOVLB  4
3D60:  CLRF   xAB
....................    sign = 0; 
3D62:  CLRF   xA9
....................    base = 10; 
3D64:  MOVLW  0A
3D66:  MOVWF  xAA
....................    result = 0; 
3D68:  CLRF   xA8
....................  
....................    if (!s) 
3D6A:  MOVF   xA6,W
3D6C:  IORWF  xA7,W
3D6E:  BNZ   3D76
....................       return 0; 
3D70:  MOVLW  00
3D72:  MOVWF  01
3D74:  BRA    3EEC
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
3D76:  MOVF   xAB,W
3D78:  INCF   xAB,F
3D7A:  ADDWF  xA6,W
3D7C:  MOVWF  FE9
3D7E:  MOVLW  00
3D80:  ADDWFC xA7,W
3D82:  MOVWF  FEA
3D84:  MOVFF  FEF,4AC
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
3D88:  MOVF   xAC,W
3D8A:  SUBLW  2D
3D8C:  BNZ   3DA6
....................    { 
....................       sign = 1;         // Set the sign to negative 
3D8E:  MOVLW  01
3D90:  MOVWF  xA9
....................       c = s[index++]; 
3D92:  MOVF   xAB,W
3D94:  INCF   xAB,F
3D96:  ADDWF  xA6,W
3D98:  MOVWF  FE9
3D9A:  MOVLW  00
3D9C:  ADDWFC xA7,W
3D9E:  MOVWF  FEA
3DA0:  MOVFF  FEF,4AC
....................    } 
3DA4:  BRA    3DBE
....................    else if (c == '+') 
3DA6:  MOVF   xAC,W
3DA8:  SUBLW  2B
3DAA:  BNZ   3DBE
....................    { 
....................       c = s[index++]; 
3DAC:  MOVF   xAB,W
3DAE:  INCF   xAB,F
3DB0:  ADDWF  xA6,W
3DB2:  MOVWF  FE9
3DB4:  MOVLW  00
3DB6:  ADDWFC xA7,W
3DB8:  MOVWF  FEA
3DBA:  MOVFF  FEF,4AC
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
3DBE:  MOVF   xAC,W
3DC0:  SUBLW  2F
3DC2:  BTFSC  FD8.0
3DC4:  BRA    3EDC
3DC6:  MOVF   xAC,W
3DC8:  SUBLW  39
3DCA:  BTFSS  FD8.0
3DCC:  BRA    3EDC
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
3DCE:  MOVF   xAC,W
3DD0:  SUBLW  30
3DD2:  BNZ   3E10
3DD4:  MOVF   xAB,W
3DD6:  ADDWF  xA6,W
3DD8:  MOVWF  FE9
3DDA:  MOVLW  00
3DDC:  ADDWFC xA7,W
3DDE:  MOVWF  FEA
3DE0:  MOVF   FEF,W
3DE2:  SUBLW  78
3DE4:  BZ    3DF8
3DE6:  MOVF   xAB,W
3DE8:  ADDWF  xA6,W
3DEA:  MOVWF  FE9
3DEC:  MOVLW  00
3DEE:  ADDWFC xA7,W
3DF0:  MOVWF  FEA
3DF2:  MOVF   FEF,W
3DF4:  SUBLW  58
3DF6:  BNZ   3E10
....................       { 
....................          base = 16; 
3DF8:  MOVLW  10
3DFA:  MOVWF  xAA
....................          index++; 
3DFC:  INCF   xAB,F
....................          c = s[index++]; 
3DFE:  MOVF   xAB,W
3E00:  INCF   xAB,F
3E02:  ADDWF  xA6,W
3E04:  MOVWF  FE9
3E06:  MOVLW  00
3E08:  ADDWFC xA7,W
3E0A:  MOVWF  FEA
3E0C:  MOVFF  FEF,4AC
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
3E10:  MOVF   xAA,W
3E12:  SUBLW  0A
3E14:  BNZ   3E4E
....................       { 
....................          while (c >= '0' && c <= '9') 
3E16:  MOVF   xAC,W
3E18:  SUBLW  2F
3E1A:  BC    3E4C
3E1C:  MOVF   xAC,W
3E1E:  SUBLW  39
3E20:  BNC   3E4C
....................          { 
....................             result = 10*result + (c - '0'); 
3E22:  MOVLW  0A
3E24:  MOVWF  xAD
3E26:  MOVFF  4A8,4AE
3E2A:  MOVLB  0
3E2C:  BRA    3D0E
3E2E:  MOVLW  30
3E30:  MOVLB  4
3E32:  SUBWF  xAC,W
3E34:  ADDWF  01,W
3E36:  MOVWF  xA8
....................             c = s[index++]; 
3E38:  MOVF   xAB,W
3E3A:  INCF   xAB,F
3E3C:  ADDWF  xA6,W
3E3E:  MOVWF  FE9
3E40:  MOVLW  00
3E42:  ADDWFC xA7,W
3E44:  MOVWF  FEA
3E46:  MOVFF  FEF,4AC
3E4A:  BRA    3E16
....................          } 
....................       } 
3E4C:  BRA    3EDC
....................       else if (base == 16)    // The number is a hexa number 
3E4E:  MOVF   xAA,W
3E50:  SUBLW  10
3E52:  BNZ   3EDC
....................       { 
....................          c = toupper(c); 
3E54:  MOVF   xAC,W
3E56:  SUBLW  60
3E58:  BC    3E66
3E5A:  MOVF   xAC,W
3E5C:  SUBLW  7A
3E5E:  BNC   3E66
3E60:  MOVF   xAC,W
3E62:  ANDLW  DF
3E64:  BRA    3E68
3E66:  MOVF   xAC,W
3E68:  MOVWF  xAC
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
3E6A:  MOVF   xAC,W
3E6C:  SUBLW  2F
3E6E:  BC    3E76
3E70:  MOVF   xAC,W
3E72:  SUBLW  39
3E74:  BC    3E82
3E76:  MOVF   xAC,W
3E78:  SUBLW  40
3E7A:  BC    3EDC
3E7C:  MOVF   xAC,W
3E7E:  SUBLW  46
3E80:  BNC   3EDC
....................          { 
....................             if (c >= '0' && c <= '9') 
3E82:  MOVF   xAC,W
3E84:  SUBLW  2F
3E86:  BC    3EA0
3E88:  MOVF   xAC,W
3E8A:  SUBLW  39
3E8C:  BNC   3EA0
....................                result = (result << 4) + (c - '0'); 
3E8E:  SWAPF  xA8,W
3E90:  MOVWF  xAD
3E92:  MOVLW  F0
3E94:  ANDWF  xAD,F
3E96:  MOVLW  30
3E98:  SUBWF  xAC,W
3E9A:  ADDWF  xAD,W
3E9C:  MOVWF  xA8
3E9E:  BRA    3EB2
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
3EA0:  SWAPF  xA8,W
3EA2:  MOVWF  xAD
3EA4:  MOVLW  F0
3EA6:  ANDWF  xAD,F
3EA8:  MOVLW  41
3EAA:  SUBWF  xAC,W
3EAC:  ADDLW  0A
3EAE:  ADDWF  xAD,W
3EB0:  MOVWF  xA8
....................  
....................             c = s[index++]; 
3EB2:  MOVF   xAB,W
3EB4:  INCF   xAB,F
3EB6:  ADDWF  xA6,W
3EB8:  MOVWF  FE9
3EBA:  MOVLW  00
3EBC:  ADDWFC xA7,W
3EBE:  MOVWF  FEA
3EC0:  MOVFF  FEF,4AC
....................             c = toupper(c); 
3EC4:  MOVF   xAC,W
3EC6:  SUBLW  60
3EC8:  BC    3ED6
3ECA:  MOVF   xAC,W
3ECC:  SUBLW  7A
3ECE:  BNC   3ED6
3ED0:  MOVF   xAC,W
3ED2:  ANDLW  DF
3ED4:  BRA    3ED8
3ED6:  MOVF   xAC,W
3ED8:  MOVWF  xAC
3EDA:  BRA    3E6A
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
3EDC:  DECFSZ xA9,W
3EDE:  BRA    3EE8
3EE0:  MOVF   xAA,W
3EE2:  SUBLW  0A
3EE4:  BNZ   3EE8
....................        result = -result; 
3EE6:  NEGF   xA8
....................  
....................    return(result); 
3EE8:  MOVFF  4A8,01
3EEC:  MOVLB  0
3EEE:  RETURN 0
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
5432:  MOVFF  1F,5CD
5436:  MOVFF  1E,5CC
543A:  MOVFF  1D,5CB
543E:  MOVFF  1C,5CA
5442:  MOVLW  41
5444:  MOVLB  5
5446:  MOVWF  xD1
5448:  MOVLW  C6
544A:  MOVWF  xD0
544C:  MOVLW  4E
544E:  MOVWF  xCF
5450:  MOVLW  6D
5452:  MOVWF  xCE
5454:  MOVLB  0
5456:  CALL   0D54
545A:  MOVLW  39
545C:  MOVLB  4
545E:  ADDWF  00,W
5460:  MOVWF  1C
5462:  MOVLW  30
5464:  ADDWFC 01,W
5466:  MOVWF  1D
5468:  MOVLW  00
546A:  ADDWFC 02,W
546C:  MOVWF  1E
546E:  MOVLW  00
5470:  ADDWFC 03,W
5472:  MOVWF  1F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
5474:  MOVFF  1E,00
5478:  MOVFF  1F,01
547C:  CLRF   02
547E:  CLRF   03
5480:  MOVFF  1F,4BE
5484:  MOVFF  1E,4BD
5488:  MOVFF  1F,4C0
548C:  MOVFF  1E,4BF
5490:  MOVLW  7F
5492:  MOVWF  xC2
5494:  SETF   xC1
5496:  MOVLB  0
5498:  RCALL  53EC
549A:  MOVFF  00,01
549E:  MOVFF  03,02
54A2:  GOTO   54DC (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "mmcsd.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           MMCSD.c                               //// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_SPI_XFER 
....................    #if defined(MMCSD_SPI_HW) 
....................       #use spi(MASTER, MMCSD_SPI_HW, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
....................    #else 
....................       #ifndef MMCSD_PIN_SCL 
....................         #define MMCSD_PIN_SCL     PIN_E1 //o   
....................          #define MMCSD_PIN_SDI     PIN_E2 //i          
....................          #define MMCSD_PIN_SDO     PIN_E0 //o                                                                                          
....................          #define MMCSD_PIN_SELECT  PIN_B6 //o 
....................       #endif 
....................     
....................       #use spi(MASTER, DI=MMCSD_PIN_SDI, DO=MMCSD_PIN_SDO, CLK=MMCSD_PIN_SCL, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
*
0526:  MOVLB  6
0528:  MOVF   x00,W
052A:  SUBLW  08
052C:  BZ    053A
052E:  MOVWF  x01
0530:  MOVLB  5
0532:  RLCF   xFF,F
0534:  MOVLB  6
0536:  DECFSZ x01,F
0538:  BRA    0530
053A:  BSF    F96.2
053C:  BCF    F96.0
053E:  BCF    F96.1
0540:  BCF    F8D.1
0542:  MOVFF  600,601
0546:  MOVLB  5
0548:  BTFSS  xFF.7
054A:  BCF    F8D.0
054C:  BTFSC  xFF.7
054E:  BSF    F8D.0
0550:  RLCF   xFF,F
0552:  BSF    F8D.1
0554:  MOVLW  04
0556:  MOVLB  6
0558:  MOVWF  x02
055A:  DECFSZ x02,F
055C:  BRA    055A
055E:  RLCF   01,F
0560:  BTFSS  F84.2
0562:  BCF    01.0
0564:  BTFSC  F84.2
0566:  BSF    01.0
0568:  BCF    F8D.1
056A:  MOVLW  03
056C:  MOVWF  x02
056E:  DECFSZ x02,F
0570:  BRA    056E
0572:  DECFSZ x01,F
0574:  BRA    0546
0576:  MOVLB  0
0578:  RETURN 0
....................    #endif 
....................     
....................    #define MMCSD_SPI_XFER(x)  spi_xfer(mmcsd_spi, x) 
.................... #endif 
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
....................  
.................... enum _card_type{SD, MMC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length); 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1; 
....................  
....................    g_CRC_enabled = TRUE; 
*
0970:  MOVLB  2
0972:  BSF    x20.0
....................    g_mmcsdBufferAddress = 0; 
0974:  CLRF   x24
0976:  CLRF   x23
0978:  CLRF   x22
097A:  CLRF   x21
....................  
....................   #if defined(MMCSD_PIN_SCL) 
....................    output_drive(MMCSD_PIN_SCL); 
097C:  BCF    F96.1
....................   #endif 
....................   #if defined(MMCSD_PIN_SDO) 
....................    output_drive(MMCSD_PIN_SDO); 
097E:  BCF    F96.0
....................   #endif 
....................    output_drive(MMCSD_PIN_SELECT); 
0980:  BCF    F93.6
....................   #if defined(MMCSD_PIN_SDI) 
....................    output_float(MMCSD_PIN_SDI); 
0982:  BSF    F96.2
....................   #endif 
....................  
....................    mmcsd_deselect(); 
0984:  MOVLB  0
0986:  RCALL  057A
....................    delay_ms(15); 
0988:  MOVLW  0F
098A:  MOVLB  4
098C:  MOVWF  xBA
098E:  MOVLB  0
0990:  RCALL  0482
....................        
....................    /* begin initialization */ 
....................    i = 0; 
0992:  MOVLB  4
0994:  CLRF   xB8
....................    do 
....................    { 
....................       delay_ms(1); 
0996:  MOVLW  01
0998:  MOVWF  xBA
099A:  MOVLB  0
099C:  RCALL  0482
....................       mmcsd_select();       
099E:  RCALL  058E
....................       r1=mmcsd_go_idle_state(); 
09A0:  BRA    06C6
09A2:  MOVFF  01,4B9
....................       mmcsd_deselect(); 
09A6:  RCALL  057A
....................       i++; 
09A8:  MOVLB  4
09AA:  INCF   xB8,F
....................       if(i == 0xFF) 
09AC:  INCFSZ xB8,W
09AE:  BRA    09BC
....................       { 
....................          mmcsd_deselect(); 
09B0:  MOVLB  0
09B2:  RCALL  057A
....................          return r1; 
09B4:  MOVLB  4
09B6:  MOVFF  4B9,01
09BA:  BRA    0A70
....................       } 
....................    } while(!bit_test(r1, 0)); 
09BC:  BTFSS  xB9.0
09BE:  BRA    0996
....................  
....................    i = 0; 
09C0:  CLRF   xB8
....................    do 
....................    { 
....................       delay_ms(1); 
09C2:  MOVLW  01
09C4:  MOVWF  xBA
09C6:  MOVLB  0
09C8:  RCALL  0482
....................       mmcsd_select(); 
09CA:  RCALL  058E
....................       r1=mmcsd_send_op_cond(); 
09CC:  BRA    06DE
09CE:  MOVFF  01,4B9
....................       mmcsd_deselect(); 
09D2:  RCALL  057A
....................       i++; 
09D4:  MOVLB  4
09D6:  INCF   xB8,F
....................       if(i == 0xFF) 
09D8:  INCFSZ xB8,W
09DA:  BRA    09E8
....................       { 
....................          mmcsd_deselect(); 
09DC:  MOVLB  0
09DE:  RCALL  057A
....................          return r1; 
09E0:  MOVLB  4
09E2:  MOVFF  4B9,01
09E6:  BRA    0A70
....................       } 
....................    } while(r1 & MMCSD_IDLE); 
09E8:  BTFSC  xB9.0
09EA:  BRA    09C2
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    mmcsd_select(); 
09EC:  MOVLB  0
09EE:  RCALL  058E
....................    r1=mmcsd_app_cmd(); 
09F0:  BRA    06F8
09F2:  MOVFF  01,4B9
....................    r1=mmcsd_sd_send_op_cond(); 
09F6:  BRA    0712
09F8:  MOVFF  01,4B9
....................    mmcsd_deselect(); 
09FC:  RCALL  057A
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
09FE:  MOVLB  4
0A00:  MOVF   xB9,W
0A02:  SUBLW  04
0A04:  BNZ   0A0E
....................       g_card_type = MMC; 
0A06:  MOVLB  2
0A08:  BSF    x20.2
0A0A:  BRA    0A12
0A0C:  MOVLB  4
....................    else 
....................       g_card_type = SD; 
0A0E:  MOVLB  2
0A10:  BCF    x20.2
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
0A12:  MOVLB  0
0A14:  RCALL  058E
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
0A16:  MOVLB  4
0A18:  CLRF   xBD
0A1A:  CLRF   xBC
0A1C:  MOVLW  02
0A1E:  MOVWF  xBB
0A20:  CLRF   xBA
0A22:  MOVLB  0
0A24:  BRA    072C
0A26:  MOVFF  01,4B9
....................    if(r1 != MMCSD_GOODEC) 
0A2A:  MOVLB  4
0A2C:  MOVF   xB9,F
0A2E:  BZ    0A3C
....................    { 
....................       mmcsd_deselect(); 
0A30:  MOVLB  0
0A32:  RCALL  057A
....................       return r1; 
0A34:  MOVLB  4
0A36:  MOVFF  4B9,01
0A3A:  BRA    0A70
....................    } 
....................    mmcsd_deselect(); 
0A3C:  MOVLB  0
0A3E:  RCALL  057A
....................  
.................... /// this would be a good time to set a higher clock speed, 20MHz 
.................... #if defined(MMCSD_SPI_HW) 
....................    #if (getenv("CLOCK") <= 80000000) 
....................       #define MMC_SPI_CLK_DIV SPI_CLK_DIV_4 
....................    #else 
....................       #if defined(SPI_CLK_DIV_8) 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_8 
....................       #else 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_16 
....................       #endif 
....................    #endif 
....................    #error/warning the next line will only work if using SPI1 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | MMC_SPI_CLK_DIV); 
.................... #endif 
....................  
....................    /* turn CRCs off to speed up reading/writing */ 
....................    mmcsd_select(); 
0A40:  RCALL  058E
....................    r1 = mmcsd_crc_on_off(0); 
0A42:  MOVLB  4
0A44:  CLRF   xBA
0A46:  MOVLB  0
0A48:  BRA    074E
0A4A:  MOVFF  01,4B9
....................    if(r1 != MMCSD_GOODEC) 
0A4E:  MOVLB  4
0A50:  MOVF   xB9,F
0A52:  BZ    0A60
....................    { 
....................       mmcsd_deselect(); 
0A54:  MOVLB  0
0A56:  RCALL  057A
....................       return r1; 
0A58:  MOVLB  4
0A5A:  MOVFF  4B9,01
0A5E:  BRA    0A70
....................    } 
....................    mmcsd_deselect(); 
0A60:  MOVLB  0
0A62:  RCALL  057A
....................  
....................    r1 = mmcsd_load_buffer(); 
0A64:  RCALL  0946
0A66:  MOVFF  01,4B9
....................  
....................    return r1; 
0A6A:  MOVLB  4
0A6C:  MOVFF  4B9,01
0A70:  MOVLB  0
0A72:  GOTO   0DB8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
0CAA:  MOVLB  5
0CAC:  CLRF   xC9
0CAE:  CLRF   xC8
0CB0:  MOVF   xC9,W
0CB2:  SUBWF  xC4,W
0CB4:  BNC   0D2A
0CB6:  BNZ   0CBE
0CB8:  MOVF   xC3,W
0CBA:  SUBWF  xC8,W
0CBC:  BC    0D2A
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
0CBE:  MOVFF  5C2,5D3
0CC2:  MOVFF  5C1,02
0CC6:  MOVFF  5C0,01
0CCA:  MOVFF  5BF,00
0CCE:  MOVLW  01
0CD0:  ADDWF  xBF,F
0CD2:  BTFSC  FD8.0
0CD4:  INCF   xC0,F
0CD6:  BTFSC  FD8.2
0CD8:  INCF   xC1,F
0CDA:  BTFSC  FD8.2
0CDC:  INCF   xC2,F
0CDE:  MOVFF  02,5CC
0CE2:  MOVFF  01,5CB
0CE6:  MOVFF  00,5CA
0CEA:  MOVFF  5C6,03
0CEE:  MOVF   xC5,W
0CF0:  INCF   xC5,F
0CF2:  BTFSC  FD8.2
0CF4:  INCF   xC6,F
0CF6:  MOVWF  xCE
0CF8:  MOVFF  03,5CF
0CFC:  MOVFF  02,5D2
0D00:  MOVFF  01,5D1
0D04:  MOVFF  00,5D0
0D08:  MOVFF  03,5D5
0D0C:  MOVWF  xD4
0D0E:  MOVLB  0
0D10:  BRA    0C58
0D12:  MOVFF  01,5C7
....................       if(r1 != MMCSD_GOODEC) 
0D16:  MOVLB  5
0D18:  MOVF   xC7,F
0D1A:  BZ    0D22
....................          return r1; 
0D1C:  MOVFF  5C7,01
0D20:  BRA    0D2E
0D22:  INCF   xC8,F
0D24:  BTFSC  FD8.2
0D26:  INCF   xC9,F
0D28:  BRA    0CB0
....................    } 
....................     
....................    return MMCSD_GOODEC; 
0D2A:  MOVLW  00
0D2C:  MOVWF  01
0D2E:  MOVLB  0
0D30:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
082E:  RCALL  058E
....................    ec = mmcsd_read_single_block(address); 
0830:  MOVFF  5E8,5F3
0834:  MOVFF  5E7,5F2
0838:  MOVFF  5E6,5F1
083C:  MOVFF  5E5,5F0
0840:  BRA    077C
0842:  MOVFF  01,5ED
....................    if(ec != MMCSD_GOODEC) 
0846:  MOVLB  5
0848:  MOVF   xED,F
084A:  BZ    0858
....................    { 
....................       mmcsd_deselect(); 
084C:  MOVLB  0
084E:  RCALL  057A
....................       return ec; 
0850:  MOVLB  5
0852:  MOVFF  5ED,01
0856:  BRA    0940
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
0858:  MOVLW  FE
085A:  MOVWF  xF0
085C:  MOVLB  0
085E:  BRA    079E
0860:  MOVFF  01,5ED
....................    if(ec != MMCSD_GOODEC) 
0864:  MOVLB  5
0866:  MOVF   xED,F
0868:  BZ    0876
....................    { 
....................       mmcsd_deselect(); 
086A:  MOVLB  0
086C:  RCALL  057A
....................       return ec; 
086E:  MOVLB  5
0870:  MOVFF  5ED,01
0874:  BRA    0940
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
0876:  CLRF   xEF
0878:  CLRF   xEE
087A:  MOVF   xEF,W
087C:  SUBWF  xEA,W
087E:  BNC   08B2
0880:  BNZ   0888
0882:  MOVF   xE9,W
0884:  SUBWF  xEE,W
0886:  BC    08B2
....................       ptr[i] = MMCSD_SPI_XFER(0xFF); 
0888:  MOVF   xEB,W
088A:  ADDWF  xEE,W
088C:  MOVWF  FE9
088E:  MOVF   xEC,W
0890:  ADDWFC xEF,W
0892:  MOVWF  FEA
0894:  SETF   xFF
0896:  MOVLW  08
0898:  MOVLB  6
089A:  MOVWF  x00
089C:  MOVLB  0
089E:  RCALL  0526
08A0:  MOVF   01,W
08A2:  MOVFF  01,FEF
08A6:  MOVLW  01
08A8:  MOVLB  5
08AA:  ADDWF  xEE,F
08AC:  MOVLW  00
08AE:  ADDWFC xEF,F
08B0:  BRA    087A
....................  
....................    if(g_CRC_enabled) 
08B2:  MOVLB  2
08B4:  BTFSS  x20.0
08B6:  BRA    0918
....................    { 
....................       /* check the crc */ 
....................       if(make16(MMCSD_SPI_XFER(0xFF), MMCSD_SPI_XFER(0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
08B8:  MOVLB  5
08BA:  SETF   xFF
08BC:  MOVLW  08
08BE:  MOVLB  6
08C0:  MOVWF  x00
08C2:  MOVLB  0
08C4:  RCALL  0526
08C6:  MOVF   01,W
08C8:  MOVFF  01,5F0
08CC:  MOVLB  5
08CE:  SETF   xFF
08D0:  MOVLW  08
08D2:  MOVLB  6
08D4:  MOVWF  x00
08D6:  MOVLB  0
08D8:  RCALL  0526
08DA:  MOVF   01,W
08DC:  MOVFF  01,5F1
08E0:  MOVFF  5F0,5F3
08E4:  MOVFF  01,5F2
08E8:  MOVLB  5
08EA:  CLRF   xF5
08EC:  MOVLW  20
08EE:  MOVWF  xF4
08F0:  CLRF   xF6
08F2:  MOVLB  0
08F4:  RCALL  07BC
08F6:  MOVFF  02,03
08FA:  MOVF   01,W
08FC:  MOVLB  5
08FE:  SUBWF  xF2,W
0900:  BNZ   0908
0902:  MOVF   03,W
0904:  SUBWF  xF3,W
0906:  BZ    0914
....................       { 
....................          mmcsd_deselect(); 
0908:  MOVLB  0
090A:  RCALL  057A
....................          return MMCSD_CRC_ERR; 
090C:  MOVLW  08
090E:  MOVWF  01
0910:  MOVLB  5
0912:  BRA    0940
....................       } 
....................    } 
0914:  BRA    0936
0916:  MOVLB  2
....................    else 
....................    { 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       MMCSD_SPI_XFER(0xFF); 
0918:  MOVLB  5
091A:  SETF   xFF
091C:  MOVLW  08
091E:  MOVLB  6
0920:  MOVWF  x00
0922:  MOVLB  0
0924:  RCALL  0526
....................       MMCSD_SPI_XFER(0xFF); 
0926:  MOVLB  5
0928:  SETF   xFF
092A:  MOVLW  08
092C:  MOVLB  6
092E:  MOVWF  x00
0930:  MOVLB  0
0932:  RCALL  0526
0934:  MOVLB  5
....................    } 
....................    mmcsd_deselect(); 
0936:  MOVLB  0
0938:  RCALL  057A
....................  
....................    return MMCSD_GOODEC; 
093A:  MOVLW  00
093C:  MOVWF  01
093E:  MOVLB  5
0940:  MOVLB  0
0942:  GOTO   096C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
18F4:  MOVLB  5
18F6:  CLRF   xD0
18F8:  CLRF   xCF
18FA:  MOVF   xD0,W
18FC:  SUBWF  xCB,W
18FE:  BNC   1972
1900:  BNZ   1908
1902:  MOVF   xCA,W
1904:  SUBWF  xCF,W
1906:  BC    1972
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
1908:  MOVFF  5C9,5D9
190C:  MOVFF  5C8,02
1910:  MOVFF  5C7,01
1914:  MOVFF  5C6,00
1918:  MOVLW  01
191A:  ADDWF  xC6,F
191C:  BTFSC  FD8.0
191E:  INCF   xC7,F
1920:  BTFSC  FD8.2
1922:  INCF   xC8,F
1924:  BTFSC  FD8.2
1926:  INCF   xC9,F
1928:  MOVFF  02,5D3
192C:  MOVFF  01,5D2
1930:  MOVFF  00,5D1
1934:  MOVFF  5CD,03
1938:  MOVF   xCC,W
193A:  INCF   xCC,F
193C:  BTFSC  FD8.2
193E:  INCF   xCD,F
1940:  MOVWF  FE9
1942:  MOVFF  03,FEA
1946:  MOVFF  FEF,5DA
194A:  MOVFF  02,5D8
194E:  MOVFF  01,5D7
1952:  MOVFF  00,5D6
1956:  MOVLB  0
1958:  BRA    18A6
195A:  MOVFF  01,5CE
....................       if(ec != MMCSD_GOODEC) 
195E:  MOVLB  5
1960:  MOVF   xCE,F
1962:  BZ    196A
....................          return ec; 
1964:  MOVFF  5CE,01
1968:  BRA    1976
196A:  INCF   xCF,F
196C:  BTFSC  FD8.2
196E:  INCF   xD0,F
1970:  BRA    18FA
....................    } 
....................     
....................    return MMCSD_GOODEC; 
1972:  MOVLW  00
1974:  MOVWF  01
1976:  MOVLB  0
1978:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
0A98:  RCALL  058E
....................    ec = mmcsd_write_single_block(address); 
0A9A:  MOVFF  5E8,5F3
0A9E:  MOVFF  5E7,5F2
0AA2:  MOVFF  5E6,5F1
0AA6:  MOVFF  5E5,5F0
0AAA:  BRA    0A76
0AAC:  MOVFF  01,5ED
....................    if(ec != MMCSD_GOODEC) 
0AB0:  MOVLB  5
0AB2:  MOVF   xED,F
0AB4:  BZ    0AC2
....................    { 
....................       mmcsd_deselect(); 
0AB6:  MOVLB  0
0AB8:  RCALL  057A
....................       return ec; 
0ABA:  MOVLB  5
0ABC:  MOVFF  5ED,01
0AC0:  BRA    0B8E
....................    } 
....................     
....................    // send a data start token 
....................    MMCSD_SPI_XFER(DATA_START_TOKEN); 
0AC2:  MOVLW  FE
0AC4:  MOVWF  xFF
0AC6:  MOVLW  08
0AC8:  MOVLB  6
0ACA:  MOVWF  x00
0ACC:  MOVLB  0
0ACE:  RCALL  0526
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
0AD0:  MOVLB  5
0AD2:  CLRF   xEF
0AD4:  CLRF   xEE
0AD6:  MOVF   xEF,W
0AD8:  SUBWF  xEA,W
0ADA:  BNC   0B0A
0ADC:  BNZ   0AE4
0ADE:  MOVF   xE9,W
0AE0:  SUBWF  xEE,W
0AE2:  BC    0B0A
....................    { 
....................       MMCSD_SPI_XFER(ptr[i]); 
0AE4:  MOVF   xEB,W
0AE6:  ADDWF  xEE,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   xEC,W
0AEC:  ADDWFC xEF,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,5FF
0AF4:  MOVLW  08
0AF6:  MOVLB  6
0AF8:  MOVWF  x00
0AFA:  MOVLB  0
0AFC:  RCALL  0526
0AFE:  MOVLW  01
0B00:  MOVLB  5
0B02:  ADDWF  xEE,F
0B04:  MOVLW  00
0B06:  ADDWFC xEF,F
0B08:  BRA    0AD6
....................    } 
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
....................    if(g_CRC_enabled) 
0B0A:  MOVLB  2
0B0C:  BTFSS  x20.0
0B0E:  BRA    0B3A
....................       MMCSD_SPI_XFER(mmcsd_crc16(ptr, size)); 
0B10:  MOVFF  5EC,5F5
0B14:  MOVFF  5EB,5F4
0B18:  MOVFF  5E9,5F6
0B1C:  MOVLB  0
0B1E:  RCALL  07BC
0B20:  MOVFF  02,5F1
0B24:  MOVFF  01,5F0
0B28:  MOVFF  01,5FF
0B2C:  MOVLW  08
0B2E:  MOVLB  6
0B30:  MOVWF  x00
0B32:  MOVLB  0
0B34:  RCALL  0526
0B36:  BRA    0B56
0B38:  MOVLB  2
....................    else 
....................    { 
....................       MMCSD_SPI_XFER(0xFF); 
0B3A:  MOVLB  5
0B3C:  SETF   xFF
0B3E:  MOVLW  08
0B40:  MOVLB  6
0B42:  MOVWF  x00
0B44:  MOVLB  0
0B46:  RCALL  0526
....................       MMCSD_SPI_XFER(0xFF); 
0B48:  MOVLB  5
0B4A:  SETF   xFF
0B4C:  MOVLW  08
0B4E:  MOVLB  6
0B50:  MOVWF  x00
0B52:  MOVLB  0
0B54:  RCALL  0526
....................    } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
0B56:  RCALL  0690
0B58:  MOVFF  01,5ED
....................    if(ec & 0x0A) 
0B5C:  MOVLB  5
0B5E:  MOVF   xED,W
0B60:  ANDLW  0A
0B62:  BZ    0B70
....................    { 
....................       mmcsd_deselect(); 
0B64:  MOVLB  0
0B66:  RCALL  057A
....................       return ec; 
0B68:  MOVLB  5
0B6A:  MOVFF  5ED,01
0B6E:  BRA    0B8E
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(MMCSD_SPI_XFER(0xFF) == 0); 
0B70:  SETF   xFF
0B72:  MOVLW  08
0B74:  MOVLB  6
0B76:  MOVWF  x00
0B78:  MOVLB  0
0B7A:  RCALL  0526
0B7C:  MOVF   01,W
0B7E:  BTFSS  FD8.2
0B80:  BRA    0B86
0B82:  MOVLB  5
0B84:  BRA    0B70
....................    mmcsd_deselect(); 
0B86:  RCALL  057A
....................  
....................    return MMCSD_GOODEC; 
0B88:  MOVLW  00
0B8A:  MOVWF  01
0B8C:  MOVLB  5
0B8E:  MOVLB  0
0B90:  GOTO   0BBE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
06C6:  MOVLB  5
06C8:  CLRF   xF4
06CA:  CLRF   xF8
06CC:  CLRF   xF7
06CE:  CLRF   xF6
06D0:  CLRF   xF5
06D2:  MOVLB  0
06D4:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
06D6:  RCALL  0690
06D8:  MOVF   01,W
06DA:  GOTO   09A2 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
06DE:  MOVLW  01
06E0:  MOVLB  5
06E2:  MOVWF  xF4
06E4:  CLRF   xF8
06E6:  CLRF   xF7
06E8:  CLRF   xF6
06EA:  CLRF   xF5
06EC:  MOVLB  0
06EE:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
06F0:  RCALL  0690
06F2:  MOVF   01,W
06F4:  GOTO   09CE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x45A); 
....................  
....................    return mmcsd_get_r7(r7); 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       MMCSD_SPI_XFER(0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
072C:  MOVLW  10
072E:  MOVLB  5
0730:  MOVWF  xF4
0732:  MOVFF  4BD,5F8
0736:  MOVFF  4BC,5F7
073A:  MOVFF  4BB,5F6
073E:  MOVFF  4BA,5F5
0742:  MOVLB  0
0744:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
0746:  RCALL  0690
0748:  MOVF   01,W
074A:  GOTO   0A26 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
077C:  MOVLW  11
077E:  MOVLB  5
0780:  MOVWF  xF4
0782:  MOVFF  5F3,5F8
0786:  MOVFF  5F2,5F7
078A:  MOVFF  5F1,5F6
078E:  MOVFF  5F0,5F5
0792:  MOVLB  0
0794:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
0796:  RCALL  0690
0798:  MOVF   01,W
079A:  GOTO   0842 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
0A76:  MOVLW  18
0A78:  MOVLB  5
0A7A:  MOVWF  xF4
0A7C:  MOVFF  5F3,5F8
0A80:  MOVFF  5F2,5F7
0A84:  MOVFF  5F1,5F6
0A88:  MOVFF  5F0,5F5
0A8C:  MOVLB  0
0A8E:  RCALL  05F4
....................    
....................    return mmcsd_get_r1(); 
0A90:  RCALL  0690
0A92:  MOVF   01,W
0A94:  GOTO   0AAC (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0); 
*
0712:  MOVLW  29
0714:  MOVLB  5
0716:  MOVWF  xF4
0718:  CLRF   xF8
071A:  CLRF   xF7
071C:  CLRF   xF6
071E:  CLRF   xF5
0720:  MOVLB  0
0722:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
0724:  RCALL  0690
0726:  MOVF   01,W
0728:  GOTO   09F8 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
06F8:  MOVLW  37
06FA:  MOVLB  5
06FC:  MOVWF  xF4
06FE:  CLRF   xF8
0700:  CLRF   xF7
0702:  CLRF   xF6
0704:  CLRF   xF5
0706:  MOVLB  0
0708:  RCALL  05F4
....................     
....................    return mmcsd_get_r1(); 
070A:  RCALL  0690
070C:  MOVF   01,W
070E:  GOTO   09F2 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
....................     
....................    return mmcsd_get_r3(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
074E:  MOVLW  3B
0750:  MOVLB  5
0752:  MOVWF  xF4
0754:  CLRF   xF8
0756:  CLRF   xF7
0758:  CLRF   xF6
075A:  MOVFF  4BA,5F5
075E:  MOVLB  0
0760:  RCALL  05F4
....................     
....................    g_CRC_enabled = crc_enabled; 
0762:  MOVLB  2
0764:  BCF    x20.0
0766:  MOVLB  4
0768:  BTFSS  xBA.0
076A:  BRA    0772
076C:  MOVLB  2
076E:  BSF    x20.0
0770:  MOVLB  4
....................     
....................    return mmcsd_get_r1(); 
0772:  MOVLB  0
0774:  RCALL  0690
0776:  MOVF   01,W
0778:  GOTO   0A4A (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................    
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
05F4:  MOVLB  5
05F6:  MOVF   xF4,W
05F8:  IORLW  40
05FA:  MOVWF  xF9
....................    packet[1] = make8(arg, 3); 
05FC:  MOVFF  5F8,5FA
....................    packet[2] = make8(arg, 2); 
0600:  MOVFF  5F7,5FB
....................    packet[3] = make8(arg, 1); 
0604:  MOVFF  5F6,5FC
....................    packet[4] = make8(arg, 0); 
0608:  MOVFF  5F5,5FD
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
060C:  MOVLB  2
060E:  BTFSS  x20.0
0610:  BRA    0630
....................       packet[5] = mmcsd_crc7(packet, 5); 
0612:  MOVLW  05
0614:  MOVLB  6
0616:  MOVWF  x00
0618:  MOVLW  F9
061A:  MOVLB  5
061C:  MOVWF  xFF
061E:  MOVLW  05
0620:  MOVLB  6
0622:  MOVWF  x01
0624:  MOVLB  0
0626:  BRA    0594
0628:  MOVFF  01,5FE
062C:  BRA    0636
062E:  MOVLB  2
....................    else 
....................       packet[5] = 0xFF; 
0630:  MOVLB  5
0632:  SETF   xFE
0634:  MOVLB  0
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    MMCSD_SPI_XFER(packet[0]); 
0636:  MOVFF  5F9,5FF
063A:  MOVLW  08
063C:  MOVLB  6
063E:  MOVWF  x00
0640:  MOVLB  0
0642:  RCALL  0526
....................    MMCSD_SPI_XFER(packet[1]); 
0644:  MOVFF  5FA,5FF
0648:  MOVLW  08
064A:  MOVLB  6
064C:  MOVWF  x00
064E:  MOVLB  0
0650:  RCALL  0526
....................    MMCSD_SPI_XFER(packet[2]); 
0652:  MOVFF  5FB,5FF
0656:  MOVLW  08
0658:  MOVLB  6
065A:  MOVWF  x00
065C:  MOVLB  0
065E:  RCALL  0526
....................    MMCSD_SPI_XFER(packet[3]); 
0660:  MOVFF  5FC,5FF
0664:  MOVLW  08
0666:  MOVLB  6
0668:  MOVWF  x00
066A:  MOVLB  0
066C:  RCALL  0526
....................    MMCSD_SPI_XFER(packet[4]); 
066E:  MOVFF  5FD,5FF
0672:  MOVLW  08
0674:  MOVLB  6
0676:  MOVWF  x00
0678:  MOVLB  0
067A:  RCALL  0526
....................    MMCSD_SPI_XFER(packet[5]); 
067C:  MOVFF  5FE,5FF
0680:  MOVLW  08
0682:  MOVLB  6
0684:  MOVWF  x00
0686:  MOVLB  0
0688:  RCALL  0526
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
068A:  MOVLW  00
068C:  MOVWF  01
068E:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
0690:  MOVLB  5
0692:  CLRF   xF4
0694:  SETF   xF5
.................... { 
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
0696:  MOVF   xF5,F
0698:  BZ    06BE
....................    { 
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = MMCSD_SPI_XFER(0xFF); 
069A:  SETF   xFF
069C:  MOVLW  08
069E:  MOVLB  6
06A0:  MOVWF  x00
06A2:  MOVLB  0
06A4:  RCALL  0526
06A6:  MOVF   01,W
06A8:  MOVFF  01,5F4
....................       //response = MMCSD_SPI_XFER(0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
06AC:  MOVLB  5
06AE:  INCFSZ xF4,W
06B0:  BRA    06B4
06B2:  BRA    06BA
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
06B4:  MOVFF  5F4,01
06B8:  BRA    06C2
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
06BA:  DECF   xF5,F
06BC:  BRA    0696
....................    } 
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
06BE:  MOVLW  80
06C0:  MOVWF  01
06C2:  MOVLB  0
06C4:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = MMCSD_SPI_XFER(0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
....................       r7[3 - i] = MMCSD_SPI_XFER(0xFF); 
....................  
....................    return r7[4]; 
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
079E:  RCALL  0690
07A0:  MOVFF  01,5F1
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
07A4:  MOVLB  5
07A6:  MOVF   xF0,W
07A8:  SUBWF  xF1,W
07AA:  BNZ   07B2
....................       return MMCSD_GOODEC; 
07AC:  MOVLW  00
07AE:  MOVWF  01
07B0:  BRA    07B6
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
07B2:  MOVFF  5F1,01
07B6:  MOVLB  0
07B8:  GOTO   0860 (RETURN)
.................... } 
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
0594:  MOVLB  6
0596:  CLRF   x05
....................  
....................    for (i = 0; i < length; i++, data++) 
0598:  CLRF   x02
059A:  MOVF   x01,W
059C:  SUBWF  x02,W
059E:  BC    05E6
....................    { 
....................       c = *data; 
05A0:  MOVLB  5
05A2:  MOVFF  5FF,FE9
05A6:  MOVFF  600,FEA
05AA:  MOVFF  FEF,604
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
05AE:  MOVLB  6
05B0:  CLRF   x03
05B2:  MOVF   x03,W
05B4:  SUBLW  07
05B6:  BNC   05D0
....................       { 
....................          crc = crc << 1; 
05B8:  BCF    FD8.0
05BA:  RLCF   x05,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
05BC:  MOVF   x04,W
05BE:  XORWF  x05,W
05C0:  ANDLW  80
05C2:  BZ    05C8
05C4:  MOVLW  09
05C6:  XORWF  x05,F
....................          c = c << 1; 
05C8:  BCF    FD8.0
05CA:  RLCF   x04,F
05CC:  INCF   x03,F
05CE:  BRA    05B2
....................       } 
....................  
....................        crc = crc & 0x7F; 
05D0:  BCF    x05.7
05D2:  MOVF   x02,W
05D4:  INCF   x02,F
05D6:  MOVLB  5
05D8:  INCF   xFF,F
05DA:  BTFSS  FD8.2
05DC:  BRA    05E2
05DE:  MOVLB  6
05E0:  INCF   x00,F
05E2:  MOVLB  6
05E4:  BRA    059A
....................    } 
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
05E6:  BSF    FD8.0
05E8:  RLCF   x05,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
05EA:  MOVFF  605,01
05EE:  MOVLB  0
05F0:  GOTO   0628 (RETURN)
.................... } 
....................  
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
*
07BC:  MOVLB  5
07BE:  CLRF   xFB
07C0:  CLRF   xFA
....................  
....................    for (i = 0; i < length; i++, data++) 
07C2:  CLRF   xF7
07C4:  MOVF   xF6,W
07C6:  SUBWF  xF7,W
07C8:  BC    081C
....................    { 
....................       c = *data; 
07CA:  MOVFF  5F4,FE9
07CE:  MOVFF  5F5,FEA
07D2:  MOVFF  FEF,5F9
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
07D6:  CLRF   xF8
07D8:  MOVF   xF8,W
07DA:  SUBLW  07
07DC:  BNC   080E
....................       { 
....................          crc = crc << 1; 
07DE:  BCF    FD8.0
07E0:  RLCF   xFA,F
07E2:  RLCF   xFB,F
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
07E4:  MOVF   xF9,W
07E6:  XORWF  xFA,W
07E8:  MOVWF  xFC
07EA:  MOVF   xFB,W
07EC:  MOVWF  xFD
07EE:  ANDLW  00
07F0:  MOVWF  00
07F2:  MOVF   xFD,W
07F4:  ANDLW  80
07F6:  MOVWF  03
07F8:  MOVF   00,W
07FA:  IORWF  03,W
07FC:  BZ    0806
07FE:  MOVLW  21
0800:  XORWF  xFA,F
0802:  MOVLW  10
0804:  XORWF  xFB,F
....................          c = c << 1; 
0806:  BCF    FD8.0
0808:  RLCF   xF9,F
080A:  INCF   xF8,F
080C:  BRA    07D8
....................       } 
....................  
....................        crc = crc & 0x7FFF; 
080E:  BCF    xFB.7
0810:  MOVF   xF7,W
0812:  INCF   xF7,F
0814:  INCF   xF4,F
0816:  BTFSC  FD8.2
0818:  INCF   xF5,F
081A:  BRA    07C4
....................    } 
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
081C:  BSF    FD8.0
081E:  RLCF   xFA,F
0820:  RLCF   xFB,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
0822:  MOVFF  5FA,01
0826:  MOVFF  5FB,02
082A:  MOVLB  0
082C:  RETURN 0
.................... } 
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
058E:  BCF    F93.6
0590:  BCF    F8A.6
0592:  RETURN 0
.................... } 
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    MMCSD_SPI_XFER(0xFF); 
*
057A:  MOVLB  5
057C:  SETF   xFF
057E:  MOVLW  08
0580:  MOVLB  6
0582:  MOVWF  x00
0584:  MOVLB  0
0586:  RCALL  0526
....................    output_high(MMCSD_PIN_SELECT); 
0588:  BCF    F93.6
058A:  BSF    F8A.6
058C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
0946:  MOVLB  2
0948:  BCF    x20.1
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
094A:  MOVFF  224,5E8
094E:  MOVFF  223,5E7
0952:  MOVFF  222,5E6
0956:  MOVFF  221,5E5
095A:  MOVLW  02
095C:  MOVLB  5
095E:  MOVWF  xEA
0960:  CLRF   xE9
0962:  CLRF   xEC
0964:  MOVLW  20
0966:  MOVWF  xEB
0968:  MOVLB  0
096A:  BRA    082E
096C:  MOVF   01,W
096E:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
0B94:  MOVLB  2
0B96:  BTFSS  x20.1
0B98:  BRA    0BC4
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
0B9A:  BCF    x20.1
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
0B9C:  MOVFF  224,5E8
0BA0:  MOVFF  223,5E7
0BA4:  MOVFF  222,5E6
0BA8:  MOVFF  221,5E5
0BAC:  MOVLW  02
0BAE:  MOVLB  5
0BB0:  MOVWF  xEA
0BB2:  CLRF   xE9
0BB4:  CLRF   xEC
0BB6:  MOVLW  20
0BB8:  MOVWF  xEB
0BBA:  MOVLB  0
0BBC:  BRA    0A98
0BBE:  MOVF   01,W
0BC0:  BRA    0BCA
0BC2:  MOVLB  2
....................    } 
....................    return(0);  //ok 
0BC4:  MOVLW  00
0BC6:  MOVWF  01
0BC8:  MOVLB  0
0BCA:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
0BCC:  MOVLB  5
0BCE:  CLRF   xE0
.................... { 
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
0BD0:  MOVF   xDD,W
0BD2:  ANDLW  01
0BD4:  MOVWF  01
0BD6:  CLRF   02
0BD8:  CLRF   03
0BDA:  MOVF   xDC,W
0BDC:  SUBWF  xDC,W
0BDE:  MOVWF  xE1
0BE0:  MOVF   01,W
0BE2:  SUBWFB xDD,W
0BE4:  MOVWF  xE2
0BE6:  MOVF   02,W
0BE8:  SUBWFB xDE,W
0BEA:  MOVWF  xE3
0BEC:  MOVF   03,W
0BEE:  SUBWFB xDF,W
0BF0:  MOVWF  xE4
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
0BF2:  MOVF   xE1,W
0BF4:  MOVLB  2
0BF6:  SUBWF  x21,W
0BF8:  BNZ   0C18
0BFA:  MOVLB  5
0BFC:  MOVF   xE2,W
0BFE:  MOVLB  2
0C00:  SUBWF  x22,W
0C02:  BNZ   0C18
0C04:  MOVLB  5
0C06:  MOVF   xE3,W
0C08:  MOVLB  2
0C0A:  SUBWF  x23,W
0C0C:  BNZ   0C18
0C0E:  MOVLB  5
0C10:  MOVF   xE4,W
0C12:  MOVLB  2
0C14:  SUBWF  x24,W
0C16:  BZ    0C4E
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
0C18:  BTFSS  x20.1
0C1A:  BRA    0C34
....................       { 
....................          ec = mmcsd_flush_buffer(); 
0C1C:  MOVLB  0
0C1E:  RCALL  0B94
0C20:  MOVFF  01,5E0
....................          if(ec != MMCSD_GOODEC) 
0C24:  MOVLB  5
0C26:  MOVF   xE0,F
0C28:  BZ    0C30
....................             return ec; 
0C2A:  MOVFF  5E0,01
0C2E:  BRA    0C54
....................          g_MMCSDBufferChanged = FALSE; 
0C30:  MOVLB  2
0C32:  BCF    x20.1
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
0C34:  MOVFF  5E4,224
0C38:  MOVFF  5E3,223
0C3C:  MOVFF  5E2,222
0C40:  MOVFF  5E1,221
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
0C44:  MOVLB  0
0C46:  RCALL  0946
0C48:  MOVFF  01,5E0
0C4C:  MOVLB  2
....................    } 
....................     
....................    return ec; 
0C4E:  MOVLB  5
0C50:  MOVFF  5E0,01
0C54:  MOVLB  0
0C56:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
0C58:  MOVFF  5D3,5DF
0C5C:  MOVFF  5D2,5DE
0C60:  MOVFF  5D1,5DD
0C64:  MOVFF  5D0,5DC
0C68:  RCALL  0BCC
0C6A:  MOVFF  01,5D6
....................    if(ec != MMCSD_GOODEC) 
0C6E:  MOVLB  5
0C70:  MOVF   xD6,F
0C72:  BZ    0C7A
....................    { 
....................      return ec; 
0C74:  MOVFF  5D6,01
0C78:  BRA    0CA4
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
0C7A:  MOVF   xD1,W
0C7C:  ANDLW  01
0C7E:  MOVWF  xDA
0C80:  CLRF   xDB
0C82:  CLRF   xDC
0C84:  MOVLW  20
0C86:  ADDWF  xD0,W
0C88:  MOVWF  FE9
0C8A:  MOVLW  00
0C8C:  ADDWFC xDA,W
0C8E:  MOVWF  FEA
0C90:  MOVFF  FEF,5DD
0C94:  MOVFF  5D5,FEA
0C98:  MOVFF  5D4,FE9
0C9C:  MOVFF  5DD,FEF
....................  
....................    return MMCSD_GOODEC; 
0CA0:  MOVLW  00
0CA2:  MOVWF  01
0CA4:  MOVLB  0
0CA6:  GOTO   0D12 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
18A6:  MOVFF  5D9,5DF
18AA:  MOVFF  5D8,5DE
18AE:  MOVFF  5D7,5DD
18B2:  MOVFF  5D6,5DC
18B6:  CALL   0BCC
18BA:  MOVFF  01,5DB
....................    if(ec != MMCSD_GOODEC) 
18BE:  MOVLB  5
18C0:  MOVF   xDB,F
18C2:  BZ    18CA
....................      return ec; 
18C4:  MOVFF  5DB,01
18C8:  BRA    18EE
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
18CA:  MOVF   xD7,W
18CC:  ANDLW  01
18CE:  MOVWF  xDD
18D0:  CLRF   xDE
18D2:  CLRF   xDF
18D4:  MOVLW  20
18D6:  ADDWF  xD6,W
18D8:  MOVWF  FE9
18DA:  MOVLW  00
18DC:  ADDWFC xDD,W
18DE:  MOVWF  FEA
18E0:  MOVFF  5DA,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
18E4:  MOVLB  2
18E6:  BSF    x20.1
....................  
....................    return MMCSD_GOODEC; 
18E8:  MOVLW  00
18EA:  MOVWF  01
18EC:  MOVLB  5
18EE:  MOVLB  0
18F0:  GOTO   195A (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... //FAT library. 
.................... #include <fat.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          FAT_PIC.C                              //// 
.................... ////                                                                 //// 
.................... //// Driver/Library for a FAT filesystem with a PIC                  //// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... //#define FAT16 
.................... #define FAT32 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster,   // number of addressable bytes per cluster 
....................    FAT_Start;           // when the first FAT begins 
....................  
.................... int32 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
*
2F26:  MOVLW  01
2F28:  MOVLB  4
2F2A:  MOVWF  xE9
2F2C:  MOVLB  5
2F2E:  CLRF   x44
.................... { 
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
2F30:  MOVLB  4
2F32:  MOVF   xE5,W
2F34:  MOVWF  FE9
2F36:  MOVF   xE6,W
2F38:  MOVWF  FEA
2F3A:  MOVF   FEF,W
2F3C:  XORLW  72
2F3E:  MOVLB  0
2F40:  BZ    2F4C
2F42:  XORLW  05
2F44:  BZ    2F54
2F46:  XORLW  16
2F48:  BZ    2F5C
2F4A:  BRA    2F66
....................    { 
....................       case 'r': 
....................          cur_stream.Flags = Read; 
2F4C:  MOVLW  01
2F4E:  MOVLB  5
2F50:  MOVWF  x23
....................          break; 
2F52:  BRA    2F6E
....................       case 'w': 
....................          cur_stream.Flags = Write; 
2F54:  MOVLW  02
2F56:  MOVLB  5
2F58:  MOVWF  x23
....................          break; 
2F5A:  BRA    2F6E
....................       case 'a': 
....................          cur_stream.Flags = Append; 
2F5C:  MOVLW  04
2F5E:  MOVLB  5
2F60:  MOVWF  x23
....................          break; 
2F62:  BRA    2F6E
2F64:  MOVLB  0
....................       default: 
....................          return EOF; 
2F66:  MOVLW  FF
2F68:  MOVWF  01
2F6A:  BRA    31C8
2F6C:  MOVLB  5
....................    } 
....................  
....................    if(mode[1] == 'b') 
2F6E:  MOVLW  01
2F70:  MOVLB  4
2F72:  ADDWF  xE5,W
2F74:  MOVWF  FE9
2F76:  MOVLW  00
2F78:  ADDWFC xE6,W
2F7A:  MOVWF  FEA
2F7C:  MOVF   FEF,W
2F7E:  SUBLW  62
2F80:  BNZ   2F88
....................       cur_stream.Flags |= Binary; 
2F82:  MOVLB  5
2F84:  BSF    x23.3
2F86:  MOVLB  4
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
2F88:  MOVFF  238,519
2F8C:  MOVFF  237,518
2F90:  MOVFF  236,517
2F94:  MOVFF  235,516
2F98:  MOVFF  519,521
2F9C:  MOVFF  518,520
2FA0:  MOVFF  517,51F
2FA4:  MOVFF  516,51E
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
2FA8:  MOVF   xE9,W
2FAA:  ADDWF  xE3,W
2FAC:  MOVWF  FE9
2FAE:  MOVLW  00
2FB0:  ADDWFC xE4,W
2FB2:  MOVWF  FEA
2FB4:  MOVF   FEF,F
2FB6:  BZ    2FD6
....................    { 
....................       if(fname[fname_parse_pos] == '/') 
2FB8:  MOVF   xE9,W
2FBA:  ADDWF  xE3,W
2FBC:  MOVWF  FE9
2FBE:  MOVLW  00
2FC0:  ADDWFC xE4,W
2FC2:  MOVWF  FEA
2FC4:  MOVF   FEF,W
2FC6:  SUBLW  2F
2FC8:  BNZ   2FD0
....................          depth++; 
2FCA:  MOVLB  5
2FCC:  INCF   x44,F
2FCE:  MOVLB  4
....................       fname_parse_pos += 1; 
2FD0:  MOVLW  01
2FD2:  ADDWF  xE9,F
2FD4:  BRA    2FA8
....................    } 
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
2FD6:  MOVLW  01
2FD8:  MOVWF  xE9
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
2FDA:  MOVLB  5
2FDC:  MOVF   x44,F
2FDE:  BZ    30B6
....................    { 
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
2FE0:  CLRF   x45
....................       while(fname[fname_parse_pos] != '/') 
2FE2:  MOVLB  4
2FE4:  MOVF   xE9,W
2FE6:  ADDWF  xE3,W
2FE8:  MOVWF  FE9
2FEA:  MOVLW  00
2FEC:  ADDWFC xE4,W
2FEE:  MOVWF  FEA
2FF0:  MOVF   FEF,W
2FF2:  SUBLW  2F
2FF4:  BZ    304C
....................       { 
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
2FF6:  MOVF   xE9,W
2FF8:  ADDWF  xE3,W
2FFA:  MOVWF  FE9
2FFC:  MOVLW  00
2FFE:  ADDWFC xE4,W
3000:  MOVWF  FEA
3002:  MOVF   FEF,F
3004:  BNZ   3010
....................             return EOF; 
3006:  MOVLW  FF
3008:  MOVWF  01
300A:  MOVLB  0
300C:  BRA    31C8
300E:  MOVLB  4
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
3010:  CLRF   03
3012:  MOVLB  5
3014:  MOVF   x45,W
3016:  ADDLW  EA
3018:  MOVWF  01
301A:  MOVLW  04
301C:  ADDWFC 03,F
301E:  MOVLB  4
3020:  MOVF   xE9,W
3022:  ADDWF  xE3,W
3024:  MOVWF  FE9
3026:  MOVLW  00
3028:  ADDWFC xE4,W
302A:  MOVWF  FEA
302C:  MOVFF  FEF,548
3030:  MOVLB  5
3032:  MOVFF  03,FEA
3036:  MOVFF  01,FE9
303A:  MOVFF  548,FEF
....................          fname_parse_pos += 1; 
303E:  MOVLW  01
3040:  MOVLB  4
3042:  ADDWF  xE9,F
....................          target_file_parse_pos += 1; 
3044:  MOVLB  5
3046:  ADDWF  x45,F
3048:  BRA    2FE2
304A:  MOVLB  4
....................       } 
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
304C:  MOVLW  01
304E:  ADDWF  xE9,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
3050:  CLRF   03
3052:  MOVLB  5
3054:  MOVF   x45,W
3056:  ADDLW  EA
3058:  MOVWF  FE9
305A:  MOVLW  04
305C:  ADDWFC 03,W
305E:  MOVWF  FEA
3060:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
3062:  MOVLW  04
3064:  MOVWF  x47
3066:  MOVLW  EA
3068:  MOVWF  x46
306A:  MOVLW  10
306C:  MOVWF  x48
306E:  MOVLW  05
3070:  MOVWF  x4A
3072:  MOVLW  0A
3074:  MOVWF  x49
3076:  MOVLB  0
3078:  CALL   2856
307C:  MOVF   01,F
307E:  BZ    30AE
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
3080:  MOVLB  5
3082:  BSF    x23.7
....................          *stream = cur_stream; 
3084:  MOVFF  4E8,03
3088:  MOVLB  4
308A:  MOVFF  4E7,FE9
308E:  MOVFF  4E8,FEA
3092:  MOVLW  05
3094:  MOVWF  FE2
3096:  MOVLW  0A
3098:  MOVWF  FE1
309A:  MOVLW  3A
309C:  MOVWF  01
309E:  MOVFF  FE6,FEE
30A2:  DECFSZ 01,F
30A4:  BRA    309E
....................          return EOF; 
30A6:  MOVLW  FF
30A8:  MOVWF  01
30AA:  MOVLB  0
30AC:  BRA    31C8
....................       } 
....................       depth -= 1; 
30AE:  MOVLW  01
30B0:  MOVLB  5
30B2:  SUBWF  x44,F
30B4:  BRA    2FDC
....................    } 
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
30B6:  MOVLB  4
30B8:  MOVF   xE9,W
30BA:  ADDWF  xE3,W
30BC:  MOVWF  FE9
30BE:  MOVLW  00
30C0:  ADDWFC xE4,W
30C2:  MOVWF  FEA
30C4:  MOVF   FEF,F
30C6:  BNZ   30F2
....................    { 
....................       *stream = cur_stream; 
30C8:  MOVFF  4E8,03
30CC:  MOVFF  4E7,FE9
30D0:  MOVFF  4E8,FEA
30D4:  MOVLW  05
30D6:  MOVWF  FE2
30D8:  MOVLW  0A
30DA:  MOVWF  FE1
30DC:  MOVLW  3A
30DE:  MOVWF  01
30E0:  MOVFF  FE6,FEE
30E4:  DECFSZ 01,F
30E6:  BRA    30E0
....................       return GOODEC; 
30E8:  MOVLW  00
30EA:  MOVWF  01
30EC:  MOVLB  0
30EE:  BRA    31C8
30F0:  MOVLB  4
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
30F2:  MOVLB  5
30F4:  CLRF   x45
....................    while(fname[fname_parse_pos] != '\0') 
30F6:  MOVLB  4
30F8:  MOVF   xE9,W
30FA:  ADDWF  xE3,W
30FC:  MOVWF  FE9
30FE:  MOVLW  00
3100:  ADDWFC xE4,W
3102:  MOVWF  FEA
3104:  MOVF   FEF,F
3106:  BZ    3144
....................    { 
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
3108:  CLRF   03
310A:  MOVLB  5
310C:  MOVF   x45,W
310E:  ADDLW  EA
3110:  MOVWF  01
3112:  MOVLW  04
3114:  ADDWFC 03,F
3116:  MOVLB  4
3118:  MOVF   xE9,W
311A:  ADDWF  xE3,W
311C:  MOVWF  FE9
311E:  MOVLW  00
3120:  ADDWFC xE4,W
3122:  MOVWF  FEA
3124:  MOVFF  FEF,548
3128:  MOVLB  5
312A:  MOVFF  03,FEA
312E:  MOVFF  01,FE9
3132:  MOVFF  548,FEF
....................       fname_parse_pos += 1; 
3136:  MOVLW  01
3138:  MOVLB  4
313A:  ADDWF  xE9,F
....................       target_file_parse_pos += 1; 
313C:  MOVLB  5
313E:  ADDWF  x45,F
3140:  BRA    30F6
3142:  MOVLB  4
....................    } 
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
3144:  CLRF   03
3146:  MOVLB  5
3148:  MOVF   x45,W
314A:  ADDLW  EA
314C:  MOVWF  FE9
314E:  MOVLW  04
3150:  ADDWFC 03,W
3152:  MOVWF  FEA
3154:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
3156:  MOVLW  04
3158:  MOVWF  x47
315A:  MOVLW  EA
315C:  MOVWF  x46
315E:  MOVLW  20
3160:  MOVWF  x48
3162:  MOVLW  05
3164:  MOVWF  x4A
3166:  MOVLW  0A
3168:  MOVWF  x49
316A:  MOVLB  0
316C:  CALL   2856
3170:  MOVF   01,F
3172:  BZ    31A2
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
3174:  MOVLB  5
3176:  BSF    x23.7
....................       *stream = cur_stream; 
3178:  MOVFF  4E8,03
317C:  MOVLB  4
317E:  MOVFF  4E7,FE9
3182:  MOVFF  4E8,FEA
3186:  MOVLW  05
3188:  MOVWF  FE2
318A:  MOVLW  0A
318C:  MOVWF  FE1
318E:  MOVLW  3A
3190:  MOVWF  01
3192:  MOVFF  FE6,FEE
3196:  DECFSZ 01,F
3198:  BRA    3192
....................       return EOF; 
319A:  MOVLW  FF
319C:  MOVWF  01
319E:  MOVLB  0
31A0:  BRA    31C8
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
31A2:  MOVFF  4E8,03
31A6:  MOVLB  4
31A8:  MOVFF  4E7,FE9
31AC:  MOVFF  4E8,FEA
31B0:  MOVLW  05
31B2:  MOVWF  FE2
31B4:  MOVLW  0A
31B6:  MOVWF  FE1
31B8:  MOVLW  3A
31BA:  MOVWF  01
31BC:  MOVFF  FE6,FEE
31C0:  DECFSZ 01,F
31C2:  BRA    31BC
....................    return GOODEC; 
31C4:  MOVLW  00
31C6:  MOVWF  01
31C8:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
31CA:  GOTO   3A40 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
*
36F4:  MOVLB  4
36F6:  CLRF   xE3
.................... { 
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
36F8:  MOVLW  19
36FA:  ADDWF  xE1,W
36FC:  MOVWF  FE9
36FE:  MOVLW  00
3700:  ADDWFC xE2,W
3702:  MOVWF  FEA
3704:  BTFSC  FEF.1
3706:  BRA    3718
3708:  MOVLW  19
370A:  ADDWF  xE1,W
370C:  MOVWF  FE9
370E:  MOVLW  00
3710:  ADDWFC xE2,W
3712:  MOVWF  FEA
3714:  BTFSS  FEF.2
3716:  BRA    3988
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
3718:  MOVLW  08
371A:  ADDWF  xE1,W
371C:  MOVWF  FE9
371E:  MOVLW  00
3720:  ADDWFC xE2,W
3722:  MOVWF  FEA
3724:  MOVFF  FEF,4E8
3728:  MOVFF  FEC,4E9
372C:  MOVFF  FEC,4EA
3730:  MOVFF  FEC,4EB
3734:  MOVLW  1C
3736:  ADDWF  xE8,F
3738:  MOVLW  00
373A:  ADDWFC xE9,F
373C:  ADDWFC xEA,F
373E:  ADDWFC xEB,F
3740:  MOVLW  10
3742:  ADDWF  xE1,W
3744:  MOVWF  01
3746:  MOVLW  00
3748:  ADDWFC xE2,W
374A:  MOVWF  03
374C:  MOVFF  01,4EC
3750:  MOVWF  xED
3752:  MOVFF  4EB,5C9
3756:  MOVFF  4EA,5C8
375A:  MOVFF  4E9,5C7
375E:  MOVFF  4E8,5C6
3762:  MOVLB  5
3764:  CLRF   xCB
3766:  MOVLW  04
3768:  MOVWF  xCA
376A:  MOVFF  03,5CD
376E:  MOVFF  01,5CC
3772:  MOVLB  0
3774:  CALL   18F4
3778:  MOVF   01,F
377A:  BZ    3798
....................       { 
....................          stream->Flags |= Write_Error; 
377C:  MOVLW  19
377E:  MOVLB  4
3780:  ADDWF  xE1,W
3782:  MOVWF  FE9
3784:  MOVLW  00
3786:  ADDWFC xE2,W
3788:  MOVWF  FEA
378A:  MOVF   FEF,W
378C:  IORLW  40
378E:  MOVWF  FEF
....................          return EOF; 
3790:  MOVLW  FF
3792:  MOVWF  01
3794:  BRA    3A16
3796:  MOVLB  0
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
3798:  MOVLW  08
379A:  MOVLB  4
379C:  ADDWF  xE1,W
379E:  MOVWF  FE9
37A0:  MOVLW  00
37A2:  ADDWFC xE2,W
37A4:  MOVWF  FEA
37A6:  MOVFF  FEF,4E8
37AA:  MOVFF  FEC,4E9
37AE:  MOVFF  FEC,4EA
37B2:  MOVFF  FEC,4EB
37B6:  MOVLW  14
37B8:  ADDWF  xE8,F
37BA:  MOVLW  00
37BC:  ADDWFC xE9,F
37BE:  ADDWFC xEA,F
37C0:  ADDWFC xEB,F
37C2:  MOVFF  4EB,5C2
37C6:  MOVFF  4EA,5C1
37CA:  MOVFF  4E9,5C0
37CE:  MOVFF  4E8,5BF
37D2:  MOVLB  5
37D4:  CLRF   xC4
37D6:  MOVLW  02
37D8:  MOVWF  xC3
37DA:  MOVLW  04
37DC:  MOVWF  xC6
37DE:  MOVLW  E6
37E0:  MOVWF  xC5
37E2:  MOVLB  0
37E4:  CALL   0CAA
37E8:  MOVF   01,W
37EA:  MOVLB  4
37EC:  ADDWF  xE3,F
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
37EE:  MOVLW  08
37F0:  ADDWF  xE1,W
37F2:  MOVWF  FE9
37F4:  MOVLW  00
37F6:  ADDWFC xE2,W
37F8:  MOVWF  FEA
37FA:  MOVFF  FEF,4E8
37FE:  MOVFF  FEC,4E9
3802:  MOVFF  FEC,4EA
3806:  MOVFF  FEC,4EB
380A:  MOVLW  1A
380C:  ADDWF  xE8,F
380E:  MOVLW  00
3810:  ADDWFC xE9,F
3812:  ADDWFC xEA,F
3814:  ADDWFC xEB,F
3816:  MOVFF  4EB,5C2
381A:  MOVFF  4EA,5C1
381E:  MOVFF  4E9,5C0
3822:  MOVFF  4E8,5BF
3826:  MOVLB  5
3828:  CLRF   xC4
382A:  MOVLW  02
382C:  MOVWF  xC3
382E:  MOVLW  04
3830:  MOVWF  xC6
3832:  MOVLW  E4
3834:  MOVWF  xC5
3836:  MOVLB  0
3838:  CALL   0CAA
383C:  MOVF   01,W
383E:  MOVLB  4
3840:  ADDWF  xE3,F
....................  
....................       if(ec != GOODEC) 
3842:  MOVF   xE3,F
3844:  BZ    385E
....................       { 
....................          stream->Flags |= Read_Error; 
3846:  MOVLW  19
3848:  ADDWF  xE1,W
384A:  MOVWF  FE9
384C:  MOVLW  00
384E:  ADDWFC xE2,W
3850:  MOVWF  FEA
3852:  MOVF   FEF,W
3854:  IORLW  20
3856:  MOVWF  FEF
....................          return EOF; 
3858:  MOVLW  FF
385A:  MOVWF  01
385C:  BRA    3A16
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
385E:  MOVF   xE4,F
3860:  BTFSS  FD8.2
3862:  BRA    396E
3864:  MOVF   xE5,F
3866:  BTFSS  FD8.2
3868:  BRA    396E
386A:  MOVF   xE6,F
386C:  BTFSS  FD8.2
386E:  BRA    396E
3870:  MOVF   xE7,F
3872:  BTFSS  FD8.2
3874:  BRA    396E
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
3876:  MOVLW  14
3878:  ADDWF  xE1,W
387A:  MOVWF  FE9
387C:  MOVLW  00
387E:  ADDWFC xE2,W
3880:  MOVWF  FEA
3882:  MOVFF  FEF,5BC
3886:  MOVFF  FEC,5BD
388A:  MOVFF  FEC,5BE
388E:  MOVFF  FEC,5BF
3892:  MOVLB  0
3894:  CALL   1266
3898:  MOVFF  03,4E7
389C:  MOVFF  02,4E6
38A0:  MOVFF  01,4E5
38A4:  MOVFF  00,4E4
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
38A8:  MOVLW  08
38AA:  MOVLB  4
38AC:  ADDWF  xE1,W
38AE:  MOVWF  FE9
38B0:  MOVLW  00
38B2:  ADDWFC xE2,W
38B4:  MOVWF  FEA
38B6:  MOVFF  FEF,4E8
38BA:  MOVFF  FEC,4E9
38BE:  MOVFF  FEC,4EA
38C2:  MOVFF  FEC,4EB
38C6:  MOVLW  14
38C8:  ADDWF  xE8,F
38CA:  MOVLW  00
38CC:  ADDWFC xE9,F
38CE:  ADDWFC xEA,F
38D0:  ADDWFC xEB,F
38D2:  MOVFF  4EB,5C9
38D6:  MOVFF  4EA,5C8
38DA:  MOVFF  4E9,5C7
38DE:  MOVFF  4E8,5C6
38E2:  MOVLB  5
38E4:  CLRF   xCB
38E6:  MOVLW  02
38E8:  MOVWF  xCA
38EA:  MOVLW  04
38EC:  MOVWF  xCD
38EE:  MOVLW  E6
38F0:  MOVWF  xCC
38F2:  MOVLB  0
38F4:  CALL   18F4
38F8:  MOVF   01,W
38FA:  MOVLB  4
38FC:  ADDWF  xE3,F
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
38FE:  MOVLW  08
3900:  ADDWF  xE1,W
3902:  MOVWF  FE9
3904:  MOVLW  00
3906:  ADDWFC xE2,W
3908:  MOVWF  FEA
390A:  MOVFF  FEF,4E8
390E:  MOVFF  FEC,4E9
3912:  MOVFF  FEC,4EA
3916:  MOVFF  FEC,4EB
391A:  MOVLW  1A
391C:  ADDWF  xE8,F
391E:  MOVLW  00
3920:  ADDWFC xE9,F
3922:  ADDWFC xEA,F
3924:  ADDWFC xEB,F
3926:  MOVFF  4EB,5C9
392A:  MOVFF  4EA,5C8
392E:  MOVFF  4E9,5C7
3932:  MOVFF  4E8,5C6
3936:  MOVLB  5
3938:  CLRF   xCB
393A:  MOVLW  02
393C:  MOVWF  xCA
393E:  MOVLW  04
3940:  MOVWF  xCD
3942:  MOVLW  E4
3944:  MOVWF  xCC
3946:  MOVLB  0
3948:  CALL   18F4
394C:  MOVF   01,W
394E:  MOVLB  4
3950:  ADDWF  xE3,F
....................  
....................          if(ec != GOODEC) 
3952:  MOVF   xE3,F
3954:  BZ    396E
....................          { 
....................             stream->Flags |= Write_Error; 
3956:  MOVLW  19
3958:  ADDWF  xE1,W
395A:  MOVWF  FE9
395C:  MOVLW  00
395E:  ADDWFC xE2,W
3960:  MOVWF  FEA
3962:  MOVF   FEF,W
3964:  IORLW  40
3966:  MOVWF  FEF
....................             return EOF; 
3968:  MOVLW  FF
396A:  MOVWF  01
396C:  BRA    3A16
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
396E:  MOVFF  4E2,4E9
3972:  MOVFF  4E1,4E8
3976:  MOVLB  0
3978:  BRA    3558
397A:  MOVF   01,W
397C:  SUBLW  FF
397E:  BNZ   398A
....................          return EOF; 
3980:  MOVLW  FF
3982:  MOVWF  01
3984:  MOVLB  4
3986:  BRA    3A16
3988:  MOVLB  0
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
398A:  MOVLW  04
398C:  MOVLB  4
398E:  ADDWF  xE1,W
3990:  MOVWF  FE9
3992:  MOVLW  00
3994:  ADDWFC xE2,W
3996:  MOVWF  FEA
3998:  MOVF   FEE,F
399A:  MOVF   FEE,F
399C:  CLRF   FEC
399E:  MOVF   FED,F
39A0:  CLRF   FEF
39A2:  MOVF   FED,F
39A4:  CLRF   FEF
39A6:  MOVF   FED,F
39A8:  CLRF   FEF
....................    stream->Entry_Addr = 0; 
39AA:  MOVLW  08
39AC:  ADDWF  xE1,W
39AE:  MOVWF  FE9
39B0:  MOVLW  00
39B2:  ADDWFC xE2,W
39B4:  MOVWF  FEA
39B6:  MOVF   FEE,F
39B8:  MOVF   FEE,F
39BA:  CLRF   FEC
39BC:  MOVF   FED,F
39BE:  CLRF   FEF
39C0:  MOVF   FED,F
39C2:  CLRF   FEF
39C4:  MOVF   FED,F
39C6:  CLRF   FEF
....................    stream->Size = 0; 
39C8:  MOVLW  10
39CA:  ADDWF  xE1,W
39CC:  MOVWF  FE9
39CE:  MOVLW  00
39D0:  ADDWFC xE2,W
39D2:  MOVWF  FEA
39D4:  MOVF   FEE,F
39D6:  MOVF   FEE,F
39D8:  CLRF   FEC
39DA:  MOVF   FED,F
39DC:  CLRF   FEF
39DE:  MOVF   FED,F
39E0:  CLRF   FEF
39E2:  MOVF   FED,F
39E4:  CLRF   FEF
....................    stream->Start_Addr = 0; 
39E6:  MOVLW  14
39E8:  ADDWF  xE1,W
39EA:  MOVWF  FE9
39EC:  MOVLW  00
39EE:  ADDWFC xE2,W
39F0:  MOVWF  FEA
39F2:  MOVF   FEE,F
39F4:  MOVF   FEE,F
39F6:  CLRF   FEC
39F8:  MOVF   FED,F
39FA:  CLRF   FEF
39FC:  MOVF   FED,F
39FE:  CLRF   FEF
3A00:  MOVF   FED,F
3A02:  CLRF   FEF
....................    stream->Flags = 0; 
3A04:  MOVLW  19
3A06:  ADDWF  xE1,W
3A08:  MOVWF  FE9
3A0A:  MOVLW  00
3A0C:  ADDWFC xE2,W
3A0E:  MOVWF  FEA
3A10:  CLRF   FEF
....................    return 0; 
3A12:  MOVLW  00
3A14:  MOVWF  01
3A16:  MOVLB  0
3A18:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
*
32D0:  MOVLW  19
32D2:  MOVLB  5
32D4:  ADDWF  xAD,W
32D6:  MOVWF  FE9
32D8:  MOVLW  00
32DA:  ADDWFC xAE,W
32DC:  MOVWF  FEA
32DE:  BTFSS  FEF.0
32E0:  BRA    33DC
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
32E2:  MOVFF  5AD,FE9
32E6:  MOVFF  5AE,FEA
32EA:  MOVFF  FEF,5B0
32EE:  MOVFF  FEC,5B1
32F2:  MOVFF  FEC,5B2
32F6:  MOVFF  FEC,5B3
32FA:  MOVF   xB0,F
32FC:  BNZ   3322
32FE:  MOVF   xB1,F
3300:  BNZ   3322
3302:  MOVF   xB2,F
3304:  BNZ   3322
3306:  MOVF   xB3,F
3308:  BNZ   3322
....................       { 
....................          stream->Flags |= EOF_Reached; 
330A:  MOVLW  19
330C:  ADDWF  xAD,W
330E:  MOVWF  FE9
3310:  MOVLW  00
3312:  ADDWFC xAE,W
3314:  MOVWF  FEA
3316:  MOVF   FEF,W
3318:  IORLW  10
331A:  MOVWF  FEF
....................          return EOF; 
331C:  MOVLW  FF
331E:  MOVWF  01
3320:  BRA    33E0
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
3322:  MOVFF  5AE,5B1
3326:  MOVFF  5AD,5B0
332A:  MOVLW  05
332C:  MOVWF  xB3
332E:  MOVLW  AF
3330:  MOVWF  xB2
3332:  MOVLB  0
3334:  BRA    31CE
3336:  MOVF   01,W
3338:  SUBLW  FF
333A:  BNZ   3346
....................          return EOF; 
333C:  MOVLW  FF
333E:  MOVWF  01
3340:  MOVLB  5
3342:  BRA    33E0
3344:  MOVLB  0
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
3346:  MOVLB  5
3348:  MOVF   xAF,F
334A:  BNZ   3374
334C:  MOVLW  19
334E:  ADDWF  xAD,W
3350:  MOVWF  FE9
3352:  MOVLW  00
3354:  ADDWFC xAE,W
3356:  MOVWF  FEA
3358:  BTFSC  FEF.3
335A:  BRA    3374
....................       { 
....................          stream->Flags |= EOF_Reached; 
335C:  MOVLW  19
335E:  ADDWF  xAD,W
3360:  MOVWF  FE9
3362:  MOVLW  00
3364:  ADDWFC xAE,W
3366:  MOVWF  FEA
3368:  MOVF   FEF,W
336A:  IORLW  10
336C:  MOVWF  FEF
....................          return EOF; 
336E:  MOVLW  FF
3370:  MOVWF  01
3372:  BRA    33E0
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
3374:  MOVLW  04
3376:  ADDWF  xAD,W
3378:  MOVWF  01
337A:  MOVLW  00
337C:  ADDWFC xAE,W
337E:  MOVWF  03
3380:  MOVFF  01,5B0
3384:  MOVWF  xB1
3386:  MOVWF  xB3
3388:  MOVFF  01,5B2
338C:  MOVLB  0
338E:  CALL   1E9E
3392:  MOVF   01,F
3394:  BZ    33A0
....................          return EOF; 
3396:  MOVLW  FF
3398:  MOVWF  01
339A:  MOVLB  5
339C:  BRA    33E0
339E:  MOVLB  0
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
33A0:  MOVLB  5
33A2:  MOVFF  5AD,FE9
33A6:  MOVFF  5AE,FEA
33AA:  MOVLW  01
33AC:  SUBWF  FEF,W
33AE:  MOVWF  00
33B0:  MOVLW  00
33B2:  SUBWFB FEC,W
33B4:  MOVWF  01
33B6:  MOVLW  00
33B8:  SUBWFB FEC,W
33BA:  MOVWF  02
33BC:  MOVLW  00
33BE:  SUBWFB FEC,W
33C0:  MOVF   FED,F
33C2:  MOVF   FED,F
33C4:  MOVF   FED,F
33C6:  MOVFF  00,FEF
33CA:  MOVFF  01,FEC
33CE:  MOVFF  02,FEC
33D2:  MOVWF  FEC
....................       return ch; 
33D4:  MOVFF  5AF,01
33D8:  BRA    33E0
....................    } 
33DA:  BRA    33E0
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
....................       return EOF; 
33DC:  MOVLW  FF
33DE:  MOVWF  01
33E0:  MOVLB  0
33E2:  GOTO   34A2 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
2120:  MOVLW  19
2122:  MOVLB  5
2124:  ADDWF  x81,W
2126:  MOVWF  FE9
2128:  MOVLW  00
212A:  ADDWFC x82,W
212C:  MOVWF  FEA
212E:  BTFSC  FEF.1
2130:  BRA    2142
2132:  MOVLW  19
2134:  ADDWF  x81,W
2136:  MOVWF  FE9
2138:  MOVLW  00
213A:  ADDWFC x82,W
213C:  MOVWF  FEA
213E:  BTFSS  FEF.2
2140:  BRA    23F4
2142:  MOVLW  18
2144:  ADDWF  x81,W
2146:  MOVWF  FE9
2148:  MOVLW  00
214A:  ADDWFC x82,W
214C:  MOVWF  FEA
214E:  MOVF   FEF,F
2150:  BTFSS  FD8.2
2152:  BRA    23F4
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
2154:  MOVLW  04
2156:  ADDWF  x81,W
2158:  MOVWF  FE9
215A:  MOVLW  00
215C:  ADDWFC x82,W
215E:  MOVWF  FEA
2160:  MOVFF  FEF,583
2164:  MOVFF  FEC,584
2168:  MOVFF  FEC,585
216C:  MOVFF  FEC,586
2170:  MOVF   x86,W
2172:  MOVLB  2
2174:  SUBWF  x2C,W
2176:  BTFSS  FD8.0
2178:  BRA    227C
217A:  BNZ   21A8
217C:  MOVLB  5
217E:  MOVF   x85,W
2180:  MOVLB  2
2182:  SUBWF  x2B,W
2184:  BTFSS  FD8.0
2186:  BRA    227C
2188:  BNZ   21A8
218A:  MOVLB  5
218C:  MOVF   x84,W
218E:  MOVLB  2
2190:  SUBWF  x2A,W
2192:  BTFSS  FD8.0
2194:  BRA    227C
2196:  BNZ   21A8
2198:  MOVF   x29,W
219A:  MOVLB  5
219C:  SUBWF  x83,W
219E:  BTFSS  FD8.0
21A0:  BRA    21A6
21A2:  MOVLB  2
21A4:  BRA    227C
21A6:  MOVLB  2
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
21A8:  MOVLW  02
21AA:  MOVLB  5
21AC:  MOVWF  x98
21AE:  MOVLW  31
21B0:  MOVWF  x97
21B2:  MOVLB  0
21B4:  RCALL  1B0C
21B6:  MOVF   01,W
21B8:  SUBLW  FF
21BA:  BNZ   21C2
....................             return EOF; 
21BC:  MOVLW  FF
21BE:  MOVWF  01
21C0:  BRA    23FA
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
21C2:  MOVFF  234,59A
21C6:  MOVFF  233,599
21CA:  MOVFF  232,598
21CE:  MOVFF  231,597
21D2:  MOVLW  0F
21D4:  MOVLB  5
21D6:  MOVWF  x9E
21D8:  SETF   x9D
21DA:  SETF   x9C
21DC:  SETF   x9B
21DE:  MOVLB  0
21E0:  CALL   197A
21E4:  MOVF   01,W
21E6:  SUBLW  FF
21E8:  BNZ   21F0
....................             return EOF; 
21EA:  MOVLW  FF
21EC:  MOVWF  01
21EE:  BRA    23FA
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................             return EOF; 
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
21F0:  MOVFF  234,59A
21F4:  MOVFF  233,599
21F8:  MOVFF  232,598
21FC:  MOVFF  231,597
2200:  RCALL  1C88
2202:  MOVF   01,W
2204:  SUBLW  FF
2206:  BNZ   220E
....................             return EOF; 
2208:  MOVLW  FF
220A:  MOVWF  01
220C:  BRA    23FA
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
220E:  MOVLW  04
2210:  MOVLB  5
2212:  ADDWF  x81,W
2214:  MOVWF  01
2216:  MOVLW  00
2218:  ADDWFC x82,W
221A:  MOVWF  03
221C:  MOVFF  01,583
2220:  MOVWF  x84
2222:  MOVLW  14
2224:  ADDWF  x81,W
2226:  MOVWF  01
2228:  MOVLW  00
222A:  ADDWFC x82,W
222C:  MOVWF  03
222E:  MOVFF  01,585
2232:  MOVWF  x86
2234:  MOVFF  234,5C5
2238:  MOVFF  233,5C4
223C:  MOVFF  232,5C3
2240:  MOVFF  231,5C2
2244:  MOVLB  0
2246:  CALL   13B0
224A:  MOVFF  586,FEA
224E:  MOVFF  585,FE9
2252:  MOVFF  00,FEF
2256:  MOVFF  01,FEC
225A:  MOVFF  02,FEC
225E:  MOVFF  03,FEC
2262:  MOVFF  584,FEA
2266:  MOVFF  583,FE9
226A:  MOVFF  00,FEF
226E:  MOVFF  01,FEC
2272:  MOVFF  02,FEC
2276:  MOVFF  03,FEC
227A:  MOVLB  2
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
227C:  MOVFF  582,584
2280:  MOVFF  581,583
2284:  MOVFF  580,585
2288:  MOVLB  0
228A:  BRA    1D44
228C:  MOVF   01,W
228E:  SUBLW  FF
2290:  BNZ   2298
....................          return EOF; 
2292:  MOVLW  FF
2294:  MOVWF  01
2296:  BRA    23FA
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
2298:  MOVLW  04
229A:  MOVLB  5
229C:  ADDWF  x81,W
229E:  MOVWF  01
22A0:  MOVLW  00
22A2:  ADDWFC x82,W
22A4:  MOVWF  03
22A6:  MOVFF  01,583
22AA:  MOVWF  x84
22AC:  MOVWF  xB3
22AE:  MOVFF  01,5B2
22B2:  MOVLB  0
22B4:  RCALL  1E9E
22B6:  MOVF   01,W
22B8:  SUBLW  FF
22BA:  BTFSS  FD8.2
22BC:  BRA    23B0
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
22BE:  MOVLW  04
22C0:  MOVLB  5
22C2:  ADDWF  x81,W
22C4:  MOVWF  FE9
22C6:  MOVLW  00
22C8:  ADDWFC x82,W
22CA:  MOVWF  FEA
22CC:  MOVFF  FEF,583
22D0:  MOVFF  FEC,584
22D4:  MOVFF  FEC,585
22D8:  MOVFF  FEC,586
22DC:  MOVLW  20
22DE:  SUBWF  x83,F
22E0:  MOVLW  00
22E2:  SUBWFB x84,F
22E4:  SUBWFB x85,F
22E6:  SUBWFB x86,F
22E8:  MOVLW  01
22EA:  ADDWF  x83,F
22EC:  MOVLW  00
22EE:  ADDWFC x84,F
22F0:  ADDWFC x85,F
22F2:  ADDWFC x86,F
22F4:  MOVLW  1A
22F6:  ADDWF  x81,W
22F8:  MOVWF  01
22FA:  MOVLW  00
22FC:  ADDWFC x82,W
22FE:  MOVWF  03
2300:  MOVFF  01,587
2304:  MOVWF  x88
2306:  MOVFF  586,5C9
230A:  MOVFF  585,5C8
230E:  MOVFF  584,5C7
2312:  MOVFF  583,5C6
2316:  CLRF   xCB
2318:  MOVLW  20
231A:  MOVWF  xCA
231C:  MOVFF  03,5CD
2320:  MOVFF  01,5CC
2324:  MOVLB  0
2326:  CALL   18F4
232A:  MOVF   01,F
232C:  BZ    234A
....................          { 
....................             stream->Flags |= Write_Error; 
232E:  MOVLW  19
2330:  MOVLB  5
2332:  ADDWF  x81,W
2334:  MOVWF  FE9
2336:  MOVLW  00
2338:  ADDWFC x82,W
233A:  MOVWF  FEA
233C:  MOVF   FEF,W
233E:  IORLW  40
2340:  MOVWF  FEF
....................             return EOF; 
2342:  MOVLW  FF
2344:  MOVWF  01
2346:  MOVLB  0
2348:  BRA    23FA
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
234A:  MOVLW  04
234C:  MOVLB  5
234E:  ADDWF  x81,W
2350:  MOVWF  FE9
2352:  MOVLW  00
2354:  ADDWFC x82,W
2356:  MOVWF  FEA
2358:  MOVFF  FEF,5BC
235C:  MOVFF  FEC,5BD
2360:  MOVFF  FEC,5BE
2364:  MOVFF  FEC,5BF
2368:  MOVLB  0
236A:  CALL   1266
236E:  MOVFF  03,58C
2372:  MOVFF  02,585
2376:  MOVFF  01,58A
237A:  MOVFF  00,583
237E:  MOVLW  04
2380:  MOVLB  5
2382:  ADDWF  x81,W
2384:  MOVWF  01
2386:  MOVLW  00
2388:  ADDWFC x82,W
238A:  MOVWF  03
238C:  MOVFF  01,587
2390:  MOVWF  x88
2392:  MOVFF  02,58B
2396:  MOVFF  00,589
239A:  MOVWF  x8E
239C:  MOVFF  01,58D
23A0:  MOVLB  0
23A2:  BRA    202C
23A4:  MOVF   01,W
23A6:  SUBLW  FF
23A8:  BNZ   23B0
....................             return EOF; 
23AA:  MOVLW  FF
23AC:  MOVWF  01
23AE:  BRA    23FA
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
23B0:  MOVLW  10
23B2:  MOVLB  5
23B4:  ADDWF  x81,W
23B6:  MOVWF  FE9
23B8:  MOVLW  00
23BA:  ADDWFC x82,W
23BC:  MOVWF  FEA
23BE:  MOVLW  01
23C0:  ADDWF  FEF,W
23C2:  MOVWF  00
23C4:  MOVLW  00
23C6:  ADDWFC FEC,W
23C8:  MOVWF  01
23CA:  MOVLW  00
23CC:  ADDWFC FEC,W
23CE:  MOVWF  02
23D0:  MOVLW  00
23D2:  ADDWFC FEC,W
23D4:  MOVF   FED,F
23D6:  MOVF   FED,F
23D8:  MOVF   FED,F
23DA:  MOVFF  00,FEF
23DE:  MOVFF  01,FEC
23E2:  MOVFF  02,FEC
23E6:  MOVWF  FEC
....................  
....................       return ch; 
23E8:  MOVFF  580,01
23EC:  MOVLB  0
23EE:  BRA    23FA
....................    } 
23F0:  BRA    23FA
23F2:  MOVLB  5
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
....................       return EOF; 
23F4:  MOVLW  FF
23F6:  MOVWF  01
23F8:  MOVLB  0
23FA:  GOTO   2514 (RETURN)
.................... } 
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
.................... { 
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
....................    { 
....................       if(fatputc(str[i], stream) == EOF) 
....................         return EOF; 
....................       i += 1; 
....................    } 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
....................       printf("%c", ch); 
....................    } while(ch != EOF); 
....................  
....................    return ch; 
.................... } 
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
23FE:  MOVFF  577,03
2402:  MOVLB  5
2404:  MOVFF  576,FE9
2408:  MOVFF  577,FEA
240C:  MOVFF  FEF,580
2410:  MOVFF  FEC,581
2414:  MOVFF  FEC,582
2418:  MOVFF  FEC,583
241C:  MOVF   x80,F
241E:  BNZ   2442
2420:  MOVF   x81,F
2422:  BNZ   2442
2424:  MOVF   x82,F
2426:  BNZ   2442
2428:  MOVF   x83,F
242A:  BNZ   2442
....................    { 
....................       rewind(stream); 
242C:  MOVFF  575,581
2430:  MOVFF  574,580
2434:  MOVLB  0
2436:  GOTO   1A8A
....................       return GOODEC; 
243A:  MOVLW  00
243C:  MOVWF  01
243E:  BRA    27EE
2440:  MOVLB  5
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
2442:  MOVLW  19
2444:  ADDWF  x74,W
2446:  MOVWF  FE9
2448:  MOVLW  00
244A:  ADDWFC x75,W
244C:  MOVWF  FEA
244E:  BTFSC  FEF.1
2450:  BRA    2462
2452:  MOVLW  19
2454:  ADDWF  x74,W
2456:  MOVWF  FE9
2458:  MOVLW  00
245A:  ADDWFC x75,W
245C:  MOVWF  FEA
245E:  BTFSS  FEF.2
2460:  BRA    252E
2462:  MOVLW  10
2464:  ADDWF  x74,W
2466:  MOVWF  FE9
2468:  MOVLW  00
246A:  ADDWFC x75,W
246C:  MOVWF  FEA
246E:  MOVFF  FEF,580
2472:  MOVFF  FEC,581
2476:  MOVFF  FEC,582
247A:  MOVFF  FEC,583
247E:  MOVFF  576,FE9
2482:  MOVFF  577,FEA
2486:  MOVFF  FEF,00
248A:  MOVFF  FEC,01
248E:  MOVFF  FEC,02
2492:  MOVFF  FEC,03
2496:  MOVF   x83,W
2498:  SUBWF  03,W
249A:  BNC   252E
249C:  BNZ   24B4
249E:  MOVF   x82,W
24A0:  SUBWF  02,W
24A2:  BNC   252E
24A4:  BNZ   24B4
24A6:  MOVF   x81,W
24A8:  SUBWF  01,W
24AA:  BNC   252E
24AC:  BNZ   24B4
24AE:  MOVF   00,W
24B0:  SUBWF  x80,W
24B2:  BC    252E
....................    { 
....................       while(stream->Size < *position) 
24B4:  MOVLW  10
24B6:  ADDWF  x74,W
24B8:  MOVWF  FE9
24BA:  MOVLW  00
24BC:  ADDWFC x75,W
24BE:  MOVWF  FEA
24C0:  MOVFF  FEF,580
24C4:  MOVFF  FEC,581
24C8:  MOVFF  FEC,582
24CC:  MOVFF  FEC,583
24D0:  MOVFF  576,FE9
24D4:  MOVFF  577,FEA
24D8:  MOVFF  FEF,00
24DC:  MOVFF  FEC,01
24E0:  MOVFF  FEC,02
24E4:  MOVFF  FEC,03
24E8:  MOVF   x83,W
24EA:  SUBWF  03,W
24EC:  BNC   2524
24EE:  BNZ   2506
24F0:  MOVF   x82,W
24F2:  SUBWF  02,W
24F4:  BNC   2524
24F6:  BNZ   2506
24F8:  MOVF   x81,W
24FA:  SUBWF  01,W
24FC:  BNC   2524
24FE:  BNZ   2506
2500:  MOVF   00,W
2502:  SUBWF  x80,W
2504:  BC    2524
....................          if(fatputc('\0', stream) == EOF) 
2506:  CLRF   x80
2508:  MOVFF  575,582
250C:  MOVFF  574,581
2510:  MOVLB  0
2512:  BRA    2120
2514:  MOVF   01,W
2516:  SUBLW  FF
2518:  BNZ   2520
....................             return EOF; 
251A:  MOVLW  FF
251C:  MOVWF  01
251E:  BRA    27EE
2520:  MOVLB  5
2522:  BRA    24B4
....................        
....................       return 0; 
2524:  MOVLW  00
2526:  MOVWF  01
2528:  MOVLB  0
252A:  BRA    27EE
252C:  MOVLB  5
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
252E:  MOVFF  577,03
2532:  MOVFF  576,FE9
2536:  MOVFF  577,FEA
253A:  MOVFF  FEF,5C4
253E:  MOVFF  FEC,5C5
2542:  MOVFF  FEC,5C6
2546:  MOVFF  FEC,5C7
254A:  MOVFF  FEA,585
254E:  MOVFF  FE9,584
2552:  BCF    FD8.1
2554:  CLRF   xCB
2556:  CLRF   xCA
2558:  MOVFF  226,5C9
255C:  MOVFF  225,5C8
2560:  MOVLB  0
2562:  CALL   11D2
2566:  MOVFF  585,FEA
256A:  MOVFF  584,FE9
256E:  MOVFF  03,57F
2572:  MOVFF  02,57E
2576:  MOVFF  01,57D
257A:  MOVFF  00,57C
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
257E:  MOVLW  14
2580:  MOVLB  5
2582:  ADDWF  x74,W
2584:  MOVWF  FE9
2586:  MOVLW  00
2588:  ADDWFC x75,W
258A:  MOVWF  FEA
258C:  MOVFF  FEF,5BC
2590:  MOVFF  FEC,5BD
2594:  MOVFF  FEC,5BE
2598:  MOVFF  FEC,5BF
259C:  MOVLB  0
259E:  CALL   1266
25A2:  MOVFF  03,57B
25A6:  MOVFF  02,57A
25AA:  MOVFF  01,579
25AE:  MOVFF  00,578
....................  
....................    // head to that cluster 
....................    while(i > 0) 
25B2:  MOVLB  5
25B4:  MOVF   x7C,F
25B6:  BNZ   25C4
25B8:  MOVF   x7D,F
25BA:  BNZ   25C4
25BC:  MOVF   x7E,F
25BE:  BNZ   25C4
25C0:  MOVF   x7F,F
25C2:  BZ    25EC
....................    { 
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
25C4:  MOVLW  05
25C6:  MOVWF  xB9
25C8:  MOVLW  78
25CA:  MOVWF  xB8
25CC:  MOVLB  0
25CE:  CALL   182A
25D2:  MOVF   01,F
25D4:  BZ    25DC
....................          return EOF; 
25D6:  MOVLW  FF
25D8:  MOVWF  01
25DA:  BRA    27EE
....................       i -= 1; 
25DC:  MOVLW  01
25DE:  MOVLB  5
25E0:  SUBWF  x7C,F
25E2:  MOVLW  00
25E4:  SUBWFB x7D,F
25E6:  SUBWFB x7E,F
25E8:  SUBWFB x7F,F
25EA:  BRA    25B4
....................    } 
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
25EC:  MOVLW  04
25EE:  ADDWF  x74,W
25F0:  MOVWF  01
25F2:  MOVLW  00
25F4:  ADDWFC x75,W
25F6:  MOVWF  03
25F8:  MOVFF  01,580
25FC:  MOVWF  x81
25FE:  MOVFF  57B,5C5
2602:  MOVFF  57A,5C4
2606:  MOVFF  579,5C3
260A:  MOVFF  578,5C2
260E:  MOVLB  0
2610:  CALL   13B0
2614:  MOVFF  581,FEA
2618:  MOVFF  580,FE9
261C:  MOVFF  00,FEF
2620:  MOVFF  01,FEC
2624:  MOVFF  02,FEC
2628:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
262C:  MOVLW  04
262E:  MOVLB  5
2630:  ADDWF  x74,W
2632:  MOVWF  01
2634:  MOVLW  00
2636:  ADDWFC x75,W
2638:  MOVFF  01,580
263C:  MOVWF  x81
263E:  MOVWF  FEA
2640:  MOVFF  01,FE9
2644:  MOVFF  FEF,582
2648:  MOVFF  FEC,583
264C:  MOVFF  FEC,584
2650:  MOVFF  FEC,585
2654:  MOVFF  577,03
2658:  MOVFF  576,FE9
265C:  MOVFF  577,FEA
2660:  MOVFF  FEF,5C4
2664:  MOVFF  FEC,5C5
2668:  MOVFF  FEC,5C6
266C:  MOVFF  FEC,5C7
2670:  MOVFF  FEA,58B
2674:  MOVFF  FE9,58A
2678:  BSF    FD8.1
267A:  MOVLW  05
267C:  MOVWF  FEA
267E:  MOVLW  8C
2680:  MOVWF  FE9
2682:  CLRF   xCB
2684:  CLRF   xCA
2686:  MOVFF  226,5C9
268A:  MOVFF  225,5C8
268E:  MOVLB  0
2690:  CALL   11D2
2694:  MOVFF  58C,00
2698:  MOVFF  58D,01
269C:  MOVFF  58E,02
26A0:  MOVFF  58F,03
26A4:  MOVFF  58B,FEA
26A8:  MOVFF  58A,FE9
26AC:  MOVLB  5
26AE:  MOVF   x82,W
26B0:  ADDWF  00,F
26B2:  MOVF   x83,W
26B4:  ADDWFC 01,F
26B6:  MOVF   x84,W
26B8:  ADDWFC 02,F
26BA:  MOVF   x85,W
26BC:  ADDWFC 03,F
26BE:  MOVFF  581,FEA
26C2:  MOVFF  580,FE9
26C6:  MOVFF  00,FEF
26CA:  MOVFF  01,FEC
26CE:  MOVFF  02,FEC
26D2:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
26D6:  MOVLW  19
26D8:  ADDWF  x74,W
26DA:  MOVWF  FE9
26DC:  MOVLW  00
26DE:  ADDWFC x75,W
26E0:  MOVWF  FEA
26E2:  BTFSS  FEF.0
26E4:  BRA    27AC
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
26E6:  MOVLW  10
26E8:  ADDWF  x74,W
26EA:  MOVWF  FE9
26EC:  MOVLW  00
26EE:  ADDWFC x75,W
26F0:  MOVWF  FEA
26F2:  MOVFF  FEF,582
26F6:  MOVFF  FEC,583
26FA:  MOVFF  FEC,584
26FE:  MOVFF  FEC,585
2702:  MOVFF  576,FE9
2706:  MOVFF  577,FEA
270A:  MOVFF  FEF,00
270E:  MOVFF  FEC,01
2712:  MOVFF  FEC,02
2716:  MOVFF  FEC,03
271A:  MOVF   00,W
271C:  SUBWF  x82,W
271E:  MOVWF  00
2720:  MOVF   01,W
2722:  SUBWFB x83,W
2724:  MOVWF  01
2726:  MOVF   02,W
2728:  SUBWFB x84,W
272A:  MOVWF  02
272C:  MOVF   03,W
272E:  SUBWFB x85,W
2730:  MOVFF  575,FEA
2734:  MOVFF  574,FE9
2738:  MOVFF  00,FEF
273C:  MOVFF  01,FEC
2740:  MOVFF  02,FEC
2744:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
2746:  MOVLW  04
2748:  ADDWF  x74,W
274A:  MOVWF  FE9
274C:  MOVLW  00
274E:  ADDWFC x75,W
2750:  MOVWF  FEA
2752:  MOVFF  FEF,5BF
2756:  MOVFF  FEC,5C0
275A:  MOVFF  FEC,5C1
275E:  MOVFF  FEC,5C2
2762:  MOVLW  1A
2764:  ADDWF  x74,W
2766:  MOVWF  01
2768:  MOVLW  00
276A:  ADDWFC x75,W
276C:  MOVWF  03
276E:  MOVFF  01,584
2772:  MOVWF  x85
2774:  CLRF   xC4
2776:  MOVLW  20
2778:  MOVWF  xC3
277A:  MOVFF  03,5C6
277E:  MOVFF  01,5C5
2782:  MOVLB  0
2784:  CALL   0CAA
2788:  MOVF   01,F
278A:  BZ    27A8
....................       { 
....................          stream->Flags |= Read_Error; 
278C:  MOVLW  19
278E:  MOVLB  5
2790:  ADDWF  x74,W
2792:  MOVWF  FE9
2794:  MOVLW  00
2796:  ADDWFC x75,W
2798:  MOVWF  FEA
279A:  MOVF   FEF,W
279C:  IORLW  20
279E:  MOVWF  FEF
....................          return EOF; 
27A0:  MOVLW  FF
27A2:  MOVWF  01
27A4:  MOVLB  0
27A6:  BRA    27EE
....................       } 
....................    } 
27A8:  BRA    27EA
27AA:  MOVLB  5
....................  
....................    else 
....................       stream->Size = *position; 
27AC:  MOVLW  10
27AE:  ADDWF  x74,W
27B0:  MOVWF  01
27B2:  MOVLW  00
27B4:  ADDWFC x75,W
27B6:  MOVFF  01,580
27BA:  MOVFF  576,FE9
27BE:  MOVFF  577,FEA
27C2:  MOVFF  FEF,00
27C6:  MOVFF  FEC,01
27CA:  MOVFF  FEC,02
27CE:  MOVFF  FEC,03
27D2:  MOVWF  FEA
27D4:  MOVFF  580,FE9
27D8:  MOVFF  00,FEF
27DC:  MOVFF  01,FEC
27E0:  MOVFF  02,FEC
27E4:  MOVFF  03,FEC
27E8:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
27EA:  MOVLW  00
27EC:  MOVWF  01
27EE:  GOTO   2CE0 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
....................    { 
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_SET: 
....................          myoffset = offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
*
3558:  MOVLW  19
355A:  MOVLB  4
355C:  ADDWF  xE8,W
355E:  MOVWF  FE9
3560:  MOVLW  00
3562:  ADDWFC xE9,W
3564:  MOVWF  FEA
3566:  BTFSC  FEF.1
3568:  BRA    357A
356A:  MOVLW  19
356C:  ADDWF  xE8,W
356E:  MOVWF  FE9
3570:  MOVLW  00
3572:  ADDWFC xE9,W
3574:  MOVWF  FEA
3576:  BTFSS  FEF.2
3578:  BRA    36EA
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
357A:  MOVLW  04
357C:  ADDWF  xE8,W
357E:  MOVWF  FE9
3580:  MOVLW  00
3582:  ADDWFC xE9,W
3584:  MOVWF  FEA
3586:  MOVFF  FEF,4EA
358A:  MOVFF  FEC,4EB
358E:  MOVFF  FEC,4EC
3592:  MOVFF  FEC,4ED
3596:  MOVLW  1F
3598:  ANDWF  xEA,F
359A:  CLRF   xEB
359C:  CLRF   xEC
359E:  CLRF   xED
35A0:  MOVF   xEA,F
35A2:  BNZ   3634
35A4:  MOVF   xEB,F
35A6:  BNZ   3634
35A8:  MOVF   xEC,F
35AA:  BNZ   3634
35AC:  MOVF   xED,F
35AE:  BNZ   3634
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
35B0:  MOVLW  04
35B2:  ADDWF  xE8,W
35B4:  MOVWF  FE9
35B6:  MOVLW  00
35B8:  ADDWFC xE9,W
35BA:  MOVWF  FEA
35BC:  MOVFF  FEF,4EA
35C0:  MOVFF  FEC,4EB
35C4:  MOVFF  FEC,4EC
35C8:  MOVFF  FEC,4ED
35CC:  MOVLW  20
35CE:  SUBWF  xEA,F
35D0:  MOVLW  00
35D2:  SUBWFB xEB,F
35D4:  SUBWFB xEC,F
35D6:  SUBWFB xED,F
35D8:  MOVLW  1A
35DA:  ADDWF  xE8,W
35DC:  MOVWF  01
35DE:  MOVLW  00
35E0:  ADDWFC xE9,W
35E2:  MOVWF  03
35E4:  MOVFF  01,4EE
35E8:  MOVWF  xEF
35EA:  MOVFF  4ED,5C9
35EE:  MOVFF  4EC,5C8
35F2:  MOVFF  4EB,5C7
35F6:  MOVFF  4EA,5C6
35FA:  MOVLB  5
35FC:  CLRF   xCB
35FE:  MOVLW  20
3600:  MOVWF  xCA
3602:  MOVFF  03,5CD
3606:  MOVFF  01,5CC
360A:  MOVLB  0
360C:  CALL   18F4
3610:  MOVF   01,F
3612:  BZ    3630
....................          { 
....................             stream->Flags |= Write_Error; 
3614:  MOVLW  19
3616:  MOVLB  4
3618:  ADDWF  xE8,W
361A:  MOVWF  FE9
361C:  MOVLW  00
361E:  ADDWFC xE9,W
3620:  MOVWF  FEA
3622:  MOVF   FEF,W
3624:  IORLW  40
3626:  MOVWF  FEF
....................             return EOF; 
3628:  MOVLW  FF
362A:  MOVWF  01
362C:  BRA    36EE
362E:  MOVLB  0
....................          } 
....................       } 
3630:  BRA    36E0
3632:  MOVLB  4
....................       else 
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
3634:  MOVLW  04
3636:  ADDWF  xE8,W
3638:  MOVWF  FE9
363A:  MOVLW  00
363C:  ADDWFC xE9,W
363E:  MOVWF  FEA
3640:  MOVFF  FEF,4EA
3644:  MOVFF  FEC,4EB
3648:  MOVFF  FEC,4EC
364C:  MOVFF  FEC,4ED
3650:  MOVLW  04
3652:  ADDWF  xE8,W
3654:  MOVWF  FE9
3656:  MOVLW  00
3658:  ADDWFC xE9,W
365A:  MOVWF  FEA
365C:  MOVFF  FEF,4EE
3660:  MOVFF  FEC,4EF
3664:  MOVFF  FEC,4F0
3668:  MOVFF  FEC,4F1
366C:  MOVF   xEE,W
366E:  ANDLW  1F
3670:  MOVWF  00
3672:  CLRF   01
3674:  CLRF   02
3676:  CLRF   03
3678:  MOVF   00,W
367A:  SUBWF  xEA,F
367C:  MOVF   01,W
367E:  SUBWFB xEB,F
3680:  MOVF   02,W
3682:  SUBWFB xEC,F
3684:  MOVF   03,W
3686:  SUBWFB xED,F
3688:  MOVLW  1A
368A:  ADDWF  xE8,W
368C:  MOVWF  01
368E:  MOVLW  00
3690:  ADDWFC xE9,W
3692:  MOVWF  03
3694:  MOVFF  01,4EE
3698:  MOVWF  xEF
369A:  MOVFF  4ED,5C9
369E:  MOVFF  4EC,5C8
36A2:  MOVFF  4EB,5C7
36A6:  MOVFF  4EA,5C6
36AA:  MOVLB  5
36AC:  CLRF   xCB
36AE:  MOVLW  20
36B0:  MOVWF  xCA
36B2:  MOVFF  03,5CD
36B6:  MOVFF  01,5CC
36BA:  MOVLB  0
36BC:  CALL   18F4
36C0:  MOVF   01,F
36C2:  BZ    36E0
....................          { 
....................             stream->Flags |= Write_Error; 
36C4:  MOVLW  19
36C6:  MOVLB  4
36C8:  ADDWF  xE8,W
36CA:  MOVWF  FE9
36CC:  MOVLW  00
36CE:  ADDWFC xE9,W
36D0:  MOVWF  FEA
36D2:  MOVF   FEF,W
36D4:  IORLW  40
36D6:  MOVWF  FEF
....................             return EOF; 
36D8:  MOVLW  FF
36DA:  MOVWF  01
36DC:  BRA    36EE
36DE:  MOVLB  0
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
36E0:  CALL   0B94
36E4:  MOVF   01,W
36E6:  MOVLB  4
36E8:  BRA    36EE
....................    } 
....................    return 0; 
36EA:  MOVLW  00
36EC:  MOVWF  01
36EE:  MOVLB  0
36F0:  GOTO   397A (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
1A8A:  MOVLW  04
1A8C:  MOVLB  5
1A8E:  ADDWF  x80,W
1A90:  MOVWF  01
1A92:  MOVLW  00
1A94:  ADDWFC x81,W
1A96:  MOVWF  03
1A98:  MOVFF  01,582
1A9C:  MOVWF  x83
1A9E:  MOVLW  14
1AA0:  ADDWF  x80,W
1AA2:  MOVWF  FE9
1AA4:  MOVLW  00
1AA6:  ADDWFC x81,W
1AA8:  MOVWF  FEA
1AAA:  MOVFF  FEF,00
1AAE:  MOVFF  FEC,01
1AB2:  MOVFF  FEC,02
1AB6:  MOVFF  FEC,03
1ABA:  MOVFF  583,FEA
1ABE:  MOVFF  582,FE9
1AC2:  MOVFF  00,FEF
1AC6:  MOVFF  01,FEC
1ACA:  MOVFF  02,FEC
1ACE:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
1AD2:  MOVLW  10
1AD4:  ADDWF  x80,W
1AD6:  MOVWF  FE9
1AD8:  MOVLW  00
1ADA:  ADDWFC x81,W
1ADC:  MOVWF  FEA
1ADE:  MOVFF  FEF,00
1AE2:  MOVFF  FEC,01
1AE6:  MOVFF  FEC,02
1AEA:  MOVFF  FEC,03
1AEE:  MOVFF  581,FEA
1AF2:  MOVFF  580,FE9
1AF6:  MOVFF  00,FEF
1AFA:  MOVFF  01,FEC
1AFE:  MOVFF  02,FEC
1B02:  MOVFF  03,FEC
1B06:  MOVLB  0
1B08:  GOTO   243A (RETURN)
.................... } 
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
.................... { 
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
....................          return EOF; 
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................       return EOF; 
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................       return EOF; 
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
....................    { 
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................          return EOF; 
....................  
....................       if(get_prev_entry(&i) == EOF) 
....................          return EOF; 
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................          return EOF; 
....................    } 
....................     
....................    if(fatclose(&stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
....................       return EOF; 
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
.................... { 
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       filename[filename_pos] = fname[fname_pos]; 
....................       fname_pos += 1; 
....................       filename_pos += 1; 
....................    } 
....................    filename[filename_pos] = '\0'; 
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
....................       return EOF; 
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
....................       entire_entry[buf] = 0; 
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
.................... { 
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
....................    dname[dname_pos] = '\0'; 
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       dirname[dirname_pos] = dname[dname_pos]; 
....................       dname_pos += 1; 
....................       dirname_pos += 1; 
....................    } 
....................    dirname[dirname_pos] = '\0'; 
....................    dname[dname_pos] = '/'; 
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
....................       return EOF; 
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
....................       return EOF; 
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
....................       return EOF; 
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
....................       entire_entry[j] = 0; 
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
....................    { 
....................       if(j < 0x01) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else if(j == 0x0B) 
....................          entire_entry[j] = 0x10; 
....................       else 
....................          entire_entry[j] = 0x00; 
....................    } 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
....................    { 
....................       if(j < 0x02) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else 
....................          entire_entry[j] = 0x10; 
....................    } 
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
....................    { 
....................       entire_entry[0x14] = 0x00; 
....................       entire_entry[0x15] = 0x00; 
....................       entire_entry[0x1A] = 0x00; 
....................       entire_entry[0x1B] = 0x00; 
....................    } 
....................    else 
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
*
2856:  MOVLB  5
2858:  CLRF   x4D
.................... { 
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
285A:  MOVLW  14
285C:  ADDWF  x49,W
285E:  MOVWF  FE9
2860:  MOVLW  00
2862:  ADDWFC x4A,W
2864:  MOVWF  FEA
2866:  MOVFF  FEF,54E
286A:  MOVFF  FEC,54F
286E:  MOVFF  FEC,550
2872:  MOVFF  FEC,551
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
2876:  MOVFF  551,5C2
287A:  MOVFF  550,5C1
287E:  MOVFF  54F,5C0
2882:  MOVFF  54E,5BF
2886:  CLRF   xC4
2888:  MOVLW  01
288A:  MOVWF  xC3
288C:  MOVLW  05
288E:  MOVWF  xC6
2890:  MOVLW  4C
2892:  MOVWF  xC5
2894:  MOVLB  0
2896:  CALL   0CAA
289A:  MOVF   01,W
289C:  MOVLB  5
289E:  ADDWF  x4D,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
28A0:  MOVLW  0B
28A2:  ADDWF  x4E,W
28A4:  MOVWF  x72
28A6:  MOVLW  00
28A8:  ADDWFC x4F,W
28AA:  MOVWF  x73
28AC:  MOVLW  00
28AE:  ADDWFC x50,W
28B0:  MOVWF  x74
28B2:  MOVLW  00
28B4:  ADDWFC x51,W
28B6:  MOVWF  x75
28B8:  MOVWF  xC2
28BA:  MOVFF  574,5C1
28BE:  MOVFF  573,5C0
28C2:  MOVFF  572,5BF
28C6:  CLRF   xC4
28C8:  MOVLW  01
28CA:  MOVWF  xC3
28CC:  MOVLW  05
28CE:  MOVWF  xC6
28D0:  MOVLW  4B
28D2:  MOVWF  xC5
28D4:  MOVLB  0
28D6:  CALL   0CAA
28DA:  MOVF   01,W
28DC:  MOVLB  5
28DE:  ADDWF  x4D,F
....................       if(ec != GOODEC) 
28E0:  MOVF   x4D,F
28E2:  BZ    28FC
....................       { 
....................          stream->Flags |= Read_Error; 
28E4:  MOVLW  19
28E6:  ADDWF  x49,W
28E8:  MOVWF  FE9
28EA:  MOVLW  00
28EC:  ADDWFC x4A,W
28EE:  MOVWF  FEA
28F0:  MOVF   FEF,W
28F2:  IORLW  20
28F4:  MOVWF  FEF
....................          return EOF; 
28F6:  MOVLW  FF
28F8:  MOVWF  01
28FA:  BRA    2F22
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
28FC:  MOVF   x4C,W
28FE:  SUBLW  E5
2900:  BTFSC  FD8.2
2902:  BRA    2EE4
2904:  MOVF   x48,W
2906:  SUBWF  x4B,W
2908:  BTFSS  FD8.2
290A:  BRA    2EE4
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
290C:  MOVFF  551,575
2910:  MOVFF  550,574
2914:  MOVFF  54F,573
2918:  MOVFF  54E,572
291C:  MOVLW  05
291E:  MOVWF  x77
2920:  MOVLW  52
2922:  MOVWF  x76
2924:  MOVLB  0
2926:  GOTO   1632
292A:  MOVF   01,W
292C:  SUBLW  FF
292E:  BNZ   293A
....................             return EOF; 
2930:  MOVLW  FF
2932:  MOVWF  01
2934:  MOVLB  5
2936:  BRA    2F22
2938:  MOVLB  0
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
293A:  MOVFF  547,573
293E:  MOVFF  546,572
2942:  MOVLW  05
2944:  MOVLB  5
2946:  MOVWF  x75
2948:  MOVLW  52
294A:  MOVWF  x74
294C:  MOVLB  0
294E:  GOTO   17B0
2952:  MOVF   01,F
2954:  BTFSS  FD8.2
2956:  BRA    2EE6
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
2958:  MOVLW  0C
295A:  MOVLB  5
295C:  ADDWF  x49,W
295E:  MOVWF  01
2960:  MOVLW  00
2962:  ADDWFC x4A,W
2964:  MOVWF  03
2966:  MOVFF  01,572
296A:  MOVWF  x73
296C:  MOVLW  14
296E:  ADDWF  x49,W
2970:  MOVWF  FE9
2972:  MOVLW  00
2974:  ADDWFC x4A,W
2976:  MOVWF  FEA
2978:  MOVFF  FEF,00
297C:  MOVFF  FEC,01
2980:  MOVFF  FEC,02
2984:  MOVFF  FEC,03
2988:  MOVFF  573,FEA
298C:  MOVFF  572,FE9
2990:  MOVFF  00,FEF
2994:  MOVFF  01,FEC
2998:  MOVFF  02,FEC
299C:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
29A0:  MOVLW  1C
29A2:  ADDWF  x4E,W
29A4:  MOVWF  x72
29A6:  MOVLW  00
29A8:  ADDWFC x4F,W
29AA:  MOVWF  x73
29AC:  MOVLW  00
29AE:  ADDWFC x50,W
29B0:  MOVWF  x74
29B2:  MOVLW  00
29B4:  ADDWFC x51,W
29B6:  MOVWF  x75
29B8:  MOVLW  10
29BA:  ADDWF  x49,W
29BC:  MOVWF  01
29BE:  MOVLW  00
29C0:  ADDWFC x4A,W
29C2:  MOVWF  03
29C4:  MOVFF  01,576
29C8:  MOVWF  x77
29CA:  MOVFF  575,5C2
29CE:  MOVFF  574,5C1
29D2:  MOVFF  573,5C0
29D6:  MOVFF  572,5BF
29DA:  CLRF   xC4
29DC:  MOVLW  04
29DE:  MOVWF  xC3
29E0:  MOVFF  03,5C6
29E4:  MOVFF  01,5C5
29E8:  MOVLB  0
29EA:  CALL   0CAA
29EE:  MOVF   01,W
29F0:  MOVLB  5
29F2:  ADDWF  x4D,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
29F4:  MOVLW  14
29F6:  ADDWF  x4E,W
29F8:  MOVWF  x72
29FA:  MOVLW  00
29FC:  ADDWFC x4F,W
29FE:  MOVWF  x73
2A00:  MOVLW  00
2A02:  ADDWFC x50,W
2A04:  MOVWF  x74
2A06:  MOVLW  00
2A08:  ADDWFC x51,W
2A0A:  MOVWF  x75
2A0C:  MOVLW  14
2A0E:  ADDWF  x49,W
2A10:  MOVWF  01
2A12:  MOVLW  00
2A14:  ADDWFC x4A,W
2A16:  MOVWF  03
2A18:  MOVFF  01,576
2A1C:  MOVWF  x77
2A1E:  MOVLW  02
2A20:  ADDWF  x76,F
2A22:  MOVLW  00
2A24:  ADDWFC x77,F
2A26:  MOVFF  575,5C2
2A2A:  MOVFF  574,5C1
2A2E:  MOVFF  573,5C0
2A32:  MOVFF  572,5BF
2A36:  CLRF   xC4
2A38:  MOVLW  02
2A3A:  MOVWF  xC3
2A3C:  MOVFF  577,5C6
2A40:  MOVFF  576,5C5
2A44:  MOVLB  0
2A46:  CALL   0CAA
2A4A:  MOVF   01,W
2A4C:  MOVLB  5
2A4E:  ADDWF  x4D,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
2A50:  MOVLW  1A
2A52:  ADDWF  x4E,W
2A54:  MOVWF  x72
2A56:  MOVLW  00
2A58:  ADDWFC x4F,W
2A5A:  MOVWF  x73
2A5C:  MOVLW  00
2A5E:  ADDWFC x50,W
2A60:  MOVWF  x74
2A62:  MOVLW  00
2A64:  ADDWFC x51,W
2A66:  MOVWF  x75
2A68:  MOVLW  14
2A6A:  ADDWF  x49,W
2A6C:  MOVWF  01
2A6E:  MOVLW  00
2A70:  ADDWFC x4A,W
2A72:  MOVWF  03
2A74:  MOVFF  01,576
2A78:  MOVWF  x77
2A7A:  MOVFF  575,5C2
2A7E:  MOVFF  574,5C1
2A82:  MOVFF  573,5C0
2A86:  MOVFF  572,5BF
2A8A:  CLRF   xC4
2A8C:  MOVLW  02
2A8E:  MOVWF  xC3
2A90:  MOVFF  03,5C6
2A94:  MOVFF  01,5C5
2A98:  MOVLB  0
2A9A:  CALL   0CAA
2A9E:  MOVF   01,W
2AA0:  MOVLB  5
2AA2:  ADDWF  x4D,F
....................  
....................             if(ec != GOODEC) 
2AA4:  MOVF   x4D,F
2AA6:  BZ    2AC0
....................             { 
....................                stream->Flags |= Read_Error; 
2AA8:  MOVLW  19
2AAA:  ADDWF  x49,W
2AAC:  MOVWF  FE9
2AAE:  MOVLW  00
2AB0:  ADDWFC x4A,W
2AB2:  MOVWF  FEA
2AB4:  MOVF   FEF,W
2AB6:  IORLW  20
2AB8:  MOVWF  FEF
....................                return EOF; 
2ABA:  MOVLW  FF
2ABC:  MOVWF  01
2ABE:  BRA    2F22
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
2AC0:  MOVLW  14
2AC2:  ADDWF  x49,W
2AC4:  MOVWF  01
2AC6:  MOVLW  00
2AC8:  ADDWFC x4A,W
2ACA:  MOVWF  03
2ACC:  MOVFF  01,572
2AD0:  MOVWF  x73
2AD2:  MOVLW  14
2AD4:  ADDWF  x49,W
2AD6:  MOVWF  FE9
2AD8:  MOVLW  00
2ADA:  ADDWFC x4A,W
2ADC:  MOVWF  FEA
2ADE:  MOVFF  FEF,5C2
2AE2:  MOVFF  FEC,5C3
2AE6:  MOVFF  FEC,5C4
2AEA:  MOVFF  FEC,5C5
2AEE:  MOVLB  0
2AF0:  CALL   13B0
2AF4:  MOVFF  573,FEA
2AF8:  MOVFF  572,FE9
2AFC:  MOVFF  00,FEF
2B00:  MOVFF  01,FEC
2B04:  MOVFF  02,FEC
2B08:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
2B0C:  MOVLW  08
2B0E:  MOVLB  5
2B10:  ADDWF  x49,W
2B12:  MOVWF  FE9
2B14:  MOVLW  00
2B16:  ADDWFC x4A,W
2B18:  MOVWF  FEA
2B1A:  MOVFF  54E,FEF
2B1E:  MOVFF  54F,FEC
2B22:  MOVFF  550,FEC
2B26:  MOVFF  551,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
2B2A:  MOVLW  10
2B2C:  ADDWF  x49,W
2B2E:  MOVWF  FE9
2B30:  MOVLW  00
2B32:  ADDWFC x4A,W
2B34:  MOVWF  FEA
2B36:  MOVFF  FEF,00
2B3A:  MOVFF  FEC,01
2B3E:  MOVFF  FEC,02
2B42:  MOVFF  FEC,03
2B46:  MOVFF  54A,FEA
2B4A:  MOVFF  549,FE9
2B4E:  MOVFF  00,FEF
2B52:  MOVFF  01,FEC
2B56:  MOVFF  02,FEC
2B5A:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
2B5E:  MOVF   x48,W
2B60:  SUBLW  20
2B62:  BTFSS  FD8.2
2B64:  BRA    2ECE
....................             { 
....................                stream->File_Type = Data_File; 
2B66:  MOVLW  18
2B68:  ADDWF  x49,W
2B6A:  MOVWF  FE9
2B6C:  MOVLW  00
2B6E:  ADDWFC x4A,W
2B70:  MOVWF  FEA
2B72:  CLRF   FEF
....................                if(stream->Flags & Write) 
2B74:  MOVLW  19
2B76:  ADDWF  x49,W
2B78:  MOVWF  FE9
2B7A:  MOVLW  00
2B7C:  ADDWFC x4A,W
2B7E:  MOVWF  FEA
2B80:  BTFSS  FEF.1
2B82:  BRA    2C7C
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
2B84:  MOVLW  10
2B86:  ADDWF  x49,W
2B88:  MOVWF  FE9
2B8A:  MOVLW  00
2B8C:  ADDWFC x4A,W
2B8E:  MOVWF  FEA
2B90:  MOVF   FEE,F
2B92:  MOVF   FEE,F
2B94:  CLRF   FEC
2B96:  MOVF   FED,F
2B98:  CLRF   FEF
2B9A:  MOVF   FED,F
2B9C:  CLRF   FEF
2B9E:  MOVF   FED,F
2BA0:  CLRF   FEF
2BA2:  MOVLW  00
2BA4:  MOVFF  54A,FEA
2BA8:  MOVFF  549,FE9
2BAC:  MOVFF  00,FEF
2BB0:  MOVFF  549,FEC
2BB4:  MOVFF  02,FEC
2BB8:  MOVFF  54A,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
2BBC:  MOVLW  14
2BBE:  ADDWF  x49,W
2BC0:  MOVWF  FE9
2BC2:  MOVLW  00
2BC4:  ADDWFC x4A,W
2BC6:  MOVWF  FEA
2BC8:  MOVFF  FEF,572
2BCC:  MOVFF  FEC,573
2BD0:  MOVFF  FEC,574
2BD4:  MOVFF  FEC,575
2BD8:  MOVLB  2
2BDA:  MOVF   x2C,W
2BDC:  MOVLB  5
2BDE:  SUBWF  x75,W
2BE0:  BNC   2C5A
2BE2:  BNZ   2C06
2BE4:  MOVLB  2
2BE6:  MOVF   x2B,W
2BE8:  MOVLB  5
2BEA:  SUBWF  x74,W
2BEC:  BNC   2C5A
2BEE:  BNZ   2C06
2BF0:  MOVLB  2
2BF2:  MOVF   x2A,W
2BF4:  MOVLB  5
2BF6:  SUBWF  x73,W
2BF8:  BNC   2C5A
2BFA:  BNZ   2C06
2BFC:  MOVLB  2
2BFE:  MOVF   x29,W
2C00:  MOVLB  5
2C02:  SUBWF  x72,W
2C04:  BNC   2C5A
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
2C06:  MOVLW  14
2C08:  ADDWF  x49,W
2C0A:  MOVWF  FE9
2C0C:  MOVLW  00
2C0E:  ADDWFC x4A,W
2C10:  MOVWF  FEA
2C12:  MOVFF  FEF,5BC
2C16:  MOVFF  FEC,5BD
2C1A:  MOVFF  FEC,5BE
2C1E:  MOVFF  FEC,5BF
2C22:  MOVLB  0
2C24:  CALL   1266
2C28:  MOVFF  03,575
2C2C:  MOVFF  02,574
2C30:  MOVFF  01,573
2C34:  MOVFF  00,572
2C38:  MOVFF  03,579
2C3C:  MOVFF  02,578
2C40:  MOVFF  01,577
2C44:  MOVFF  00,576
2C48:  GOTO   19E0
2C4C:  MOVF   01,W
2C4E:  SUBLW  FF
2C50:  BNZ   2C5C
....................                         return EOF; 
2C52:  MOVLW  FF
2C54:  MOVWF  01
2C56:  MOVLB  5
2C58:  BRA    2F22
2C5A:  MOVLB  0
....................                   stream->Cur_Char = 0; 
2C5C:  MOVLW  04
2C5E:  MOVLB  5
2C60:  ADDWF  x49,W
2C62:  MOVWF  FE9
2C64:  MOVLW  00
2C66:  ADDWFC x4A,W
2C68:  MOVWF  FEA
2C6A:  MOVF   FEE,F
2C6C:  MOVF   FEE,F
2C6E:  CLRF   FEC
2C70:  MOVF   FED,F
2C72:  CLRF   FEF
2C74:  MOVF   FED,F
2C76:  CLRF   FEF
2C78:  MOVF   FED,F
2C7A:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
2C7C:  MOVLW  19
2C7E:  ADDWF  x49,W
2C80:  MOVWF  FE9
2C82:  MOVLW  00
2C84:  ADDWFC x4A,W
2C86:  MOVWF  FEA
2C88:  BTFSS  FEF.2
2C8A:  BRA    2E12
2C8C:  MOVLW  10
2C8E:  ADDWF  x49,W
2C90:  MOVWF  FE9
2C92:  MOVLW  00
2C94:  ADDWFC x4A,W
2C96:  MOVWF  FEA
2C98:  MOVFF  FEF,572
2C9C:  MOVFF  FEC,573
2CA0:  MOVFF  FEC,574
2CA4:  MOVFF  FEC,575
2CA8:  MOVF   x72,F
2CAA:  BNZ   2CBA
2CAC:  MOVF   x73,F
2CAE:  BNZ   2CBA
2CB0:  MOVF   x74,F
2CB2:  BNZ   2CBA
2CB4:  MOVF   x75,F
2CB6:  BTFSC  FD8.2
2CB8:  BRA    2E12
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
2CBA:  MOVLW  10
2CBC:  ADDWF  x49,W
2CBE:  MOVWF  01
2CC0:  MOVLW  00
2CC2:  ADDWFC x4A,W
2CC4:  MOVWF  03
2CC6:  MOVFF  01,572
2CCA:  MOVWF  x73
2CCC:  MOVFF  54A,575
2CD0:  MOVFF  549,574
2CD4:  MOVWF  x77
2CD6:  MOVFF  01,576
2CDA:  MOVLB  0
2CDC:  GOTO   23FE
2CE0:  MOVFF  01,54D
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
2CE4:  MOVLW  04
2CE6:  MOVLB  5
2CE8:  ADDWF  x49,W
2CEA:  MOVWF  FE9
2CEC:  MOVLW  00
2CEE:  ADDWFC x4A,W
2CF0:  MOVWF  FEA
2CF2:  MOVFF  FEF,572
2CF6:  MOVFF  FEC,573
2CFA:  MOVFF  FEC,574
2CFE:  MOVFF  FEC,575
2D02:  MOVLW  1F
2D04:  ANDWF  x72,F
2D06:  CLRF   x73
2D08:  CLRF   x74
2D0A:  CLRF   x75
2D0C:  MOVF   x72,F
2D0E:  BNZ   2D82
2D10:  MOVF   x73,F
2D12:  BNZ   2D82
2D14:  MOVF   x74,F
2D16:  BNZ   2D82
2D18:  MOVF   x75,F
2D1A:  BNZ   2D82
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
2D1C:  MOVLW  04
2D1E:  ADDWF  x49,W
2D20:  MOVWF  FE9
2D22:  MOVLW  00
2D24:  ADDWFC x4A,W
2D26:  MOVWF  FEA
2D28:  MOVFF  FEF,572
2D2C:  MOVFF  FEC,573
2D30:  MOVFF  FEC,574
2D34:  MOVFF  FEC,575
2D38:  MOVLW  20
2D3A:  SUBWF  x72,F
2D3C:  MOVLW  00
2D3E:  SUBWFB x73,F
2D40:  SUBWFB x74,F
2D42:  SUBWFB x75,F
2D44:  MOVLW  1A
2D46:  ADDWF  x49,W
2D48:  MOVWF  01
2D4A:  MOVLW  00
2D4C:  ADDWFC x4A,W
2D4E:  MOVWF  03
2D50:  MOVFF  01,576
2D54:  MOVWF  x77
2D56:  MOVFF  575,5C2
2D5A:  MOVFF  574,5C1
2D5E:  MOVFF  573,5C0
2D62:  MOVFF  572,5BF
2D66:  CLRF   xC4
2D68:  MOVLW  20
2D6A:  MOVWF  xC3
2D6C:  MOVFF  03,5C6
2D70:  MOVFF  01,5C5
2D74:  MOVLB  0
2D76:  CALL   0CAA
2D7A:  MOVF   01,W
2D7C:  MOVLB  5
2D7E:  ADDWF  x4D,F
2D80:  BRA    2E12
....................                   else 
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
2D82:  MOVLW  04
2D84:  ADDWF  x49,W
2D86:  MOVWF  FE9
2D88:  MOVLW  00
2D8A:  ADDWFC x4A,W
2D8C:  MOVWF  FEA
2D8E:  MOVFF  FEF,572
2D92:  MOVFF  FEC,573
2D96:  MOVFF  FEC,574
2D9A:  MOVFF  FEC,575
2D9E:  MOVLW  04
2DA0:  ADDWF  x49,W
2DA2:  MOVWF  FE9
2DA4:  MOVLW  00
2DA6:  ADDWFC x4A,W
2DA8:  MOVWF  FEA
2DAA:  MOVFF  FEF,576
2DAE:  MOVFF  FEC,577
2DB2:  MOVFF  FEC,578
2DB6:  MOVFF  FEC,579
2DBA:  MOVF   x76,W
2DBC:  ANDLW  1F
2DBE:  MOVWF  00
2DC0:  CLRF   01
2DC2:  CLRF   02
2DC4:  CLRF   03
2DC6:  MOVF   00,W
2DC8:  SUBWF  x72,F
2DCA:  MOVF   01,W
2DCC:  SUBWFB x73,F
2DCE:  MOVF   02,W
2DD0:  SUBWFB x74,F
2DD2:  MOVF   03,W
2DD4:  SUBWFB x75,F
2DD6:  MOVLW  1A
2DD8:  ADDWF  x49,W
2DDA:  MOVWF  01
2DDC:  MOVLW  00
2DDE:  ADDWFC x4A,W
2DE0:  MOVWF  03
2DE2:  MOVFF  01,576
2DE6:  MOVWF  x77
2DE8:  MOVFF  575,5C2
2DEC:  MOVFF  574,5C1
2DF0:  MOVFF  573,5C0
2DF4:  MOVFF  572,5BF
2DF8:  CLRF   xC4
2DFA:  MOVLW  20
2DFC:  MOVWF  xC3
2DFE:  MOVFF  03,5C6
2E02:  MOVFF  01,5C5
2E06:  MOVLB  0
2E08:  CALL   0CAA
2E0C:  MOVF   01,W
2E0E:  MOVLB  5
2E10:  ADDWF  x4D,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
2E12:  MOVLW  19
2E14:  ADDWF  x49,W
2E16:  MOVWF  FE9
2E18:  MOVLW  00
2E1A:  ADDWFC x4A,W
2E1C:  MOVWF  FEA
2E1E:  BTFSS  FEF.0
2E20:  BRA    2EB0
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
2E22:  MOVLW  04
2E24:  ADDWF  x49,W
2E26:  MOVWF  01
2E28:  MOVLW  00
2E2A:  ADDWFC x4A,W
2E2C:  MOVWF  03
2E2E:  MOVFF  01,572
2E32:  MOVWF  x73
2E34:  MOVLW  14
2E36:  ADDWF  x49,W
2E38:  MOVWF  FE9
2E3A:  MOVLW  00
2E3C:  ADDWFC x4A,W
2E3E:  MOVWF  FEA
2E40:  MOVFF  FEF,00
2E44:  MOVFF  FEC,01
2E48:  MOVFF  FEC,02
2E4C:  MOVFF  FEC,03
2E50:  MOVFF  573,FEA
2E54:  MOVFF  572,FE9
2E58:  MOVFF  00,FEF
2E5C:  MOVFF  01,FEC
2E60:  MOVFF  02,FEC
2E64:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
2E68:  MOVLW  04
2E6A:  ADDWF  x49,W
2E6C:  MOVWF  FE9
2E6E:  MOVLW  00
2E70:  ADDWFC x4A,W
2E72:  MOVWF  FEA
2E74:  MOVFF  FEF,5BF
2E78:  MOVFF  FEC,5C0
2E7C:  MOVFF  FEC,5C1
2E80:  MOVFF  FEC,5C2
2E84:  MOVLW  1A
2E86:  ADDWF  x49,W
2E88:  MOVWF  01
2E8A:  MOVLW  00
2E8C:  ADDWFC x4A,W
2E8E:  MOVWF  03
2E90:  MOVFF  01,576
2E94:  MOVWF  x77
2E96:  CLRF   xC4
2E98:  MOVLW  20
2E9A:  MOVWF  xC3
2E9C:  MOVFF  03,5C6
2EA0:  MOVFF  01,5C5
2EA4:  MOVLB  0
2EA6:  CALL   0CAA
2EAA:  MOVFF  01,54D
2EAE:  MOVLB  5
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
2EB0:  MOVF   x4D,F
2EB2:  BZ    2ECC
....................                { 
....................                   stream->Flags |= Read_Error; 
2EB4:  MOVLW  19
2EB6:  ADDWF  x49,W
2EB8:  MOVWF  FE9
2EBA:  MOVLW  00
2EBC:  ADDWFC x4A,W
2EBE:  MOVWF  FEA
2EC0:  MOVF   FEF,W
2EC2:  IORLW  20
2EC4:  MOVWF  FEF
....................                   return EOF; 
2EC6:  MOVLW  FF
2EC8:  MOVWF  01
2ECA:  BRA    2F22
....................                }                
....................             } 
2ECC:  BRA    2EDE
....................             else 
....................                stream->File_Type = Directory; 
2ECE:  MOVLW  18
2ED0:  ADDWF  x49,W
2ED2:  MOVWF  FE9
2ED4:  MOVLW  00
2ED6:  ADDWFC x4A,W
2ED8:  MOVWF  FEA
2EDA:  MOVLW  01
2EDC:  MOVWF  FEF
....................             return GOODEC; 
2EDE:  MOVLW  00
2EE0:  MOVWF  01
2EE2:  BRA    2F22
2EE4:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
2EE6:  MOVLW  05
2EE8:  MOVLB  5
2EEA:  MOVWF  x73
2EEC:  MOVLW  4E
2EEE:  MOVWF  x72
2EF0:  MOVLB  0
2EF2:  BRA    27F2
2EF4:  MOVF   01,W
2EF6:  SUBLW  FF
2EF8:  BNZ   2F04
....................          return EOF; 
2EFA:  MOVLW  FF
2EFC:  MOVWF  01
2EFE:  MOVLB  5
2F00:  BRA    2F22
2F02:  MOVLB  0
....................  
....................    } while(cur_state != 0x00); 
2F04:  MOVLB  5
2F06:  MOVF   x4C,F
2F08:  BTFSS  FD8.2
2F0A:  BRA    2876
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
2F0C:  MOVLW  19
2F0E:  ADDWF  x49,W
2F10:  MOVWF  FE9
2F12:  MOVLW  00
2F14:  ADDWFC x4A,W
2F16:  MOVWF  FEA
2F18:  MOVF   FEF,W
2F1A:  IORLW  80
2F1C:  MOVWF  FEF
....................    return EOF; 
2F1E:  MOVLW  FF
2F20:  MOVWF  01
2F22:  MOVLB  0
2F24:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
*
1632:  MOVLB  5
1634:  CLRF   x79
.................... { 
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
1636:  MOVFF  575,57F
163A:  MOVFF  574,57E
163E:  MOVFF  573,57D
1642:  MOVFF  572,57C
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
1646:  MOVLW  15
1648:  SUBWF  x7C,W
164A:  MOVWF  x80
164C:  MOVLW  00
164E:  SUBWFB x7D,W
1650:  MOVWF  x81
1652:  MOVLW  00
1654:  SUBWFB x7E,W
1656:  MOVWF  x82
1658:  MOVLW  00
165A:  SUBWFB x7F,W
165C:  MOVWF  x83
165E:  MOVWF  xC2
1660:  MOVFF  582,5C1
1664:  MOVFF  581,5C0
1668:  MOVFF  580,5BF
166C:  CLRF   xC4
166E:  MOVLW  01
1670:  MOVWF  xC3
1672:  MOVLW  05
1674:  MOVWF  xC6
1676:  MOVLW  7B
1678:  MOVWF  xC5
167A:  MOVLB  0
167C:  CALL   0CAA
1680:  MOVF   01,F
1682:  BZ    168A
....................       return EOF; 
1684:  MOVLW  FF
1686:  MOVWF  01
1688:  BRA    17AA
....................  
....................    if(type != 0x0F) 
168A:  MOVLB  5
168C:  MOVF   x7B,W
168E:  SUBLW  0F
1690:  BZ    16C6
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
1692:  MOVFF  57F,583
1696:  MOVFF  57E,582
169A:  MOVFF  57D,581
169E:  MOVFF  57C,580
16A2:  MOVFF  577,585
16A6:  MOVFF  576,584
16AA:  MOVFF  57B,586
16AE:  MOVLB  0
16B0:  BRA    109A
16B2:  MOVF   01,W
16B4:  SUBLW  FF
16B6:  BNZ   16BE
....................          return EOF; 
16B8:  MOVLW  FF
16BA:  MOVWF  01
16BC:  BRA    17AA
....................       return GOODEC; 
16BE:  MOVLW  00
16C0:  MOVWF  01
16C2:  BRA    17AA
16C4:  MOVLB  5
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
16C6:  MOVLW  05
16C8:  MOVWF  x81
16CA:  MOVLW  7C
16CC:  MOVWF  x80
16CE:  MOVLB  0
16D0:  BRA    15D0
16D2:  MOVF   01,W
16D4:  SUBLW  FF
16D6:  BNZ   16DE
....................          return EOF; 
16D8:  MOVLW  FF
16DA:  MOVWF  01
16DC:  BRA    17AA
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
16DE:  MOVLW  01
16E0:  MOVLB  5
16E2:  MOVWF  x78
16E4:  MOVF   x78,W
16E6:  SUBLW  1F
16E8:  BNC   1764
....................       { 
....................          if(j == 11) 
16EA:  MOVF   x78,W
16EC:  SUBLW  0B
16EE:  BNZ   16F6
....................             j = 14; 
16F0:  MOVLW  0E
16F2:  MOVWF  x78
16F4:  BRA    1700
....................          else if(j == 26) 
16F6:  MOVF   x78,W
16F8:  SUBLW  1A
16FA:  BNZ   1700
....................             j = 28; 
16FC:  MOVLW  1C
16FE:  MOVWF  x78
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
1700:  MOVF   x78,W
1702:  ADDWF  x7C,W
1704:  MOVWF  x80
1706:  MOVLW  00
1708:  ADDWFC x7D,W
170A:  MOVWF  x81
170C:  MOVLW  00
170E:  ADDWFC x7E,W
1710:  MOVWF  x82
1712:  MOVLW  00
1714:  ADDWFC x7F,W
1716:  MOVWF  x83
1718:  MOVF   x79,W
171A:  ADDWF  x76,W
171C:  MOVWF  01
171E:  MOVLW  00
1720:  ADDWFC x77,W
1722:  MOVWF  03
1724:  MOVFF  01,584
1728:  MOVWF  x85
172A:  MOVFF  583,5C2
172E:  MOVFF  582,5C1
1732:  MOVFF  581,5C0
1736:  MOVFF  580,5BF
173A:  CLRF   xC4
173C:  MOVLW  01
173E:  MOVWF  xC3
1740:  MOVFF  03,5C6
1744:  MOVFF  01,5C5
1748:  MOVLB  0
174A:  CALL   0CAA
174E:  MOVF   01,F
1750:  BZ    1758
....................             return EOF; 
1752:  MOVLW  FF
1754:  MOVWF  01
1756:  BRA    17AA
1758:  MOVLW  02
175A:  MOVLB  5
175C:  ADDWF  x78,F
175E:  MOVLW  01
1760:  ADDWF  x79,F
1762:  BRA    16E4
....................       } 
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
1764:  MOVFF  57F,5C2
1768:  MOVFF  57E,5C1
176C:  MOVFF  57D,5C0
1770:  MOVFF  57C,5BF
1774:  CLRF   xC4
1776:  MOVLW  01
1778:  MOVWF  xC3
177A:  MOVLW  05
177C:  MOVWF  xC6
177E:  MOVLW  7A
1780:  MOVWF  xC5
1782:  MOVLB  0
1784:  CALL   0CAA
1788:  MOVF   01,F
178A:  BZ    1792
....................          return EOF; 
178C:  MOVLW  FF
178E:  MOVWF  01
1790:  BRA    17AA
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
1792:  MOVLB  5
1794:  BTFSS  x7A.6
1796:  BRA    16C6
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
1798:  MOVF   x79,W
179A:  ADDWF  x76,W
179C:  MOVWF  FE9
179E:  MOVLW  00
17A0:  ADDWFC x77,W
17A2:  MOVWF  FEA
17A4:  CLRF   FEF
....................  
....................    return GOODEC; 
17A6:  MOVLW  00
17A8:  MOVWF  01
17AA:  MOVLB  0
17AC:  GOTO   292A (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
.................... { 
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
....................       return EOF; 
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
....................       return EOF; 
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
....................       entire_entry[entry_pos] = 0;    
....................  
....................    i = parent_dir_addr; 
....................    if(get_next_free_entry(&i) == EOF) 
....................       return EOF; 
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
....................    name_pos %= 13; 
....................  
....................    if(name_pos != 0) 
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
....................  
....................    if(name_pos % 13 == 0) 
....................       long_entry -= 1; 
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
....................  
....................    while(name_pos >= 0) 
....................    { 
....................       entry_pos = name_pos % 13; 
....................  
....................       if(entry_pos < 5) 
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
....................  
....................       else if(entry_pos < 11) 
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
....................  
....................       else 
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
....................       { 
....................          entire_entry[0] = long_entry; 
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
....................             long_entry &= 0x3F; 
....................  
....................          long_entry -= 1; 
....................  
....................          entire_entry[13] = chksum; 
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................             return EOF; 
....................          if(get_next_free_entry(&i) == EOF) 
....................             return EOF; 
....................          fill_entry(entire_entry, 0x00, 0); 
....................       } 
....................       name_pos -= 1; 
....................    } 
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
....................       return EOF; 
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
*
109A:  MOVLB  5
109C:  CLRF   x89
.................... { 
....................    int 
....................       buf, 
....................       i, 
....................       j = 0; 
....................  
....................    // one short file name has, at the most, 11 characters 
....................    for(i = 0; i < 11; i += 1) 
109E:  CLRF   x88
10A0:  MOVF   x88,W
10A2:  SUBLW  0A
10A4:  BNC   111C
....................    {       
....................       // read in a character 
....................       if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
10A6:  MOVF   x88,W
10A8:  ADDWF  x80,W
10AA:  MOVWF  x8A
10AC:  MOVLW  00
10AE:  ADDWFC x81,W
10B0:  MOVWF  x8B
10B2:  MOVLW  00
10B4:  ADDWFC x82,W
10B6:  MOVWF  x8C
10B8:  MOVLW  00
10BA:  ADDWFC x83,W
10BC:  MOVWF  x8D
10BE:  MOVWF  xC2
10C0:  MOVFF  58C,5C1
10C4:  MOVFF  58B,5C0
10C8:  MOVFF  58A,5BF
10CC:  CLRF   xC4
10CE:  MOVLW  01
10D0:  MOVWF  xC3
10D2:  MOVLW  05
10D4:  MOVWF  xC6
10D6:  MOVLW  87
10D8:  MOVWF  xC5
10DA:  MOVLB  0
10DC:  RCALL  0CAA
10DE:  MOVF   01,F
10E0:  BZ    10E8
....................          return EOF; 
10E2:  MOVLW  FF
10E4:  MOVWF  01
10E6:  BRA    11CC
....................        
....................       // convert the character 
....................       if(buf != ' ') 
10E8:  MOVLB  5
10EA:  MOVF   x87,W
10EC:  SUBLW  20
10EE:  BZ    1116
....................       {          
....................          sname[j] = tolower(buf); 
10F0:  MOVF   x89,W
10F2:  ADDWF  x84,W
10F4:  MOVWF  FE9
10F6:  MOVLW  00
10F8:  ADDWFC x85,W
10FA:  MOVWF  FEA
10FC:  MOVF   x87,W
10FE:  SUBLW  40
1100:  BC    110E
1102:  MOVF   x87,W
1104:  SUBLW  5A
1106:  BNC   110E
1108:  MOVF   x87,W
110A:  IORLW  20
110C:  BRA    1110
110E:  MOVF   x87,W
1110:  MOVWF  FEF
....................          j += 1; 
1112:  MOVLW  01
1114:  ADDWF  x89,F
....................       } 
1116:  MOVLW  01
1118:  ADDWF  x88,F
111A:  BRA    10A0
....................        
....................    }    
....................  
....................    // tack on a null terminator 
....................    sname[j] = '\0'; 
111C:  MOVF   x89,W
111E:  ADDWF  x84,W
1120:  MOVWF  FE9
1122:  MOVLW  00
1124:  ADDWFC x85,W
1126:  MOVWF  FEA
1128:  CLRF   FEF
....................     
....................    //printf("\r\n%s, %u\r\n",sname, strlen(sname)); 
....................  
....................    if(type != 0x10 && strlen(sname) > 3) 
112A:  MOVF   x86,W
112C:  SUBLW  10
112E:  BZ    11B8
1130:  MOVFF  585,5AE
1134:  MOVFF  584,5AD
1138:  MOVLB  0
113A:  RCALL  105E
113C:  MOVFF  02,58B
1140:  MOVFF  01,58A
1144:  MOVLB  5
1146:  MOVF   x8B,F
1148:  BNZ   1150
114A:  MOVF   x8A,W
114C:  SUBLW  03
114E:  BC    11B8
....................    { 
....................       j = strlen(sname); 
1150:  MOVFF  585,5AE
1154:  MOVFF  584,5AD
1158:  MOVLB  0
115A:  RCALL  105E
115C:  MOVFF  01,589
....................       for(i=j; i > j-3; --i) 
1160:  MOVFF  589,588
1164:  MOVLW  03
1166:  MOVLB  5
1168:  SUBWF  x89,W
116A:  SUBWF  x88,W
116C:  BZ    11A8
116E:  BNC   11A8
....................          sname[i] = sname[i-1]; 
1170:  MOVF   x88,W
1172:  ADDWF  x84,W
1174:  MOVWF  01
1176:  MOVLW  00
1178:  ADDWFC x85,W
117A:  MOVWF  03
117C:  MOVFF  01,58A
1180:  MOVWF  x8B
1182:  MOVLW  01
1184:  SUBWF  x88,W
1186:  ADDWF  x84,W
1188:  MOVWF  FE9
118A:  MOVLW  00
118C:  ADDWFC x85,W
118E:  MOVWF  FEA
1190:  MOVFF  FEF,58C
1194:  MOVFF  03,FEA
1198:  MOVFF  01,FE9
119C:  MOVFF  58C,FEF
11A0:  DECF   x88,F
11A2:  MOVLB  0
11A4:  BRA    1164
11A6:  MOVLB  5
....................       sname[i] = '.'; 
11A8:  MOVF   x88,W
11AA:  ADDWF  x84,W
11AC:  MOVWF  FE9
11AE:  MOVLW  00
11B0:  ADDWFC x85,W
11B2:  MOVWF  FEA
11B4:  MOVLW  2E
11B6:  MOVWF  FEF
....................    } 
....................     
....................    sname[j+1] = '\0'; 
11B8:  MOVLW  01
11BA:  ADDWF  x89,W
11BC:  ADDWF  x84,W
11BE:  MOVWF  FE9
11C0:  MOVLW  00
11C2:  ADDWFC x85,W
11C4:  MOVWF  FEA
11C6:  CLRF   FEF
....................  
....................    return GOODEC; 
11C8:  MOVLW  00
11CA:  MOVWF  01
11CC:  MOVLB  0
11CE:  GOTO   16B2 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... { 
....................    char 
....................       val[12] = "           ", 
....................       cur_fname[12] = "           ", 
....................       cur_fnum[7] = "      "; 
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
....................          val_parse_pos += 1; 
....................          fname_parse_pos += 1; 
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       ext_pos -= fname - 1; 
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
....................          val_parse_pos += 1; 
....................          fname_parse_pos += 1; 
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
....................             fname_parse_pos += 1; 
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
....................             val_parse_pos = 8; 
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
....................             fname_parse_pos = ext_pos; 
....................       } 
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
....................       return EOF; 
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
....................    { 
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
....................             return EOF; 
....................  
....................          cur_fname[11] = '\0'; 
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%lu", fnum); 
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
....................             if(val_parse_pos == 0) 
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
....................             else 
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
....................             while(fnum >= buf) 
....................             { 
....................                val_parse_pos -= 1; 
....................                buf *= 10; 
....................             } 
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
....................             while(cur_fnum[fname_parse_pos] != '\0') 
....................             { 
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
....................                val_parse_pos += 1; 
....................                fname_parse_pos += 1; 
....................             } 
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
....................             return EOF;          
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
....................          return EOF; 
....................    } 
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
....................       sname[i] = val[i]; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
.................... { 
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
....................  
....................    return Sum; 
.................... } 
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
....................          return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
*
1B0C:  MOVLB  5
1B0E:  MOVFF  597,FE9
1B12:  MOVFF  598,FEA
1B16:  MOVFF  FEF,5A9
1B1A:  MOVFF  FEC,5AA
1B1E:  MOVFF  FEC,5AB
1B22:  MOVFF  FEC,5AC
1B26:  RLCF   xA9,F
1B28:  RLCF   xAA,F
1B2A:  RLCF   xAB,F
1B2C:  RLCF   xAC,F
1B2E:  RLCF   xA9,F
1B30:  RLCF   xAA,F
1B32:  RLCF   xAB,F
1B34:  RLCF   xAC,F
1B36:  MOVLW  FC
1B38:  ANDWF  xA9,F
1B3A:  MOVLB  2
1B3C:  MOVF   x27,W
1B3E:  MOVLB  5
1B40:  ADDWF  xA9,W
1B42:  MOVWF  xA1
1B44:  MOVLB  2
1B46:  MOVF   x28,W
1B48:  MOVLB  5
1B4A:  ADDWFC xAA,W
1B4C:  MOVWF  xA2
1B4E:  MOVLW  00
1B50:  ADDWFC xAB,W
1B52:  MOVWF  xA3
1B54:  MOVLW  00
1B56:  ADDWFC xAC,W
1B58:  MOVWF  xA4
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
1B5A:  CLRF   xA8
1B5C:  CLRF   xA7
1B5E:  CLRF   xA6
1B60:  CLRF   xA5
1B62:  MOVF   xA8,W
1B64:  MOVLB  2
1B66:  SUBWF  x30,W
1B68:  BTFSS  FD8.0
1B6A:  BRA    1C80
1B6C:  BNZ   1B9A
1B6E:  MOVLB  5
1B70:  MOVF   xA7,W
1B72:  MOVLB  2
1B74:  SUBWF  x2F,W
1B76:  BTFSS  FD8.0
1B78:  BRA    1C80
1B7A:  BNZ   1B9A
1B7C:  MOVLB  5
1B7E:  MOVF   xA6,W
1B80:  MOVLB  2
1B82:  SUBWF  x2E,W
1B84:  BTFSS  FD8.0
1B86:  BRA    1C80
1B88:  BNZ   1B9A
1B8A:  MOVF   x2D,W
1B8C:  MOVLB  5
1B8E:  SUBWF  xA5,W
1B90:  BTFSS  FD8.0
1B92:  BRA    1B98
1B94:  MOVLB  2
1B96:  BRA    1C80
1B98:  MOVLB  2
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
1B9A:  MOVLB  5
1B9C:  MOVF   xA5,W
1B9E:  ADDWF  xA1,W
1BA0:  MOVWF  xA9
1BA2:  MOVF   xA6,W
1BA4:  ADDWFC xA2,W
1BA6:  MOVWF  xAA
1BA8:  MOVF   xA7,W
1BAA:  ADDWFC xA3,W
1BAC:  MOVWF  xAB
1BAE:  MOVF   xA8,W
1BB0:  ADDWFC xA4,W
1BB2:  MOVWF  xAC
1BB4:  MOVWF  xC2
1BB6:  MOVFF  5AB,5C1
1BBA:  MOVFF  5AA,5C0
1BBE:  MOVFF  5A9,5BF
1BC2:  CLRF   xC4
1BC4:  MOVLW  04
1BC6:  MOVWF  xC3
1BC8:  MOVLW  05
1BCA:  MOVWF  xC6
1BCC:  MOVLW  99
1BCE:  MOVWF  xC5
1BD0:  MOVLB  0
1BD2:  CALL   0CAA
1BD6:  MOVF   01,F
1BD8:  BZ    1BE0
....................          return EOF; 
1BDA:  MOVLW  FF
1BDC:  MOVWF  01
1BDE:  BRA    1C86
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
1BE0:  MOVFF  59C,5A0
1BE4:  MOVFF  59B,59F
1BE8:  MOVFF  59A,59E
1BEC:  MOVFF  599,59D
....................  
....................       if(cur_cluster == 0) 
1BF0:  MOVLB  5
1BF2:  MOVF   x9D,F
1BF4:  BNZ   1C70
1BF6:  MOVF   x9E,F
1BF8:  BNZ   1C70
1BFA:  MOVF   x9F,F
1BFC:  BNZ   1C70
1BFE:  MOVF   xA0,F
1C00:  BNZ   1C70
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
1C02:  MOVF   xA5,W
1C04:  ADDWF  xA1,F
1C06:  MOVF   xA6,W
1C08:  ADDWFC xA2,F
1C0A:  MOVF   xA7,W
1C0C:  ADDWFC xA3,F
1C0E:  MOVF   xA8,W
1C10:  ADDWFC xA4,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
1C12:  MOVFF  597,FE9
1C16:  MOVFF  598,FEA
1C1A:  MOVLB  2
1C1C:  MOVF   x27,W
1C1E:  MOVLB  5
1C20:  SUBWF  xA1,W
1C22:  MOVWF  xAB
1C24:  MOVLB  2
1C26:  MOVF   x28,W
1C28:  MOVLB  5
1C2A:  SUBWFB xA2,W
1C2C:  MOVWF  xAC
1C2E:  MOVLW  00
1C30:  SUBWFB xA3,W
1C32:  MOVWF  xAD
1C34:  MOVLW  00
1C36:  SUBWFB xA4,W
1C38:  MOVWF  xAE
1C3A:  RRCF   xAE,W
1C3C:  MOVWF  03
1C3E:  RRCF   xAD,W
1C40:  MOVWF  02
1C42:  RRCF   xAC,W
1C44:  MOVWF  01
1C46:  RRCF   xAB,W
1C48:  MOVWF  00
1C4A:  RRCF   03,F
1C4C:  RRCF   02,F
1C4E:  RRCF   01,F
1C50:  RRCF   00,F
1C52:  MOVLW  3F
1C54:  ANDWF  03,F
1C56:  MOVFF  00,FEF
1C5A:  MOVFF  01,FEC
1C5E:  MOVFF  02,FEC
1C62:  MOVFF  03,FEC
....................          return GOODEC; 
1C66:  MOVLW  00
1C68:  MOVWF  01
1C6A:  MOVLB  0
1C6C:  BRA    1C86
1C6E:  MOVLB  5
....................       } 
1C70:  MOVLW  04
1C72:  ADDWF  xA5,F
1C74:  MOVLW  00
1C76:  ADDWFC xA6,F
1C78:  ADDWFC xA7,F
1C7A:  ADDWFC xA8,F
1C7C:  BRA    1B62
1C7E:  MOVLB  2
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make16(val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
....................          return GOODEC; 
....................       } 
....................    } 
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
1C80:  MOVLW  FF
1C82:  MOVWF  01
1C84:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
1C86:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
27F2:  MOVLB  5
27F4:  MOVFF  572,FE9
27F8:  MOVFF  573,FEA
27FC:  MOVFF  FEF,574
2800:  MOVFF  FEC,575
2804:  MOVFF  FEC,576
2808:  MOVFF  FEC,577
....................     
....................    i += 0x1F; 
280C:  MOVLW  1F
280E:  ADDWF  x74,F
2810:  MOVLW  00
2812:  ADDWFC x75,F
2814:  ADDWFC x76,F
2816:  ADDWFC x77,F
....................     
....................    if(get_next_addr(&i) == EOF) 
2818:  MOVLW  05
281A:  MOVWF  xB3
281C:  MOVLW  74
281E:  MOVWF  xB2
2820:  MOVLB  0
2822:  CALL   1E9E
2826:  MOVF   01,W
2828:  SUBLW  FF
282A:  BNZ   2832
....................       return EOF; 
282C:  MOVLW  FF
282E:  MOVWF  01
2830:  BRA    2850
....................     
....................    *start_addr = i; 
2832:  MOVLB  5
2834:  MOVFF  572,FE9
2838:  MOVFF  573,FEA
283C:  MOVFF  574,FEF
2840:  MOVFF  575,FEC
2844:  MOVFF  576,FEC
2848:  MOVFF  577,FEC
....................     
....................    return GOODEC; 
284C:  MOVLW  00
284E:  MOVWF  01
2850:  MOVLB  0
2852:  GOTO   2EF4 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
15D0:  MOVLB  5
15D2:  MOVFF  580,FE9
15D6:  MOVFF  581,FEA
15DA:  MOVFF  FEF,582
15DE:  MOVFF  FEC,583
15E2:  MOVFF  FEC,584
15E6:  MOVFF  FEC,585
....................  
....................    i -= 0x1F; 
15EA:  MOVLW  1F
15EC:  SUBWF  x82,F
15EE:  MOVLW  00
15F0:  SUBWFB x83,F
15F2:  SUBWFB x84,F
15F4:  SUBWFB x85,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
15F6:  MOVLW  05
15F8:  MOVWF  x87
15FA:  MOVLW  82
15FC:  MOVWF  x86
15FE:  MOVLB  0
1600:  BRA    140C
1602:  MOVF   01,W
1604:  SUBLW  FF
1606:  BNZ   160E
....................       return EOF; 
1608:  MOVLW  FF
160A:  MOVWF  01
160C:  BRA    162C
....................  
....................    *start_addr = i; 
160E:  MOVLB  5
1610:  MOVFF  580,FE9
1614:  MOVFF  581,FEA
1618:  MOVFF  582,FEF
161C:  MOVFF  583,FEC
1620:  MOVFF  584,FEC
1624:  MOVFF  585,FEC
....................     
....................    return GOODEC; 
1628:  MOVLW  00
162A:  MOVWF  01
162C:  MOVLB  0
162E:  GOTO   16D2 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
....................      return EOF; 
....................  
....................    while(buf != 0) 
....................    { 
....................       i += 0x1F; 
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
....................             return EOF; 
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
....................         return EOF; 
....................    } 
....................  
....................    *start_addr = i; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
202C:  MOVFF  58C,592
2030:  MOVFF  58B,591
2034:  MOVFF  58A,590
2038:  MOVFF  589,58F
203C:  MOVFF  592,596
2040:  MOVFF  591,595
2044:  MOVFF  590,594
2048:  MOVFF  58F,593
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
204C:  MOVLW  05
204E:  MOVLB  5
2050:  MOVWF  x98
2052:  MOVLW  93
2054:  MOVWF  x97
2056:  MOVLB  0
2058:  RCALL  1B0C
205A:  MOVF   01,W
205C:  SUBLW  FF
205E:  BNZ   2066
....................       return EOF; 
2060:  MOVLW  FF
2062:  MOVWF  01
2064:  BRA    211C
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
2066:  MOVFF  592,59A
206A:  MOVFF  591,599
206E:  MOVFF  590,598
2072:  MOVFF  58F,597
2076:  MOVFF  596,59E
207A:  MOVFF  595,59D
207E:  MOVFF  594,59C
2082:  MOVFF  593,59B
2086:  RCALL  197A
2088:  MOVF   01,W
208A:  SUBLW  FF
208C:  BNZ   2094
....................       return EOF; 
208E:  MOVLW  FF
2090:  MOVWF  01
2092:  BRA    211C
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
2094:  MOVFF  596,59A
2098:  MOVFF  595,599
209C:  MOVFF  594,598
20A0:  MOVFF  593,597
20A4:  MOVLW  0F
20A6:  MOVLB  5
20A8:  MOVWF  x9E
20AA:  SETF   x9D
20AC:  SETF   x9C
20AE:  SETF   x9B
20B0:  MOVLB  0
20B2:  RCALL  197A
20B4:  MOVF   01,W
20B6:  SUBLW  FF
20B8:  BNZ   20C0
....................       return EOF; 
20BA:  MOVLW  FF
20BC:  MOVWF  01
20BE:  BRA    211C
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
20C0:  MOVFF  596,59A
20C4:  MOVFF  595,599
20C8:  MOVFF  594,598
20CC:  MOVFF  593,597
20D0:  RCALL  1C88
20D2:  MOVF   01,W
20D4:  SUBLW  FF
20D6:  BNZ   20DE
....................       return EOF; 
20D8:  MOVLW  FF
20DA:  MOVWF  01
20DC:  BRA    211C
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
20DE:  MOVFF  58E,03
20E2:  MOVFF  58D,597
20E6:  MOVFF  58E,598
20EA:  MOVFF  596,5C5
20EE:  MOVFF  595,5C4
20F2:  MOVFF  594,5C3
20F6:  MOVFF  593,5C2
20FA:  MOVLB  0
20FC:  CALL   13B0
2100:  MOVFF  598,FEA
2104:  MOVFF  597,FE9
2108:  MOVFF  00,FEF
210C:  MOVFF  01,FEC
2110:  MOVFF  02,FEC
2114:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
2118:  MOVLW  00
211A:  MOVWF  01
211C:  GOTO   23A4 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
19E0:  MOVFF  579,57D
19E4:  MOVFF  578,57C
19E8:  MOVFF  577,57B
19EC:  MOVFF  576,57A
19F0:  MOVFF  57D,581
19F4:  MOVFF  57C,580
19F8:  MOVFF  57B,57F
19FC:  MOVFF  57A,57E
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
1A00:  MOVLW  05
1A02:  MOVLB  5
1A04:  MOVWF  xB9
1A06:  MOVLW  7E
1A08:  MOVWF  xB8
1A0A:  MOVLB  0
1A0C:  RCALL  182A
1A0E:  MOVF   01,W
1A10:  SUBLW  FF
1A12:  BNZ   1A1A
....................          return EOF; 
1A14:  MOVLW  FF
1A16:  MOVWF  01
1A18:  BRA    1A84
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
1A1A:  MOVFF  57D,59A
1A1E:  MOVFF  57C,599
1A22:  MOVFF  57B,598
1A26:  MOVFF  57A,597
1A2A:  MOVLB  5
1A2C:  CLRF   x9E
1A2E:  CLRF   x9D
1A30:  CLRF   x9C
1A32:  CLRF   x9B
1A34:  MOVLB  0
1A36:  RCALL  197A
1A38:  MOVF   01,W
1A3A:  SUBLW  FF
1A3C:  BNZ   1A44
....................          return EOF; 
1A3E:  MOVLW  FF
1A40:  MOVWF  01
1A42:  BRA    1A84
....................  
....................       cur_cluster = next_cluster; 
1A44:  MOVFF  581,57D
1A48:  MOVFF  580,57C
1A4C:  MOVFF  57F,57B
1A50:  MOVFF  57E,57A
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
1A54:  MOVLB  5
1A56:  INCFSZ x7A,W
1A58:  BRA    1A5C
1A5A:  BRA    1A60
1A5C:  MOVLB  0
1A5E:  BRA    1A00
1A60:  INCFSZ x7B,W
1A62:  BRA    1A66
1A64:  BRA    1A6A
1A66:  MOVLB  0
1A68:  BRA    1A00
1A6A:  INCFSZ x7C,W
1A6C:  BRA    1A70
1A6E:  BRA    1A74
1A70:  MOVLB  0
1A72:  BRA    1A00
1A74:  MOVF   x7D,W
1A76:  SUBLW  0F
1A78:  BTFSC  FD8.2
1A7A:  BRA    1A80
1A7C:  MOVLB  0
1A7E:  BRA    1A00
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
1A80:  MOVLW  00
1A82:  MOVWF  01
1A84:  MOVLB  0
1A86:  GOTO   2C4C (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
1C88:  MOVFF  59A,5C5
1C8C:  MOVFF  599,5C4
1C90:  MOVFF  598,5C3
1C94:  MOVFF  597,5C2
1C98:  CALL   13B0
1C9C:  MOVFF  03,5C1
1CA0:  MOVFF  02,5C0
1CA4:  MOVFF  01,5BF
1CA8:  MOVFF  00,5BE
....................     
....................    for(j = 0; j < 0x20; j += 1) 
1CAC:  MOVLB  5
1CAE:  CLRF   xBB
1CB0:  MOVF   xBB,W
1CB2:  SUBLW  1F
1CB4:  BNC   1CCC
....................       clear_entry[j] = 0; 
1CB6:  CLRF   03
1CB8:  MOVF   xBB,W
1CBA:  ADDLW  9B
1CBC:  MOVWF  FE9
1CBE:  MOVLW  05
1CC0:  ADDWFC 03,W
1CC2:  MOVWF  FEA
1CC4:  CLRF   FEF
1CC6:  MOVLW  01
1CC8:  ADDWF  xBB,F
1CCA:  BRA    1CB0
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
1CCC:  CLRF   xBD
1CCE:  CLRF   xBC
1CD0:  MOVF   xBD,W
1CD2:  MOVLB  2
1CD4:  SUBWF  x26,W
1CD6:  BNC   1D3C
1CD8:  BNZ   1CEA
1CDA:  MOVF   x25,W
1CDC:  MOVLB  5
1CDE:  SUBWF  xBC,W
1CE0:  BTFSS  FD8.0
1CE2:  BRA    1CE8
1CE4:  MOVLB  2
1CE6:  BRA    1D3C
1CE8:  MOVLB  2
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
1CEA:  MOVLB  5
1CEC:  MOVF   xBC,W
1CEE:  ADDWF  xBE,W
1CF0:  MOVWF  xC2
1CF2:  MOVF   xBD,W
1CF4:  ADDWFC xBF,W
1CF6:  MOVWF  xC3
1CF8:  MOVLW  00
1CFA:  ADDWFC xC0,W
1CFC:  MOVWF  xC4
1CFE:  MOVLW  00
1D00:  ADDWFC xC1,W
1D02:  MOVWF  xC5
1D04:  MOVWF  xC9
1D06:  MOVFF  5C4,5C8
1D0A:  MOVFF  5C3,5C7
1D0E:  MOVFF  5C2,5C6
1D12:  CLRF   xCB
1D14:  MOVLW  20
1D16:  MOVWF  xCA
1D18:  MOVLW  05
1D1A:  MOVWF  xCD
1D1C:  MOVLW  9B
1D1E:  MOVWF  xCC
1D20:  MOVLB  0
1D22:  RCALL  18F4
1D24:  MOVF   01,F
1D26:  BZ    1D2E
....................          return EOF; 
1D28:  MOVLW  FF
1D2A:  MOVWF  01
1D2C:  BRA    1D42
1D2E:  MOVLW  20
1D30:  MOVLB  5
1D32:  ADDWF  xBC,F
1D34:  MOVLW  00
1D36:  ADDWFC xBD,F
1D38:  BRA    1CD0
1D3A:  MOVLB  2
....................  
....................    return GOODEC; 
1D3C:  MOVLW  00
1D3E:  MOVWF  01
1D40:  MOVLB  0
1D42:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
*
197A:  MOVLB  5
197C:  RLCF   x97,W
197E:  MOVWF  xA0
1980:  RLCF   x98,W
1982:  MOVWF  xA1
1984:  RLCF   x99,W
1986:  MOVWF  xA2
1988:  RLCF   x9A,W
198A:  MOVWF  xA3
198C:  RLCF   xA0,F
198E:  RLCF   xA1,F
1990:  RLCF   xA2,F
1992:  RLCF   xA3,F
1994:  MOVLW  FC
1996:  ANDWF  xA0,F
1998:  MOVLB  2
199A:  MOVF   x27,W
199C:  MOVLB  5
199E:  ADDWF  xA0,F
19A0:  MOVLB  2
19A2:  MOVF   x28,W
19A4:  MOVLB  5
19A6:  ADDWFC xA1,F
19A8:  MOVLW  00
19AA:  ADDWFC xA2,F
19AC:  ADDWFC xA3,F
19AE:  MOVFF  5A3,5C9
19B2:  MOVFF  5A2,5C8
19B6:  MOVFF  5A1,5C7
19BA:  MOVFF  5A0,5C6
19BE:  CLRF   xCB
19C0:  MOVLW  04
19C2:  MOVWF  xCA
19C4:  MOVLW  05
19C6:  MOVWF  xCD
19C8:  MOVLW  9B
19CA:  MOVWF  xCC
19CC:  MOVLB  0
19CE:  RCALL  18F4
19D0:  MOVF   01,F
19D2:  BZ    19DA
....................       return EOF; 
19D4:  MOVLW  FF
19D6:  MOVWF  01
19D8:  BRA    19DE
....................  
....................    return GOODEC; 
19DA:  MOVLW  00
19DC:  MOVWF  01
19DE:  RETURN 0
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
*
31CE:  MOVLW  04
31D0:  MOVLB  5
31D2:  ADDWF  xB0,W
31D4:  MOVWF  FE9
31D6:  MOVLW  00
31D8:  ADDWFC xB1,W
31DA:  MOVWF  FEA
31DC:  MOVFF  FEF,5B5
31E0:  MOVFF  FEC,5B6
31E4:  MOVFF  FEC,5B7
31E8:  MOVFF  FEC,5B8
31EC:  MOVLW  1F
31EE:  ANDWF  xB5,F
31F0:  CLRF   xB6
31F2:  CLRF   xB7
31F4:  CLRF   xB8
31F6:  MOVF   xB5,F
31F8:  BNZ   3266
31FA:  MOVF   xB6,F
31FC:  BNZ   3266
31FE:  MOVF   xB7,F
3200:  BNZ   3266
3202:  MOVF   xB8,F
3204:  BNZ   3266
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
3206:  MOVLW  04
3208:  ADDWF  xB0,W
320A:  MOVWF  FE9
320C:  MOVLW  00
320E:  ADDWFC xB1,W
3210:  MOVWF  FEA
3212:  MOVFF  FEF,5BF
3216:  MOVFF  FEC,5C0
321A:  MOVFF  FEC,5C1
321E:  MOVFF  FEC,5C2
3222:  MOVLW  1A
3224:  ADDWF  xB0,W
3226:  MOVWF  01
3228:  MOVLW  00
322A:  ADDWFC xB1,W
322C:  MOVWF  03
322E:  MOVFF  01,5B9
3232:  MOVWF  xBA
3234:  CLRF   xC4
3236:  MOVLW  20
3238:  MOVWF  xC3
323A:  MOVFF  03,5C6
323E:  MOVFF  01,5C5
3242:  MOVLB  0
3244:  CALL   0CAA
3248:  MOVF   01,F
324A:  BZ    3268
....................       { 
....................          stream->Flags |= Read_Error; 
324C:  MOVLW  19
324E:  MOVLB  5
3250:  ADDWF  xB0,W
3252:  MOVWF  FE9
3254:  MOVLW  00
3256:  ADDWFC xB1,W
3258:  MOVWF  FEA
325A:  MOVF   FEF,W
325C:  IORLW  20
325E:  MOVWF  FEF
....................          return EOF; 
3260:  MOVLW  FF
3262:  MOVWF  01
3264:  BRA    32CA
3266:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
3268:  MOVLB  5
326A:  MOVLW  1A
326C:  ADDWF  xB0,W
326E:  MOVWF  FE9
3270:  MOVLW  00
3272:  ADDWFC xB1,W
3274:  MOVWF  FEA
3276:  MOVFF  FEF,5B7
327A:  MOVFF  5B3,FEA
327E:  MOVFF  5B2,FE9
3282:  MOVFF  5B7,FEF
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
3286:  CLRF   xB4
3288:  MOVF   xB4,W
328A:  SUBLW  07
328C:  BNC   32C6
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
328E:  MOVLW  1A
3290:  ADDWF  xB0,W
3292:  MOVWF  01
3294:  MOVLW  00
3296:  ADDWFC xB1,W
3298:  MOVWF  03
329A:  MOVFF  01,5B5
329E:  MOVWF  xB6
32A0:  MOVLW  20
32A2:  MOVWF  00
32A4:  MOVFF  03,FEA
32A8:  MOVFF  01,FE9
32AC:  MOVFF  FEF,03
32B0:  MOVLW  1F
32B2:  ADDWF  FE9,F
32B4:  MOVLW  00
32B6:  ADDWFC FEA,F
32B8:  RRCF   03,W
32BA:  RRCF   FED,F
32BC:  DECFSZ 00,F
32BE:  BRA    32BA
32C0:  MOVLW  01
32C2:  ADDWF  xB4,F
32C4:  BRA    3288
....................  
....................    return GOODEC; 
32C6:  MOVLW  00
32C8:  MOVWF  01
32CA:  MOVLB  0
32CC:  GOTO   3336 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
1D44:  MOVLW  04
1D46:  MOVLB  5
1D48:  ADDWF  x83,W
1D4A:  MOVWF  FE9
1D4C:  MOVLW  00
1D4E:  ADDWFC x84,W
1D50:  MOVWF  FEA
1D52:  MOVFF  FEF,586
1D56:  MOVFF  FEC,587
1D5A:  MOVFF  FEC,588
1D5E:  MOVFF  FEC,589
1D62:  MOVLW  1F
1D64:  ANDWF  x86,F
1D66:  CLRF   x87
1D68:  CLRF   x88
1D6A:  CLRF   x89
1D6C:  MOVF   x86,F
1D6E:  BNZ   1E46
1D70:  MOVF   x87,F
1D72:  BNZ   1E46
1D74:  MOVF   x88,F
1D76:  BNZ   1E46
1D78:  MOVF   x89,F
1D7A:  BNZ   1E46
1D7C:  MOVLW  04
1D7E:  ADDWF  x83,W
1D80:  MOVWF  FE9
1D82:  MOVLW  00
1D84:  ADDWFC x84,W
1D86:  MOVWF  FEA
1D88:  MOVFF  FEF,586
1D8C:  MOVFF  FEC,587
1D90:  MOVFF  FEC,588
1D94:  MOVFF  FEC,589
1D98:  MOVLW  14
1D9A:  ADDWF  x83,W
1D9C:  MOVWF  FE9
1D9E:  MOVLW  00
1DA0:  ADDWFC x84,W
1DA2:  MOVWF  FEA
1DA4:  MOVFF  FEF,00
1DA8:  MOVFF  FEC,01
1DAC:  MOVFF  FEC,02
1DB0:  MOVFF  FEC,03
1DB4:  MOVF   00,W
1DB6:  SUBWF  x86,W
1DB8:  BNZ   1DCC
1DBA:  MOVF   01,W
1DBC:  SUBWF  x87,W
1DBE:  BNZ   1DCC
1DC0:  MOVF   02,W
1DC2:  SUBWF  x88,W
1DC4:  BNZ   1DCC
1DC6:  MOVF   03,W
1DC8:  SUBWF  x89,W
1DCA:  BZ    1E46
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
1DCC:  MOVLW  04
1DCE:  ADDWF  x83,W
1DD0:  MOVWF  FE9
1DD2:  MOVLW  00
1DD4:  ADDWFC x84,W
1DD6:  MOVWF  FEA
1DD8:  MOVFF  FEF,586
1DDC:  MOVFF  FEC,587
1DE0:  MOVFF  FEC,588
1DE4:  MOVFF  FEC,589
1DE8:  MOVLW  20
1DEA:  SUBWF  x86,F
1DEC:  MOVLW  00
1DEE:  SUBWFB x87,F
1DF0:  SUBWFB x88,F
1DF2:  SUBWFB x89,F
1DF4:  MOVLW  1A
1DF6:  ADDWF  x83,W
1DF8:  MOVWF  01
1DFA:  MOVLW  00
1DFC:  ADDWFC x84,W
1DFE:  MOVWF  03
1E00:  MOVFF  01,58A
1E04:  MOVWF  x8B
1E06:  MOVFF  589,5C9
1E0A:  MOVFF  588,5C8
1E0E:  MOVFF  587,5C7
1E12:  MOVFF  586,5C6
1E16:  CLRF   xCB
1E18:  MOVLW  20
1E1A:  MOVWF  xCA
1E1C:  MOVFF  03,5CD
1E20:  MOVFF  01,5CC
1E24:  MOVLB  0
1E26:  RCALL  18F4
1E28:  MOVF   01,F
1E2A:  BZ    1E48
....................       { 
....................          stream->Flags |= Write_Error; 
1E2C:  MOVLW  19
1E2E:  MOVLB  5
1E30:  ADDWF  x83,W
1E32:  MOVWF  FE9
1E34:  MOVLW  00
1E36:  ADDWFC x84,W
1E38:  MOVWF  FEA
1E3A:  MOVF   FEF,W
1E3C:  IORLW  40
1E3E:  MOVWF  FEF
....................          return EOF; 
1E40:  MOVLW  FF
1E42:  MOVWF  01
1E44:  BRA    1E98
1E46:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
1E48:  MOVLW  04
1E4A:  MOVLB  5
1E4C:  ADDWF  x83,W
1E4E:  MOVWF  FE9
1E50:  MOVLW  00
1E52:  ADDWFC x84,W
1E54:  MOVWF  FEA
1E56:  MOVFF  FEF,586
1E5A:  MOVFF  FEC,587
1E5E:  MOVFF  FEC,588
1E62:  MOVFF  FEC,589
1E66:  MOVLW  1F
1E68:  ANDWF  x86,F
1E6A:  CLRF   x87
1E6C:  CLRF   x88
1E6E:  CLRF   x89
1E70:  MOVLW  1A
1E72:  ADDWF  x86,W
1E74:  MOVWF  00
1E76:  MOVLW  00
1E78:  ADDWFC x87,W
1E7A:  MOVWF  01
1E7C:  MOVLW  00
1E7E:  ADDWFC x88,W
1E80:  MOVLW  00
1E82:  ADDWFC x89,W
1E84:  MOVF   x83,W
1E86:  ADDWF  00,W
1E88:  MOVWF  FE9
1E8A:  MOVF   x84,W
1E8C:  ADDWFC 01,W
1E8E:  MOVWF  FEA
1E90:  MOVFF  585,FEF
....................  
....................    return GOODEC; 
1E94:  MOVLW  00
1E96:  MOVWF  01
1E98:  MOVLB  0
1E9A:  GOTO   228C (RETURN)
.................... } 
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
....................    { 
....................       if(i < 5) 
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
....................          the_entry[(i << 1) + 2] = val; 
....................       } 
....................  
....................       else if(i < 11) 
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
....................          the_entry[(i << 1) + 5] = val; 
....................       } 
....................  
....................       else 
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
....................          the_entry[(i << 1) + 7] = val; 
....................       } 
....................    } 
.................... } 
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
*
0DB0:  MOVLB  4
0DB2:  CLRF   xA3
.................... { 
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    ec += mmcsd_init(); 
0DB4:  MOVLB  0
0DB6:  BRA    0970
0DB8:  MOVF   01,W
0DBA:  MOVLB  4
0DBC:  ADDWF  xA3,F
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(11, 2, &Bytes_Per_Sector); 
0DBE:  MOVLB  5
0DC0:  CLRF   xC2
0DC2:  CLRF   xC1
0DC4:  CLRF   xC0
0DC6:  MOVLW  0B
0DC8:  MOVWF  xBF
0DCA:  CLRF   xC4
0DCC:  MOVLW  02
0DCE:  MOVWF  xC3
0DD0:  MOVLW  04
0DD2:  MOVWF  xC6
0DD4:  MOVLW  A6
0DD6:  MOVWF  xC5
0DD8:  MOVLB  0
0DDA:  RCALL  0CAA
0DDC:  MOVF   01,W
0DDE:  MOVLB  4
0DE0:  ADDWF  xA3,F
....................    ec += mmcsd_read_data(13, 1, &Sectors_Per_Cluster); 
0DE2:  MOVLB  5
0DE4:  CLRF   xC2
0DE6:  CLRF   xC1
0DE8:  CLRF   xC0
0DEA:  MOVLW  0D
0DEC:  MOVWF  xBF
0DEE:  CLRF   xC4
0DF0:  MOVLW  01
0DF2:  MOVWF  xC3
0DF4:  MOVLW  04
0DF6:  MOVWF  xC6
0DF8:  MOVLW  A5
0DFA:  MOVWF  xC5
0DFC:  MOVLB  0
0DFE:  RCALL  0CAA
0E00:  MOVF   01,W
0E02:  MOVLB  4
0E04:  ADDWF  xA3,F
....................    ec += mmcsd_read_data(14, 2, &Reserved_Sectors); 
0E06:  MOVLB  5
0E08:  CLRF   xC2
0E0A:  CLRF   xC1
0E0C:  CLRF   xC0
0E0E:  MOVLW  0E
0E10:  MOVWF  xBF
0E12:  CLRF   xC4
0E14:  MOVLW  02
0E16:  MOVWF  xC3
0E18:  MOVLW  04
0E1A:  MOVWF  xC6
0E1C:  MOVLW  A8
0E1E:  MOVWF  xC5
0E20:  MOVLB  0
0E22:  RCALL  0CAA
0E24:  MOVF   01,W
0E26:  MOVLB  4
0E28:  ADDWF  xA3,F
....................    ec += mmcsd_read_data(16, 1, &FATs); 
0E2A:  MOVLB  5
0E2C:  CLRF   xC2
0E2E:  CLRF   xC1
0E30:  CLRF   xC0
0E32:  MOVLW  10
0E34:  MOVWF  xBF
0E36:  CLRF   xC4
0E38:  MOVLW  01
0E3A:  MOVWF  xC3
0E3C:  MOVLW  04
0E3E:  MOVWF  xC6
0E40:  MOVLW  A4
0E42:  MOVWF  xC5
0E44:  MOVLB  0
0E46:  RCALL  0CAA
0E48:  MOVF   01,W
0E4A:  MOVLB  4
0E4C:  ADDWF  xA3,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(17, 2, &Root_Entries); 
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(19, 2, &Small_Sectors); 
0E4E:  MOVLB  5
0E50:  CLRF   xC2
0E52:  CLRF   xC1
0E54:  CLRF   xC0
0E56:  MOVLW  13
0E58:  MOVWF  xBF
0E5A:  CLRF   xC4
0E5C:  MOVLW  02
0E5E:  MOVWF  xC3
0E60:  MOVLW  04
0E62:  MOVWF  xC6
0E64:  MOVLW  AA
0E66:  MOVWF  xC5
0E68:  MOVLB  0
0E6A:  RCALL  0CAA
0E6C:  MOVF   01,W
0E6E:  MOVLB  4
0E70:  ADDWF  xA3,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(36, 4, &Sectors_Per_FAT); 
0E72:  MOVLB  5
0E74:  CLRF   xC2
0E76:  CLRF   xC1
0E78:  CLRF   xC0
0E7A:  MOVLW  24
0E7C:  MOVWF  xBF
0E7E:  CLRF   xC4
0E80:  MOVLW  04
0E82:  MOVWF  xC3
0E84:  MOVWF  xC6
0E86:  MOVLW  B4
0E88:  MOVWF  xC5
0E8A:  MOVLB  0
0E8C:  RCALL  0CAA
0E8E:  MOVF   01,W
0E90:  MOVLB  4
0E92:  ADDWF  xA3,F
.................... #else // FAT16 
....................    ec += mmcsd_read_data(22, 2, &Sectors_Per_FAT); 
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(28, 4, &Hidden_Sectors); 
0E94:  MOVLB  5
0E96:  CLRF   xC2
0E98:  CLRF   xC1
0E9A:  CLRF   xC0
0E9C:  MOVLW  1C
0E9E:  MOVWF  xBF
0EA0:  CLRF   xC4
0EA2:  MOVLW  04
0EA4:  MOVWF  xC3
0EA6:  MOVWF  xC6
0EA8:  MOVLW  AC
0EAA:  MOVWF  xC5
0EAC:  MOVLB  0
0EAE:  RCALL  0CAA
0EB0:  MOVF   01,W
0EB2:  MOVLB  4
0EB4:  ADDWF  xA3,F
....................    ec += mmcsd_read_data(32, 4, &Large_Sectors); 
0EB6:  MOVLB  5
0EB8:  CLRF   xC2
0EBA:  CLRF   xC1
0EBC:  CLRF   xC0
0EBE:  MOVLW  20
0EC0:  MOVWF  xBF
0EC2:  CLRF   xC4
0EC4:  MOVLW  04
0EC6:  MOVWF  xC3
0EC8:  MOVWF  xC6
0ECA:  MOVLW  B0
0ECC:  MOVWF  xC5
0ECE:  MOVLB  0
0ED0:  RCALL  0CAA
0ED2:  MOVF   01,W
0ED4:  MOVLB  4
0ED6:  ADDWF  xA3,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
.................... #else 
....................    ec += mmcsd_read_data(0x3EC, 4, &Next_Free_Clust); 
0ED8:  MOVLB  5
0EDA:  CLRF   xC2
0EDC:  CLRF   xC1
0EDE:  MOVLW  03
0EE0:  MOVWF  xC0
0EE2:  MOVLW  EC
0EE4:  MOVWF  xBF
0EE6:  CLRF   xC4
0EE8:  MOVLW  04
0EEA:  MOVWF  xC3
0EEC:  MOVLW  02
0EEE:  MOVWF  xC6
0EF0:  MOVLW  31
0EF2:  MOVWF  xC5
0EF4:  MOVLB  0
0EF6:  RCALL  0CAA
0EF8:  MOVF   01,W
0EFA:  MOVLB  4
0EFC:  ADDWF  xA3,F
.................... #endif 
....................    if(ec != GOODEC) 
0EFE:  MOVF   xA3,F
0F00:  BZ    0F08
....................       return EOF; 
0F02:  MOVLW  FF
0F04:  MOVWF  01
0F06:  BRA    0FE2
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
0F08:  CLRF   xCB
0F0A:  MOVFF  4A5,4CA
0F0E:  MOVFF  4A7,4CD
0F12:  MOVFF  4A6,4CC
0F16:  MOVLB  0
0F18:  RCALL  0D32
0F1A:  MOVFF  02,226
0F1E:  MOVFF  01,225
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
0F22:  MOVFF  4A6,00
0F26:  MOVFF  4A7,01
0F2A:  CLRF   02
0F2C:  CLRF   03
0F2E:  MOVFF  03,4BB
0F32:  MOVFF  02,4BA
0F36:  MOVFF  4A7,4B9
0F3A:  MOVFF  4A6,4B8
0F3E:  MOVFF  4B7,5CD
0F42:  MOVFF  4B6,5CC
0F46:  MOVFF  4B5,5CB
0F4A:  MOVFF  4B4,5CA
0F4E:  MOVFF  03,5D1
0F52:  MOVFF  02,5D0
0F56:  MOVFF  4A7,5CF
0F5A:  MOVFF  4A6,5CE
0F5E:  RCALL  0D54
0F60:  MOVFF  03,230
0F64:  MOVFF  02,22F
0F68:  MOVFF  01,22E
0F6C:  MOVFF  00,22D
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = Reserved_Sectors * Bytes_Per_Sector; 
0F70:  MOVFF  4A9,4CB
0F74:  MOVFF  4A8,4CA
0F78:  MOVFF  4A7,4CD
0F7C:  MOVFF  4A6,4CC
0F80:  RCALL  0D32
0F82:  MOVFF  02,228
0F86:  MOVFF  01,227
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
0F8A:  MOVLB  5
0F8C:  CLRF   xCD
0F8E:  CLRF   xCC
0F90:  CLRF   xCB
0F92:  MOVFF  4A4,5CA
0F96:  MOVFF  230,5D1
0F9A:  MOVFF  22F,5D0
0F9E:  MOVFF  22E,5CF
0FA2:  MOVFF  22D,5CE
0FA6:  MOVLB  0
0FA8:  RCALL  0D54
0FAA:  MOVF   00,W
0FAC:  MOVLB  2
0FAE:  ADDWF  x27,W
0FB0:  MOVWF  x35
0FB2:  MOVF   01,W
0FB4:  ADDWFC x28,W
0FB6:  MOVWF  x36
0FB8:  MOVLW  00
0FBA:  ADDWFC 02,W
0FBC:  MOVWF  x37
0FBE:  MOVLW  00
0FC0:  ADDWFC 03,W
0FC2:  MOVWF  x38
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Bytes_Per_Cluster + Root_Dir; 
0FC4:  MOVF   x25,W
0FC6:  ADDWF  x35,W
0FC8:  MOVWF  x29
0FCA:  MOVF   x26,W
0FCC:  ADDWFC x36,W
0FCE:  MOVWF  x2A
0FD0:  MOVLW  00
0FD2:  ADDWFC x37,W
0FD4:  MOVWF  x2B
0FD6:  MOVLW  00
0FD8:  ADDWFC x38,W
0FDA:  MOVWF  x2C
.................... #else // FAT16 
....................    Data_Start = (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
....................    Data_Start /= Bytes_Per_Sector; 
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
....................    Data_Start *= Bytes_Per_Sector; 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
0FDC:  MOVLW  00
0FDE:  MOVWF  01
0FE0:  MOVLB  4
0FE2:  MOVLB  0
0FE4:  GOTO   1012 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
*
182A:  MOVFF  5B9,03
182E:  MOVLB  5
1830:  MOVFF  5B8,FE9
1834:  MOVFF  5B9,FEA
1838:  MOVFF  FEF,5BA
183C:  MOVFF  FEC,5BB
1840:  MOVFF  FEC,5BC
1844:  MOVFF  FEC,5BD
1848:  RLCF   xBA,F
184A:  RLCF   xBB,F
184C:  RLCF   xBC,F
184E:  RLCF   xBD,F
1850:  RLCF   xBA,F
1852:  RLCF   xBB,F
1854:  RLCF   xBC,F
1856:  RLCF   xBD,F
1858:  MOVLW  FC
185A:  ANDWF  xBA,F
185C:  MOVLB  2
185E:  MOVF   x27,W
1860:  MOVLB  5
1862:  ADDWF  xBA,F
1864:  MOVLB  2
1866:  MOVF   x28,W
1868:  MOVLB  5
186A:  ADDWFC xBB,F
186C:  MOVLW  00
186E:  ADDWFC xBC,F
1870:  ADDWFC xBD,F
1872:  MOVFF  5BD,5C2
1876:  MOVFF  5BC,5C1
187A:  MOVFF  5BB,5C0
187E:  MOVFF  5BA,5BF
1882:  CLRF   xC4
1884:  MOVLW  04
1886:  MOVWF  xC3
1888:  MOVFF  5B9,5C6
188C:  MOVFF  5B8,5C5
1890:  MOVLB  0
1892:  CALL   0CAA
1896:  MOVF   01,F
1898:  BZ    18A0
....................       return EOF; 
189A:  MOVLW  FF
189C:  MOVWF  01
189E:  BRA    18A4
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
18A0:  MOVLW  00
18A2:  MOVWF  01
18A4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
*
12DC:  MOVLB  5
12DE:  CLRF   x91
12E0:  CLRF   x90
12E2:  CLRF   x8F
12E4:  MOVLW  01
12E6:  MOVWF  x8E
12E8:  CLRF   x95
12EA:  CLRF   x94
12EC:  CLRF   x93
12EE:  CLRF   x92
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
12F0:  MOVFF  58C,FE9
12F4:  MOVFF  58D,FEA
12F8:  MOVFF  FEF,00
12FC:  MOVFF  FEC,01
1300:  MOVFF  FEC,02
1304:  MOVFF  FEC,03
1308:  MOVF   00,W
130A:  SUBWF  x92,W
130C:  BNZ   1320
130E:  MOVF   01,W
1310:  SUBWF  x93,W
1312:  BNZ   1320
1314:  MOVF   02,W
1316:  SUBWF  x94,W
1318:  BNZ   1320
131A:  MOVF   03,W
131C:  SUBWF  x95,W
131E:  BZ    138E
....................    {    
....................       cur_cluster += 1; 
1320:  MOVLW  01
1322:  ADDWF  x8E,F
1324:  MOVLW  00
1326:  ADDWFC x8F,F
1328:  ADDWFC x90,F
132A:  ADDWFC x91,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
132C:  RLCF   x8E,W
132E:  MOVWF  x97
1330:  RLCF   x8F,W
1332:  MOVWF  x98
1334:  RLCF   x90,W
1336:  MOVWF  x99
1338:  RLCF   x91,W
133A:  MOVWF  x9A
133C:  RLCF   x97,F
133E:  RLCF   x98,F
1340:  RLCF   x99,F
1342:  RLCF   x9A,F
1344:  MOVLW  FC
1346:  ANDWF  x97,F
1348:  MOVLB  2
134A:  MOVF   x27,W
134C:  MOVLB  5
134E:  ADDWF  x97,F
1350:  MOVLB  2
1352:  MOVF   x28,W
1354:  MOVLB  5
1356:  ADDWFC x98,F
1358:  MOVLW  00
135A:  ADDWFC x99,F
135C:  ADDWFC x9A,F
135E:  MOVFF  59A,5C2
1362:  MOVFF  599,5C1
1366:  MOVFF  598,5C0
136A:  MOVFF  597,5BF
136E:  CLRF   xC4
1370:  MOVLW  04
1372:  MOVWF  xC3
1374:  MOVLW  05
1376:  MOVWF  xC6
1378:  MOVLW  92
137A:  MOVWF  xC5
137C:  MOVLB  0
137E:  RCALL  0CAA
1380:  MOVF   01,F
1382:  BZ    138A
....................          return EOF; 
1384:  MOVLW  FF
1386:  MOVWF  01
1388:  BRA    13AA
.................... #else // FAT16 
138A:  MOVLB  5
138C:  BRA    12F0
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................    } 
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
138E:  MOVFF  58C,FE9
1392:  MOVFF  58D,FEA
1396:  MOVFF  58E,FEF
139A:  MOVFF  58F,FEC
139E:  MOVFF  590,FEC
13A2:  MOVFF  591,FEC
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
13A6:  MOVLW  00
13A8:  MOVWF  01
13AA:  MOVLB  0
13AC:  GOTO   1514 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if((*my_addr + 1) % Bytes_Per_Cluster == 0) 
*
1E9E:  MOVFF  5B3,03
1EA2:  MOVLB  5
1EA4:  MOVFF  5B2,FE9
1EA8:  MOVFF  5B3,FEA
1EAC:  MOVFF  FEF,5B8
1EB0:  MOVFF  FEC,5B9
1EB4:  MOVFF  FEC,5BA
1EB8:  MOVFF  FEC,5BB
1EBC:  MOVLW  01
1EBE:  ADDWF  xB8,F
1EC0:  MOVLW  00
1EC2:  ADDWFC xB9,F
1EC4:  ADDWFC xBA,F
1EC6:  ADDWFC xBB,F
1EC8:  MOVFF  FEA,5BD
1ECC:  MOVFF  FE9,5BC
1ED0:  BSF    FD8.1
1ED2:  MOVLW  05
1ED4:  MOVWF  FEA
1ED6:  MOVLW  BE
1ED8:  MOVWF  FE9
1EDA:  MOVFF  5BB,5C7
1EDE:  MOVFF  5BA,5C6
1EE2:  MOVFF  5B9,5C5
1EE6:  MOVFF  5B8,5C4
1EEA:  CLRF   xCB
1EEC:  CLRF   xCA
1EEE:  MOVFF  226,5C9
1EF2:  MOVFF  225,5C8
1EF6:  MOVLB  0
1EF8:  CALL   11D2
1EFC:  MOVFF  5BE,00
1F00:  MOVFF  5BF,01
1F04:  MOVFF  5C0,02
1F08:  MOVFF  5C1,03
1F0C:  MOVFF  5BD,FEA
1F10:  MOVFF  5BC,FE9
1F14:  MOVFF  5C1,5BB
1F18:  MOVFF  5C0,5BA
1F1C:  MOVFF  5BF,5B9
1F20:  MOVFF  5BE,5B8
1F24:  MOVLB  5
1F26:  MOVF   xB8,F
1F28:  BNZ   1FF0
1F2A:  MOVF   xB9,F
1F2C:  BNZ   1FF0
1F2E:  MOVF   xBA,F
1F30:  BNZ   1FF0
1F32:  MOVF   xBB,F
1F34:  BNZ   1FF0
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if(((*my_addr + 1) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       // convert the current address into the address of where information about 
....................       //  the address is stored in the FAT, and put this value into the current address 
....................       temp = addr_to_cluster(*my_addr); 
1F36:  MOVFF  5B3,03
1F3A:  MOVFF  5B2,FE9
1F3E:  MOVFF  5B3,FEA
1F42:  MOVFF  FEF,5BC
1F46:  MOVFF  FEC,5BD
1F4A:  MOVFF  FEC,5BE
1F4E:  MOVFF  FEC,5BF
1F52:  MOVLB  0
1F54:  CALL   1266
1F58:  MOVFF  03,5B7
1F5C:  MOVFF  02,5B6
1F60:  MOVFF  01,5B5
1F64:  MOVFF  00,5B4
....................       if(get_next_cluster(&temp) == EOF) 
1F68:  MOVLW  05
1F6A:  MOVLB  5
1F6C:  MOVWF  xB9
1F6E:  MOVLW  B4
1F70:  MOVWF  xB8
1F72:  MOVLB  0
1F74:  RCALL  182A
1F76:  MOVF   01,W
1F78:  SUBLW  FF
1F7A:  BNZ   1F82
....................          return EOF; 
1F7C:  MOVLW  FF
1F7E:  MOVWF  01
1F80:  BRA    202A
.................... #ifdef FAT32 
....................       if((temp == 0xFFFFFFFF) 
....................          || (temp == 0x0FFFFFFF)) // WinXP will format the root directory's FAT entry to 0x0FFFFFFF. 
1F82:  MOVLB  5
1F84:  INCFSZ xB4,W
1F86:  BRA    1F96
1F88:  INCFSZ xB5,W
1F8A:  BRA    1F96
1F8C:  INCFSZ xB6,W
1F8E:  BRA    1F96
1F90:  INCFSZ xB7,W
1F92:  BRA    1F96
1F94:  BRA    1FA8
1F96:  INCFSZ xB4,W
1F98:  BRA    1FB2
1F9A:  INCFSZ xB5,W
1F9C:  BRA    1FB2
1F9E:  INCFSZ xB6,W
1FA0:  BRA    1FB2
1FA2:  MOVF   xB7,W
1FA4:  SUBLW  0F
1FA6:  BNZ   1FB2
....................          return EOF; 
1FA8:  MOVLW  FF
1FAA:  MOVWF  01
1FAC:  MOVLB  0
1FAE:  BRA    202A
1FB0:  MOVLB  5
.................... #else // FAT16 
....................       if(temp == 0xFFFF) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................       *my_addr = cluster_to_addr(temp); 
1FB2:  MOVFF  5B3,03
1FB6:  MOVFF  5B2,5B8
1FBA:  MOVFF  5B3,5B9
1FBE:  MOVFF  5B7,5C5
1FC2:  MOVFF  5B6,5C4
1FC6:  MOVFF  5B5,5C3
1FCA:  MOVFF  5B4,5C2
1FCE:  MOVLB  0
1FD0:  CALL   13B0
1FD4:  MOVFF  5B9,FEA
1FD8:  MOVFF  5B8,FE9
1FDC:  MOVFF  00,FEF
1FE0:  MOVFF  01,FEC
1FE4:  MOVFF  02,FEC
1FE8:  MOVFF  03,FEC
....................    } 
1FEC:  BRA    2026
1FEE:  MOVLB  5
....................    else 
....................       *my_addr += 1; 
1FF0:  MOVFF  5B2,FE9
1FF4:  MOVFF  5B3,FEA
1FF8:  MOVLW  01
1FFA:  ADDWF  FEF,W
1FFC:  MOVWF  00
1FFE:  MOVLW  00
2000:  ADDWFC FEC,W
2002:  MOVWF  01
2004:  MOVLW  00
2006:  ADDWFC FEC,W
2008:  MOVWF  02
200A:  MOVLW  00
200C:  ADDWFC FEC,W
200E:  MOVWF  03
2010:  MOVF   FED,F
2012:  MOVF   FED,F
2014:  MOVF   FED,F
2016:  MOVFF  00,FEF
201A:  MOVFF  01,FEC
201E:  MOVFF  02,FEC
2022:  MOVWF  FEC
2024:  MOVLB  0
....................  
....................    return GOODEC; 
2026:  MOVLW  00
2028:  MOVWF  01
202A:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're trying to go backwards one entry from the beginning of the root, 
....................    //  we won't be able to... 
....................    if(*my_addr <= Root_Dir) 
*
140C:  MOVFF  587,03
1410:  MOVLB  5
1412:  MOVFF  586,FE9
1416:  MOVFF  587,FEA
141A:  MOVFF  FEF,58C
141E:  MOVFF  FEC,58D
1422:  MOVFF  FEC,58E
1426:  MOVFF  FEC,58F
142A:  MOVF   x8F,W
142C:  MOVLB  2
142E:  SUBWF  x38,W
1430:  BNC   145C
1432:  BNZ   1456
1434:  MOVLB  5
1436:  MOVF   x8E,W
1438:  MOVLB  2
143A:  SUBWF  x37,W
143C:  BNC   145C
143E:  BNZ   1456
1440:  MOVLB  5
1442:  MOVF   x8D,W
1444:  MOVLB  2
1446:  SUBWF  x36,W
1448:  BNC   145C
144A:  BNZ   1456
144C:  MOVLB  5
144E:  MOVF   x8C,W
1450:  MOVLB  2
1452:  SUBWF  x35,W
1454:  BNC   145C
....................       return GOODEC; 
1456:  MOVLW  00
1458:  MOVWF  01
145A:  BRA    15CA
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if(*my_addr % Bytes_Per_Cluster == 0) 
145C:  MOVFF  587,03
1460:  MOVLB  5
1462:  MOVFF  586,FE9
1466:  MOVFF  587,FEA
146A:  MOVFF  FEF,5C4
146E:  MOVFF  FEC,5C5
1472:  MOVFF  FEC,5C6
1476:  MOVFF  FEC,5C7
147A:  MOVFF  FEA,591
147E:  MOVFF  FE9,590
1482:  BSF    FD8.1
1484:  MOVLW  05
1486:  MOVWF  FEA
1488:  MOVLW  92
148A:  MOVWF  FE9
148C:  CLRF   xCB
148E:  CLRF   xCA
1490:  MOVFF  226,5C9
1494:  MOVFF  225,5C8
1498:  MOVLB  0
149A:  RCALL  11D2
149C:  MOVFF  592,00
14A0:  MOVFF  593,01
14A4:  MOVFF  594,02
14A8:  MOVFF  595,03
14AC:  MOVFF  591,FEA
14B0:  MOVFF  590,FE9
14B4:  MOVFF  595,58F
14B8:  MOVFF  594,58E
14BC:  MOVFF  593,58D
14C0:  MOVFF  592,58C
14C4:  MOVLB  5
14C6:  MOVF   x8C,F
14C8:  BNZ   1592
14CA:  MOVF   x8D,F
14CC:  BNZ   1592
14CE:  MOVF   x8E,F
14D0:  BNZ   1592
14D2:  MOVF   x8F,F
14D4:  BNZ   1592
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if((*my_addr % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       temp = addr_to_cluster(*my_addr); 
14D6:  MOVFF  587,03
14DA:  MOVFF  586,FE9
14DE:  MOVFF  587,FEA
14E2:  MOVFF  FEF,5BC
14E6:  MOVFF  FEC,5BD
14EA:  MOVFF  FEC,5BE
14EE:  MOVFF  FEC,5BF
14F2:  MOVLB  0
14F4:  RCALL  1266
14F6:  MOVFF  03,58B
14FA:  MOVFF  02,58A
14FE:  MOVFF  01,589
1502:  MOVFF  00,588
....................       if(get_prev_cluster(&temp) == EOF) 
1506:  MOVLW  05
1508:  MOVLB  5
150A:  MOVWF  x8D
150C:  MOVLW  88
150E:  MOVWF  x8C
1510:  MOVLB  0
1512:  BRA    12DC
1514:  MOVF   01,W
1516:  SUBLW  FF
1518:  BNZ   1524
....................          return EOF; 
151A:  MOVLW  FF
151C:  MOVWF  01
151E:  MOVLB  2
1520:  BRA    15CA
1522:  MOVLB  0
....................  
....................       *my_addr = cluster_to_addr(temp) + (Bytes_Per_Cluster - 1); 
1524:  MOVFF  587,03
1528:  MOVFF  586,58C
152C:  MOVFF  587,58D
1530:  MOVFF  58B,5C5
1534:  MOVFF  58A,5C4
1538:  MOVFF  589,5C3
153C:  MOVFF  588,5C2
1540:  MOVLB  0
1542:  RCALL  13B0
1544:  MOVFF  03,591
1548:  MOVFF  02,590
154C:  MOVFF  01,58F
1550:  MOVFF  00,58E
1554:  MOVLW  01
1556:  MOVLB  2
1558:  SUBWF  x25,W
155A:  MOVWF  00
155C:  MOVLW  00
155E:  SUBWFB x26,W
1560:  MOVWF  03
1562:  MOVF   00,W
1564:  MOVLB  5
1566:  ADDWF  x8E,W
1568:  MOVWF  00
156A:  MOVF   03,W
156C:  ADDWFC 01,W
156E:  MOVWF  01
1570:  MOVLW  00
1572:  ADDWFC 02,W
1574:  MOVWF  02
1576:  MOVLW  00
1578:  ADDWFC x91,W
157A:  MOVFF  58D,FEA
157E:  MOVFF  58C,FE9
1582:  MOVFF  00,FEF
1586:  MOVFF  01,FEC
158A:  MOVFF  02,FEC
158E:  MOVWF  FEC
....................    } 
1590:  BRA    15C4
....................    else 
....................       *my_addr -= 1; 
1592:  MOVFF  586,FE9
1596:  MOVFF  587,FEA
159A:  MOVLW  01
159C:  SUBWF  FEF,W
159E:  MOVWF  00
15A0:  MOVLW  00
15A2:  SUBWFB FEC,W
15A4:  MOVWF  01
15A6:  MOVLW  00
15A8:  SUBWFB FEC,W
15AA:  MOVWF  02
15AC:  MOVLW  00
15AE:  SUBWFB FEC,W
15B0:  MOVF   FED,F
15B2:  MOVF   FED,F
15B4:  MOVF   FED,F
15B6:  MOVFF  00,FEF
15BA:  MOVFF  01,FEC
15BE:  MOVFF  02,FEC
15C2:  MOVWF  FEC
....................  
....................    return GOODEC; 
15C4:  MOVLW  00
15C6:  MOVWF  01
15C8:  MOVLB  2
15CA:  MOVLB  0
15CC:  GOTO   1602 (RETURN)
.................... } 
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
*
13B0:  MOVLW  02
13B2:  MOVLB  5
13B4:  SUBWF  xC2,W
13B6:  MOVWF  00
13B8:  MOVLW  00
13BA:  SUBWFB xC3,W
13BC:  MOVWF  01
13BE:  MOVLW  00
13C0:  SUBWFB xC4,W
13C2:  MOVWF  02
13C4:  MOVLW  00
13C6:  SUBWFB xC5,W
13C8:  MOVWF  03
13CA:  MOVWF  xC9
13CC:  MOVFF  02,5C8
13D0:  MOVFF  01,5C7
13D4:  MOVFF  00,5C6
13D8:  CLRF   xCD
13DA:  CLRF   xCC
13DC:  MOVFF  226,5CB
13E0:  MOVFF  225,5CA
13E4:  MOVWF  xD1
13E6:  MOVFF  02,5D0
13EA:  MOVFF  01,5CF
13EE:  MOVFF  00,5CE
13F2:  MOVLB  0
13F4:  RCALL  0D54
13F6:  MOVLB  2
13F8:  MOVF   x35,W
13FA:  ADDWF  00,F
13FC:  MOVF   x36,W
13FE:  ADDWFC 01,F
1400:  MOVF   x37,W
1402:  ADDWFC 02,F
1404:  MOVF   x38,W
1406:  ADDWFC 03,F
1408:  MOVLB  0
140A:  RETURN 0
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
....................       return 0; 
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
*
1266:  MOVLB  2
1268:  MOVF   x35,W
126A:  MOVLB  5
126C:  SUBWF  xBC,W
126E:  MOVWF  xC0
1270:  MOVLB  2
1272:  MOVF   x36,W
1274:  MOVLB  5
1276:  SUBWFB xBD,W
1278:  MOVWF  xC1
127A:  MOVLB  2
127C:  MOVF   x37,W
127E:  MOVLB  5
1280:  SUBWFB xBE,W
1282:  MOVWF  xC2
1284:  MOVLB  2
1286:  MOVF   x38,W
1288:  MOVLB  5
128A:  SUBWFB xBF,W
128C:  MOVWF  xC3
128E:  BCF    FD8.1
1290:  MOVWF  xC7
1292:  MOVFF  5C2,5C6
1296:  MOVFF  5C1,5C5
129A:  MOVFF  5C0,5C4
129E:  CLRF   xCB
12A0:  CLRF   xCA
12A2:  MOVFF  226,5C9
12A6:  MOVFF  225,5C8
12AA:  MOVLB  0
12AC:  RCALL  11D2
12AE:  MOVFF  03,5C3
12B2:  MOVFF  02,5C2
12B6:  MOVFF  01,5C1
12BA:  MOVFF  00,5C0
12BE:  MOVLW  02
12C0:  MOVLB  5
12C2:  ADDWF  00,W
12C4:  MOVWF  00
12C6:  MOVLW  00
12C8:  ADDWFC 01,W
12CA:  MOVWF  01
12CC:  MOVLW  00
12CE:  ADDWFC 02,W
12D0:  MOVWF  02
12D2:  MOVLW  00
12D4:  ADDWFC 03,W
12D6:  MOVWF  03
12D8:  MOVLB  0
12DA:  RETURN 0
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
....................       return 0; 
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
.................... { 
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
....................       BS_VolLab[] = "NO NAME    "; 
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
....................       return EOF; 
....................    else if(DskSize < 0x41000) // 260 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0X800000) // 8 GB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x1000000) // 16 GB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x2000000) // 32 GB 
....................       BPB_SecPerClus = 32; 
....................    else // > 32 GB; this is too big 
....................       return EOF; 
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0x4000) // 16 MB 
....................       BPB_SecPerClus = 2; 
....................    else if(DskSize < 0X20000) // 128 MB 
....................       BPB_SecPerClus = 4; 
....................    else if(DskSize < 0x40000) // 256 MB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x80000) // 512 MB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x100000) // 1 GB 
....................       BPB_SecPerClus = 32; 
....................    else if(DskSize < 0x200000) // 2 GB 
....................       BPB_SecPerClus = 64; 
....................    else // > 2 GB; this is too big 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
....................       data[i] = 0; 
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
....................    data[1] = BS_jmpBoot; 
....................    data[2] = 0x90;    
....................    sprintf(data + 3, "%s", BS_OEMName); 
....................    data[11] = make8(BPB_BytsPerSec, 0); 
....................    data[12] = make8(BPB_BytsPerSec, 1); 
....................    data[13] = BPB_SecPerClus; 
....................    data[14] = BPB_RsvdSecCnt; 
....................    data[16] = BPB_NumFATs; 
....................    data[21] = BPB_Media; 
....................    data[24] = BPB_SecPerTrk;  
....................    data[26] = BPB_NumHeads; 
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
....................    data[33] = make8(BPB_TotSec, 1); 
....................    data[34] = make8(BPB_TotSec, 2); 
....................    data[35] = make8(BPB_TotSec, 3); 
....................    data[36] = make8(BPB_FATSz, 0); 
....................    data[37] = make8(BPB_FATSz, 1); 
....................    data[38] = make8(BPB_FATSz, 2); 
....................    data[39] = make8(BPB_FATSz, 3); 
....................    data[44] = BPB_RootClus; 
....................    data[48] = BPB_FSInfo; 
....................    data[50] = BPB_BkBootSec; 
....................    data[66] = BS_BootSig; 
....................    data[67] = make8(BS_VolID, 0); 
....................    data[68] = make8(BS_VolID, 1); 
....................    data[69] = make8(BS_VolID, 2); 
....................    data[70] = make8(BS_VolID, 3); 
....................    sprintf(data + 71, "%s", BS_VolLab); 
....................    sprintf(data + 82, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    data[3] = 0x0F; 
....................    data[4] = 0xFF; 
....................    data[5] = 0xFF; 
....................    data[6] = 0xFF; 
....................    data[7] = 0x0F; 
....................    data[8] = 0xFF; 
....................    data[9] = 0xFF; 
....................    data[10] = 0xFF; 
....................    data[11] = 0x0F; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
....................    // reset the last cluster 
....................    i = 2; 
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
....................       return EOF; 
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
....................    data[18] = make8(BPB_RootEntCnt, 1); 
....................    data[19] = make8(BPB_TotSec, 0); 
....................    data[20] = make8(BPB_TotSec, 1); 
....................    data[22] = make8(BPB_FATSz, 0); 
....................    data[23] = make8(BPB_FATSz, 1); 
....................    data[38] = BS_BootSig; 
....................    data[39] = make8(BS_VolID, 0); 
....................    data[40] = make8(BS_VolID, 1); 
....................    data[41] = make8(BS_VolID, 2); 
....................    data[42] = make8(BS_VolID, 3); 
....................    sprintf(data + 43, "%s", BS_VolLab); 
....................    sprintf(data + 54, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
....................       return EOF;    
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
....................  
....................    while(get_next_file(&stream) != EOF) 
....................    { 
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
....................          return EOF; 
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
....................       if (stream.File_Type == Directory) 
....................          putc('/'); 
....................    } 
....................  
....................    fatclose(&stream); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
.................... #define COMMAND_SIZE 10 
.................... #define NUM_COMMANDS 11 
....................  
.................... float power1; 
.................... unsigned int16 rcount = 0, rcount2 = 0, rcount6 = 0, rcount_TOUT = 0; 
.................... int rcount1 = 0, rcount4 = 0, rcount3 = 0, rcount5 = 0; 
.................... int error_get = 0, error_get1 = 0; 
.................... int kt_time = 0, num = 0, num_no2 = 0, num_so2 = 0, num_co = 0; 
.................... char diachi1[8] = {0x04, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01}; 
.................... char diachi2[8] = {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03}; 
.................... // *********** Bien thoi gian *********** // 
.................... BYTE sec; 
.................... BYTE min; 
.................... BYTE hrs; 
.................... BYTE day; 
.................... BYTE month; 
.................... BYTE yr; 
....................  
.................... void AppendFile(char *fileName, char *appendString); 
.................... void MakeFile(char *fileName); 
.................... //float pre_power = 0,delta_power=0; 
....................  
.................... unsigned int16 Temp, RH; 
.................... short Time_out; 
.................... unsigned int8 T_byte1, T_byte2, RH_byte1, RH_byte2, CheckSum; 
....................  
.................... char URLeeprom[55]; 
.................... unsigned int dodaiURL = 0; 
.................... //!#define buffer_size 100 //Buffer size you can adjust this size 
.................... #define buff2_size 60 
....................  
.................... //#DEVICE HIGH_INTS=TRUE 
....................  
.................... // ********** Bien doc cam bien ********** // 
.................... float PA = 0, PM25 = 0, PM10 = 0, LUX = 0; 
.................... float Temp_485 = 0, Humi_485 = 0, Noise = 0; 
.................... float Tb_no2 = 0, Tb_so2 = 0, Tb_co = 0; 
.................... float buf_so2 = 0, buf_no2 = 0, buf_co = 0; 
.................... int Wind = 0, check_hour = 0; 
.................... char No2[10], So2[10], Co[15]; 
.................... //cac bien 
.................... char c, buff[buff2_size], *toInt, *ptr;//, buffer[buffer_size] // SAVE Response 
.................... int xbuff = 0x00, xbuff2, i, kt = 0, gg; 
.................... int count_check = 0, count_check1 = 0, Check_Pin = 0, check_rc3 = 0; 
.................... float tachdata[20]; 
.................... int tachdata_time[6]; 
.................... int setcapnhat = 1, bit_binhthuong = 0; 
.................... int1 kiemtraread = 0, Wait = 0; 
.................... char querystring[220]; 
.................... //Chuong trinh ngat UART 
.................... #define RTC_SDA PIN_A3 
.................... #define RTC_SCL PIN_B3 
.................... #use i2c(master, sda = RTC_SDA, scl = RTC_SCL, fast = 450000) 
*
3F9E:  MOVLW  08
3FA0:  MOVWF  01
3FA2:  BRA    3FA4
3FA4:  BRA    3FA6
3FA6:  NOP   
3FA8:  BCF    F8A.3
3FAA:  BCF    F93.3
3FAC:  BRA    3FAE
3FAE:  BRA    3FB0
3FB0:  BRA    3FB2
3FB2:  MOVLB  4
3FB4:  RLCF   xAB,F
3FB6:  BCF    F89.3
3FB8:  BTFSC  FD8.0
3FBA:  BSF    F92.3
3FBC:  BTFSS  FD8.0
3FBE:  BCF    F92.3
3FC0:  BSF    F93.3
3FC2:  BTFSS  F81.3
3FC4:  BRA    3FC2
3FC6:  DECFSZ 01,F
3FC8:  BRA    3FCC
3FCA:  BRA    3FD0
3FCC:  MOVLB  0
3FCE:  BRA    3FA2
3FD0:  BRA    3FD2
3FD2:  BRA    3FD4
3FD4:  NOP   
3FD6:  BCF    F8A.3
3FD8:  BCF    F93.3
3FDA:  NOP   
3FDC:  BSF    F92.3
3FDE:  BRA    3FE0
3FE0:  BRA    3FE2
3FE2:  BRA    3FE4
3FE4:  BRA    3FE6
3FE6:  BRA    3FE8
3FE8:  BRA    3FEA
3FEA:  BSF    F93.3
3FEC:  BTFSS  F81.3
3FEE:  BRA    3FEC
3FF0:  CLRF   01
3FF2:  BRA    3FF4
3FF4:  BRA    3FF6
3FF6:  BRA    3FF8
3FF8:  BTFSC  F80.3
3FFA:  BSF    01.0
3FFC:  BCF    F8A.3
3FFE:  BCF    F93.3
4000:  BCF    F89.3
4002:  BCF    F92.3
4004:  MOVLB  0
4006:  RETURN 0
*
42D0:  MOVLW  08
42D2:  MOVLB  4
42D4:  MOVWF  xA2
42D6:  MOVFF  00,4A3
42DA:  BSF    F92.3
42DC:  BRA    42DE
42DE:  BRA    42E0
42E0:  BRA    42E2
42E2:  BSF    F93.3
42E4:  BTFSS  F81.3
42E6:  BRA    42E4
42E8:  BTFSC  F80.3
42EA:  BSF    FD8.0
42EC:  BTFSS  F80.3
42EE:  BCF    FD8.0
42F0:  RLCF   01,F
42F2:  BRA    42F4
42F4:  BRA    42F6
42F6:  NOP   
42F8:  BCF    F93.3
42FA:  BCF    F8A.3
42FC:  DECFSZ xA2,F
42FE:  BRA    42DA
4300:  BSF    F92.3
4302:  BRA    4304
4304:  BRA    4306
4306:  BRA    4308
4308:  BCF    F89.3
430A:  MOVF   xA3,W
430C:  BTFSS  FD8.2
430E:  BCF    F92.3
4310:  NOP   
4312:  BSF    F93.3
4314:  BTFSS  F81.3
4316:  BRA    4314
4318:  BRA    431A
431A:  BRA    431C
431C:  NOP   
431E:  BCF    F8A.3
4320:  BCF    F93.3
4322:  BRA    4324
4324:  BRA    4326
4326:  BRA    4328
4328:  BCF    F89.3
432A:  BCF    F92.3
432C:  MOVLB  0
432E:  RETURN 0
.................... int DEC_2_BCD(int to_convert); 
.................... void Set_Time_Date(BYTE day, BYTE mth, BYTE year, BYTE hr, BYTE min, BYTE sec); 
.................... void Update_Current_Date_Time(); 
....................  
.................... // *********** Ngat Uart *********** // 
.................... #INT_RDA 
.................... void RDA_isr() 
.................... { 
....................     c = fgetc(PORT1SIM); 
*
0214:  BTFSS  F9E.5
0216:  BRA    0214
0218:  MOVFF  FAE,302
021C:  MOVLB  3
....................     if (c == '*') 
021E:  MOVF   x02,W
0220:  SUBLW  2A
0222:  BNZ   0248
....................     { //kt2=1; 
....................         kt = 1; 
0224:  MOVLW  01
0226:  MOVWF  x46
....................         xbuff2 = 0; 
0228:  CLRF   x44
....................         for (i = 0; i < buff2_size; i++) 
022A:  CLRF   x45
022C:  MOVF   x45,W
022E:  SUBLW  3B
0230:  BNC   0246
....................         { 
....................             buff[i] = 0x00; 
0232:  CLRF   03
0234:  MOVF   x45,W
0236:  ADDLW  03
0238:  MOVWF  FE9
023A:  MOVLW  03
023C:  ADDWFC 03,W
023E:  MOVWF  FEA
0240:  CLRF   FEF
0242:  INCF   x45,F
0244:  BRA    022C
....................         } 
....................     } 
0246:  BRA    0258
....................     else if (c == '#') 
0248:  MOVF   x02,W
024A:  SUBLW  23
024C:  BNZ   0258
....................     { 
....................         kt = 0; 
024E:  CLRF   x46
....................         kt_time = 1; 
0250:  MOVLW  01
0252:  MOVLB  2
0254:  MOVWF  x4D
0256:  MOVLB  3
....................         break; 
....................     } 
....................     if (kt == 1) 
0258:  DECFSZ x46,W
025A:  BRA    0270
....................     { 
....................         buff[xbuff2] = c; 
025C:  CLRF   03
025E:  MOVF   x44,W
0260:  ADDLW  03
0262:  MOVWF  FE9
0264:  MOVLW  03
0266:  ADDWFC 03,W
0268:  MOVWF  FEA
026A:  MOVFF  302,FEF
....................         xbuff2++; 
026E:  INCF   x44,F
....................     } 
....................     xbuff++; 
0270:  INCF   x43,F
0272:  BCF    F9E.5
0274:  MOVLB  0
0276:  GOTO   0078
.................... } 
....................  
.................... // *********** HAM eeprom *********** // 
.................... void eeprom_write_string(unsigned int8 addr, unsigned char *str) 
.................... { 
....................     while (*str) 
*
342C:  MOVFF  5AF,03
3430:  MOVLB  5
3432:  MOVFF  5AE,FE9
3436:  MOVFF  5AF,FEA
343A:  MOVF   FEF,F
343C:  BZ    3488
....................     { 
....................         write_eeprom(addr, *str); 
343E:  MOVFF  5AF,03
3442:  MOVF   xAE,W
3444:  MOVWF  FE9
3446:  MOVFF  03,FEA
344A:  MOVFF  FEF,5B0
344E:  MOVF   FF2,W
3450:  MOVWF  00
3452:  BCF    FF2.7
3454:  MOVFF  5AD,FA9
3458:  MOVFF  5B0,FA8
345C:  BCF    FA6.6
345E:  BCF    FA6.7
3460:  BSF    FA6.2
3462:  MOVLB  F
3464:  MOVLW  55
3466:  MOVWF  FA7
3468:  MOVLW  AA
346A:  MOVWF  FA7
346C:  BSF    FA6.1
346E:  BTFSC  FA6.1
3470:  BRA    346E
3472:  BCF    FA6.2
3474:  MOVF   00,W
3476:  IORWF  FF2,F
....................         addr++; 
3478:  MOVLB  5
347A:  INCF   xAD,F
....................         str++; 
347C:  INCF   xAE,F
347E:  BTFSC  FD8.2
3480:  INCF   xAF,F
3482:  MOVLB  0
3484:  BRA    342C
3486:  MOVLB  5
....................     } 
3488:  MOVLB  0
348A:  GOTO   3528 (RETURN)
.................... } 
....................  
.................... void eeprom_read_string(unsigned int8 addr, unsigned char *str, unsigned int8 len) 
.................... { 
....................     unsigned int8 i, j, c; 
....................     j = 0; 
*
3A78:  MOVLB  4
3A7A:  CLRF   xA6
....................     for (i = 0; i < len; i++) 
3A7C:  CLRF   xA5
3A7E:  MOVF   xA4,W
3A80:  SUBWF  xA5,W
3A82:  BC    3AC4
....................     { 
....................         c = read_eeprom(addr + i); 
3A84:  MOVF   xA5,W
3A86:  ADDWF  xA1,W
3A88:  MOVWF  xA8
3A8A:  MOVFF  FF2,4A9
3A8E:  BCF    FF2.7
3A90:  MOVFF  4A8,FA9
3A94:  BCF    FA6.6
3A96:  BCF    FA6.7
3A98:  BSF    FA6.0
3A9A:  MOVF   FA8,W
3A9C:  BTFSC  xA9.7
3A9E:  BSF    FF2.7
3AA0:  MOVWF  xA7
....................         if ((c > 32) && (c < 127)) 
3AA2:  MOVF   xA7,W
3AA4:  SUBLW  20
3AA6:  BC    3AC0
3AA8:  MOVF   xA7,W
3AAA:  SUBLW  7E
3AAC:  BNC   3AC0
....................         { 
....................             str[j] = c; 
3AAE:  MOVF   xA6,W
3AB0:  ADDWF  xA2,W
3AB2:  MOVWF  FE9
3AB4:  MOVLW  00
3AB6:  ADDWFC xA3,W
3AB8:  MOVWF  FEA
3ABA:  MOVFF  4A7,FEF
....................             j++; 
3ABE:  INCF   xA6,F
....................         } 
3AC0:  INCF   xA5,F
3AC2:  BRA    3A7E
....................     } 
....................     str[j] = 0; 
3AC4:  MOVF   xA6,W
3AC6:  ADDWF  xA2,W
3AC8:  MOVWF  FE9
3ACA:  MOVLW  00
3ACC:  ADDWFC xA3,W
3ACE:  MOVWF  FEA
3AD0:  CLRF   FEF
3AD2:  MOVLB  0
3AD4:  GOTO   6D52 (RETURN)
.................... } 
....................  
.................... // *********** Timer *********** // 
.................... #INT_TIMER1 // Timer1 interrupt ISR 
....................  
.................... void timer1_isr() 
.................... { 
....................     set_timer1(5536); //1/(48M/16)x60000 
*
027A:  MOVLW  15
027C:  MOVWF  FCF
027E:  MOVLW  A0
0280:  MOVWF  FCE
....................     rcount++; 
0282:  MOVLB  2
0284:  INCF   x3F,F
0286:  BTFSC  FD8.2
0288:  INCF   x40,F
....................     rcount2++; 
028A:  INCF   x41,F
028C:  BTFSC  FD8.2
028E:  INCF   x42,F
....................     rcount6++; 
0290:  INCF   x43,F
0292:  BTFSC  FD8.2
0294:  INCF   x44,F
....................     rcount_TOUT++; 
0296:  INCF   x45,F
0298:  BTFSC  FD8.2
029A:  INCF   x46,F
....................     if (rcount2 == 3000) 
029C:  MOVF   x41,W
029E:  SUBLW  B8
02A0:  BNZ   02AC
02A2:  MOVF   x42,W
02A4:  SUBLW  0B
02A6:  BNZ   02AC
....................         rcount2 = 0; 
02A8:  CLRF   x42
02AA:  CLRF   x41
....................     if (rcount6 == 3000) 
02AC:  MOVF   x43,W
02AE:  SUBLW  B8
02B0:  BNZ   02BC
02B2:  MOVF   x44,W
02B4:  SUBLW  0B
02B6:  BNZ   02BC
....................         rcount6 = 0; 
02B8:  CLRF   x44
02BA:  CLRF   x43
....................     if (rcount_TOUT == 3000) 
02BC:  MOVF   x45,W
02BE:  SUBLW  B8
02C0:  BNZ   02CC
02C2:  MOVF   x46,W
02C4:  SUBLW  0B
02C6:  BNZ   02CC
....................         rcount_TOUT = 0; 
02C8:  CLRF   x46
02CA:  CLRF   x45
....................  
....................     if (rcount == 3000) //15000)//50 la 1 giay/3000 la 1 phut, 15000 la 5 phut 
02CC:  MOVF   x3F,W
02CE:  SUBLW  B8
02D0:  BNZ   02E6
02D2:  MOVF   x40,W
02D4:  SUBLW  0B
02D6:  BNZ   02E6
....................     { 
....................         rcount = 0; 
02D8:  CLRF   x40
02DA:  CLRF   x3F
....................         rcount1 = 1; 
02DC:  MOVLW  01
02DE:  MOVWF  x47
....................         rcount3 = 1; 
02E0:  MOVWF  x49
....................         rcount4 = 1; 
02E2:  MOVWF  x48
....................         rcount5 = 1; 
02E4:  MOVWF  x4A
....................     } 
.................... } 
....................  
.................... // *********** Ngat Ngoai*********** // 
02E6:  BCF    F9E.0
02E8:  MOVLB  0
02EA:  GOTO   0078
.................... #INT_EXT // External interrupt ISR 
.................... void ext_isr() 
.................... { 
....................     delay_us(100); 
*
0314:  MOVLW  64
0316:  MOVLB  6
0318:  MOVWF  x08
031A:  MOVLB  0
031C:  RCALL  02EE
031E:  BCF    FF2.1
0320:  GOTO   0078
.................... } 
....................  
.................... // *********** HAM doc nhiet do do am DHT22 *********** // 
....................  
.................... void start_signal() 
.................... { 
....................     output_low(PIN_A5); 
*
671C:  BCF    F92.5
671E:  BCF    F89.5
....................     delay_ms(25); 
6720:  MOVLW  19
6722:  MOVLB  4
6724:  MOVWF  xBA
6726:  MOVLB  0
6728:  CALL   0482
....................     output_high(PIN_A5); 
672C:  BCF    F92.5
672E:  BSF    F89.5
....................     delay_us(30); 
6730:  MOVLW  77
6732:  MOVWF  00
6734:  DECFSZ 00,F
6736:  BRA    6734
6738:  BRA    673A
673A:  GOTO   683C (RETURN)
.................... } 
.................... short check_response() 
.................... { 
....................     delay_us(40); 
673E:  MOVLW  9F
6740:  MOVWF  00
6742:  DECFSZ 00,F
6744:  BRA    6742
6746:  BRA    6748
....................     if (!input(PIN_A5)) 
6748:  BSF    F92.5
674A:  BTFSC  F80.5
674C:  BRA    677A
....................     { // Read and test if connection pin is low 
....................         delay_us(80); 
674E:  CLRF   19
6750:  BTFSC  FF2.7
6752:  BSF    19.7
6754:  BCF    FF2.7
6756:  MOVLW  50
6758:  MOVLB  6
675A:  MOVWF  x08
675C:  MOVLB  0
675E:  CALL   02EE
6762:  BTFSC  19.7
6764:  BSF    FF2.7
....................         if (input(PIN_A5)) 
6766:  BSF    F92.5
6768:  BTFSS  F80.5
676A:  BRA    677A
....................         { // Read and test if connection pin is high 
....................             delay_us(50); 
676C:  MOVLW  C7
676E:  MOVWF  00
6770:  DECFSZ 00,F
6772:  BRA    6770
6774:  BRA    6776
....................             return 1; 
6776:  MOVLW  01
6778:  MOVWF  01
....................         } 
....................     } 
677A:  GOTO   683E (RETURN)
.................... } 
.................... unsigned int8 Read_Data() 
677E:  MOVLB  4
6780:  CLRF   xA3
.................... { 
....................     unsigned int8 i, k, _data = 0; // k is used to count 1 bit reading duration 
....................     if (Time_out) 
6782:  MOVLB  2
6784:  BTFSS  x20.3
6786:  BRA    6788
....................         break; 
....................     for (i = 0; i < 8; i++) 
6788:  MOVLB  4
678A:  CLRF   xA1
678C:  MOVF   xA1,W
678E:  SUBLW  07
6790:  BNC   682C
....................     { 
....................         k = 0; 
6792:  CLRF   xA2
....................         while (!input(PIN_A5)) 
6794:  BSF    F92.5
6796:  BTFSC  F80.5
6798:  BRA    67B6
....................         { // Wait until pin goes high 
....................             k++; 
679A:  INCF   xA2,F
....................             if (k > 100) 
679C:  MOVF   xA2,W
679E:  SUBLW  64
67A0:  BC    67AA
....................             { 
....................                 Time_out = 1; 
67A2:  MOVLB  2
67A4:  BSF    x20.3
....................                 break; 
67A6:  MOVLB  4
67A8:  BRA    67B6
....................             } 
....................             delay_us(1); 
67AA:  MOVLW  03
67AC:  MOVWF  00
67AE:  DECFSZ 00,F
67B0:  BRA    67AE
67B2:  BRA    67B4
67B4:  BRA    6794
....................         } 
....................         delay_us(30); 
67B6:  MOVLW  77
67B8:  MOVWF  00
67BA:  DECFSZ 00,F
67BC:  BRA    67BA
67BE:  BRA    67C0
....................         if (!input(PIN_A5)) 
67C0:  BSF    F92.5
67C2:  BTFSC  F80.5
67C4:  BRA    67E8
....................             bit_clear(_data, (7 - i)); // Clear bit (7 - i) 
67C6:  MOVLW  07
67C8:  BSF    FD8.0
67CA:  SUBFWB xA1,W
67CC:  MOVWF  xA4
67CE:  MOVLW  01
67D0:  MOVWF  00
67D2:  MOVF   xA4,W
67D4:  MOVWF  01
67D6:  BZ    67E0
67D8:  BCF    FD8.0
67DA:  RLCF   00,F
67DC:  DECFSZ 01,F
67DE:  BRA    67D8
67E0:  MOVF   00,W
67E2:  XORLW  FF
67E4:  ANDWF  xA3,F
67E6:  BRA    6828
....................         else 
....................         { 
....................             bit_set(_data, (7 - i)); // Set bit (7 - i) 
67E8:  MOVLW  07
67EA:  BSF    FD8.0
67EC:  SUBFWB xA1,W
67EE:  MOVWF  xA4
67F0:  MOVLW  01
67F2:  MOVWF  00
67F4:  MOVF   xA4,W
67F6:  MOVWF  01
67F8:  BZ    6802
67FA:  BCF    FD8.0
67FC:  RLCF   00,F
67FE:  DECFSZ 01,F
6800:  BRA    67FA
6802:  MOVF   00,W
6804:  IORWF  xA3,F
....................             while (input(PIN_A5)) 
6806:  BSF    F92.5
6808:  BTFSS  F80.5
680A:  BRA    6828
....................             { // Wait until pin goes low 
....................                 k++; 
680C:  INCF   xA2,F
....................                 if (k > 100) 
680E:  MOVF   xA2,W
6810:  SUBLW  64
6812:  BC    681C
....................                 { 
....................                     Time_out = 1; 
6814:  MOVLB  2
6816:  BSF    x20.3
....................                     break; 
6818:  MOVLB  4
681A:  BRA    6828
....................                 } 
....................                 delay_us(1); 
681C:  MOVLW  03
681E:  MOVWF  00
6820:  DECFSZ 00,F
6822:  BRA    6820
6824:  BRA    6826
6826:  BRA    6806
....................             } 
....................         } 
6828:  INCF   xA1,F
682A:  BRA    678C
....................     } 
....................     return _data; 
682C:  MOVFF  4A3,01
6830:  MOVLB  0
6832:  RETURN 0
.................... } 
....................  
.................... void docdht22() 
.................... { 
....................     //-----doc nhiet do - do am--------/ 
....................     //  delay_ms(1000); 
....................     Time_out = 0; 
6834:  MOVLB  2
6836:  BCF    x20.3
....................     start_signal(); 
6838:  MOVLB  0
683A:  BRA    671C
....................     if (check_response()) 
683C:  BRA    673E
683E:  MOVF   01,F
6840:  BZ    68F2
....................     {                           // If there is response from sensor 
....................         RH_byte1 = Read_Data(); // read RH byte1 
6842:  RCALL  677E
6844:  MOVFF  01,26E
....................         RH_byte2 = Read_Data(); // read RH byte2 
6848:  RCALL  677E
684A:  MOVFF  01,26F
....................         T_byte1 = Read_Data();  // read T byte1 
684E:  RCALL  677E
6850:  MOVFF  01,26C
....................         T_byte2 = Read_Data();  // read T byte2 
6854:  RCALL  677E
6856:  MOVFF  01,26D
....................         CheckSum = Read_Data(); // read checksum 
685A:  RCALL  677E
685C:  MOVFF  01,270
....................  
....................         if (Time_out) 
6860:  MOVLB  2
6862:  BTFSS  x20.3
6864:  BRA    6868
....................         { // If reading takes long time 
....................  
....................             //    fprintf(UART2,"\r\n\nTime out1!\r\n\n"); 
....................         } 
6866:  BRA    68F4
....................         else 
....................         { 
....................             if (CheckSum == ((RH_byte1 + RH_byte2 + T_byte1 + T_byte2) & 0xFF)) 
6868:  MOVF   x6F,W
686A:  ADDWF  x6E,W
686C:  ADDWF  x6C,W
686E:  ADDWF  x6D,W
6870:  SUBWF  x70,W
6872:  BNZ   68F4
....................             { 
....................                 RH = RH_byte1; 
6874:  CLRF   x6B
6876:  MOVFF  26E,26A
....................                 RH = (RH << 8) | RH_byte2; // lay nhiet do 
687A:  MOVFF  26A,26B
687E:  MOVLB  4
6880:  CLRF   xA1
6882:  MOVF   xA1,W
6884:  MOVLB  2
6886:  IORWF  x6F,W
6888:  MOVWF  x6A
688A:  MOVLB  2
....................  
....................                 Temp = T_byte1; 
688C:  CLRF   x69
688E:  MOVFF  26C,268
....................                 Temp = (Temp << 8) | T_byte2; // lay do am 
6892:  MOVFF  268,269
6896:  MOVLB  4
6898:  CLRF   xA1
689A:  MOVF   xA1,W
689C:  MOVLB  2
689E:  IORWF  x6D,W
68A0:  MOVWF  x68
68A2:  MOVLB  2
....................  
....................                 if (Temp > 0x8000) 
68A4:  MOVF   x69,W
68A6:  SUBLW  7F
68A8:  BC    68B6
68AA:  XORLW  FF
68AC:  BNZ   68B4
68AE:  MOVF   x68,W
68B0:  SUBLW  00
68B2:  BC    68B6
....................                 { 
....................  
....................                     Temp = Temp & 0x7FFF; 
68B4:  BCF    x69.7
....................                 } 
....................                 RH = RH / 10; 
68B6:  MOVFF  26B,4C0
68BA:  MOVFF  26A,4BF
68BE:  MOVLB  4
68C0:  CLRF   xC2
68C2:  MOVLW  0A
68C4:  MOVWF  xC1
68C6:  MOVLB  0
68C8:  CALL   53EC
68CC:  MOVFF  02,26B
68D0:  MOVFF  01,26A
....................                 Temp = Temp / 10; 
68D4:  MOVFF  269,4C0
68D8:  MOVFF  268,4BF
68DC:  MOVLB  4
68DE:  CLRF   xC2
68E0:  MOVLW  0A
68E2:  MOVWF  xC1
68E4:  MOVLB  0
68E6:  CALL   53EC
68EA:  MOVFF  02,269
68EE:  MOVFF  01,268
68F2:  MOVLB  2
....................             } 
....................         } 
....................     } 
68F4:  MOVLB  0
68F6:  GOTO   7000 (RETURN)
.................... } 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
.................... { 
....................     // fprintf(UART2,"\r\nMaking file '%s': ", fileName); 
....................     if (mk_file(fileName) != GOODEC) 
....................     { 
....................         //     fprintf(UART2,"Error creating file"); 
....................         return; 
....................     } 
....................     // fprintf(UART2,"OK"); 
.................... } 
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
.................... { 
....................     FILE stream; 
....................     //    fprintf(UART2,"\r\nAppending '%s' to '%s': ", appendString, fileName); 
....................     if (fatopen(fileName, "w", &stream) != GOODEC) 
....................     { 
....................         //  fprintf(UART2,"Error opening file '%s'",fileName); 
....................         return; 
....................     } 
....................  
....................     fatputs(appendString, &stream); 
....................     //  fatputs("\r\n", &stream); 
....................  
....................     if (fatclose(&stream) != GOODEC) 
....................     { 
....................         //     fprintf(UART2,"Error closing file"); 
....................         return; 
....................     } 
....................     //  fprintf(UART2,"OK"); 
.................... } 
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None.                               
.................... Example Usage: \> cd ftp/     -> /ftp/ 
.................... \ftp\> cd files/  -> /ftp/files/ 
.................... \ftp\files> cd..  -> /ftp/ 
.................... \ftp\> cd ..      -> / 
.................... \> cd /ftp/files/ -> /ftp/files/ 
....................  
....................  
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
.................... If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
....................  
.................... void PrintFile(char *fileName, int1 startFromEnd) 
.................... { 
....................     FILE stream; 
....................  
....................     if (fatopen(fileName, "r", &stream) != GOODEC) 
....................     { 
....................         printf("\r\nError opening file '%s'", fileName); 
....................         return; 
....................     } 
....................  
....................     fprintf(UART2, "\r\n"); 
....................  
....................     if (startFromEnd) 
....................         fatseek(&stream, 80, SEEK_END); 
....................  
....................     fatprintf(&stream); 
....................  
....................     // fatclose(&stream); 
....................     if (fatclose(&stream) != GOODEC) 
....................     { 
....................         printf("Error closing file '%s'", fileName); 
....................         return; 
....................     } 
.................... } 
....................  
.................... // *********** HAM kiem tra the nho *********** // 
.................... int1 checkthesd() 
*
100A:  MOVLB  4
100C:  CLRF   xA1
.................... { 
....................     //kiem tra the nho n lan, loi: return 0, thanh cong return 1. 
....................     unsigned int solan = 0; 
....................     int1 i; // pointer to the buffer 
....................     // delay_ms(1000); // cho on dinh de kiem tra the nho 
....................  
....................     //check the nho 
....................     do 
....................     { 
....................         i = fat_init(); 
100E:  MOVLB  0
1010:  BRA    0DB0
1012:  MOVLB  4
1014:  BCF    xA2.0
1016:  BTFSC  01.0
1018:  BSF    xA2.0
....................  
....................         if (i) 
101A:  BTFSS  xA2.0
101C:  BRA    102E
....................             fprintf(UART2, "No SD\n"); 
101E:  MOVLW  56
1020:  MOVWF  FF6
1022:  MOVLW  03
1024:  MOVWF  FF7
1026:  MOVLB  0
1028:  RCALL  0FE8
102A:  BRA    1036
102C:  MOVLB  4
....................         else 
....................             return 1; 
102E:  MOVLW  01
1030:  MOVWF  01
1032:  BRA    1058
1034:  MOVLB  0
....................         solan++; 
1036:  MOVLB  4
1038:  INCF   xA1,F
....................         delay_ms(1000);  // 
103A:  MOVLW  04
103C:  MOVWF  xA3
103E:  MOVLW  FA
1040:  MOVWF  xBA
1042:  MOVLB  0
1044:  CALL   0482
1048:  MOVLB  4
104A:  DECFSZ xA3,F
104C:  BRA    103E
....................     } while (solan < 5); //i =1: loi the nho, i = 0 : co the nho 
104E:  MOVF   xA1,W
1050:  SUBLW  04
1052:  BC    100E
....................  
....................     return 0; 
1054:  MOVLW  00
1056:  MOVWF  01
1058:  MOVLB  0
105A:  GOTO   6CE0 (RETURN)
....................  
....................     //check the nho ********** 
.................... } 
....................  
.................... // *********** HAM doc dien ap Acquy *********** // 
.................... void docadc() 
.................... { 
....................     set_adc_channel(0); 
*
4732:  MOVLW  00
4734:  MOVWF  01
4736:  MOVF   FC2,W
4738:  ANDLW  C3
473A:  IORWF  01,W
473C:  MOVWF  FC2
....................     power1 = read_adc(); 
473E:  BSF    FC2.1
4740:  BTFSC  FC2.1
4742:  BRA    4740
4744:  MOVFF  FC4,4CA
4748:  MOVFF  FC3,4C9
474C:  MOVLB  0
474E:  RCALL  44A8
4750:  MOVFF  03,23E
4754:  MOVFF  02,23D
4758:  MOVFF  01,23C
475C:  MOVFF  00,23B
....................     power1 = (((power1 * 5) / 20000) * 119); // (x*20000)/120000.............5 
4760:  MOVFF  23E,4CC
4764:  MOVFF  23D,4CB
4768:  MOVFF  23C,4CA
476C:  MOVFF  23B,4C9
4770:  MOVLB  4
4772:  CLRF   xD0
4774:  CLRF   xCF
4776:  MOVLW  20
4778:  MOVWF  xCE
477A:  MOVLW  81
477C:  MOVWF  xCD
477E:  MOVLB  0
4780:  RCALL  44DE
4782:  MOVFF  03,4A4
4786:  MOVFF  02,4A3
478A:  MOVFF  01,4A2
478E:  MOVFF  00,4A1
4792:  MOVFF  03,4CC
4796:  MOVFF  02,4CB
479A:  MOVFF  01,4CA
479E:  MOVFF  00,4C9
47A2:  MOVLB  4
47A4:  CLRF   xD0
47A6:  MOVLW  40
47A8:  MOVWF  xCF
47AA:  MOVLW  1C
47AC:  MOVWF  xCE
47AE:  MOVLW  8D
47B0:  MOVWF  xCD
47B2:  MOVLB  0
47B4:  RCALL  45D4
47B6:  MOVFF  03,4A4
47BA:  MOVFF  02,4A3
47BE:  MOVFF  01,4A2
47C2:  MOVFF  00,4A1
47C6:  MOVFF  03,4CC
47CA:  MOVFF  02,4CB
47CE:  MOVFF  01,4CA
47D2:  MOVFF  00,4C9
47D6:  MOVLB  4
47D8:  CLRF   xD0
47DA:  CLRF   xCF
47DC:  MOVLW  6E
47DE:  MOVWF  xCE
47E0:  MOVLW  85
47E2:  MOVWF  xCD
47E4:  MOVLB  0
47E6:  RCALL  44DE
47E8:  MOVFF  03,23E
47EC:  MOVFF  02,23D
47F0:  MOVFF  01,23C
47F4:  MOVFF  00,23B
47F8:  GOTO   6DB6 (RETURN)
....................                                              //adc  ........................1024  => x=(adc*5*120000)/1024*20000 
.................... } 
....................  
.................... // ********* Ham cai dat ngat va timer ********* // 
.................... void caidatngatvatimer() 
.................... { 
....................     //  Cai dat ngat va timer 
....................     enable_interrupts(INT_RDA);               //cho phep ngat uart 
*
04FE:  BSF    F9D.5
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_4); // Timer1 configuration 
0500:  MOVLW  A5
0502:  MOVWF  FCD
....................     //enable_interrupts(INT_EXT2_H2L);                 // Enable external interrupt 
....................     ext_int_edge(H_TO_L); 
0504:  BCF    FF1.6
....................     enable_interrupts(INT_EXT); //kich hoat ngat ngoai 
0506:  BSF    FF2.4
....................  
....................     enable_interrupts(INT_TIMER1); 
0508:  BSF    F9D.0
....................  
....................     setup_adc(ADC_CLOCK_DIV_8);  // Set ADC conversion time to 8Tosc 
050A:  MOVF   FC0,W
050C:  ANDLW  C0
050E:  IORLW  01
0510:  MOVWF  FC0
0512:  BSF    FC0.7
0514:  BSF    FC2.0
....................     setup_adc_ports(AN0_TO_AN2); // Configure AN0 as analog input SETUP_ADC_PORTS(AN0_TO_AN1); 
0516:  MOVF   FC1,W
0518:  ANDLW  C0
051A:  IORLW  0C
051C:  MOVWF  FC1
....................                                  // set_adc_channel(0); 
....................     //** 
....................     enable_interrupts(GLOBAL); //cho phep ngat toan cuc 
051E:  MOVLW  C0
0520:  IORWF  FF2,F
0522:  GOTO   6CD6 (RETURN)
.................... } 
....................  
.................... void tachdl2(FILE *stream) 
.................... { 
....................     char docurl[100] = ""; 
*
348E:  MOVLB  4
3490:  CLRF   xE3
....................     char chuoitam[100] = ""; 
3492:  MOVLB  5
3494:  CLRF   x47
....................     unsigned int dodaichuoi; 
....................     signed int ch; // character read in 
....................     // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................     do 
....................     { 
....................         ch = fatgetc(stream); 
3496:  MOVFF  4E2,5AE
349A:  MOVFF  4E1,5AD
349E:  MOVLB  0
34A0:  BRA    32D0
34A2:  MOVFF  01,5AC
....................         if ((ch > 32) && (ch < 127)) // 32 - 126 la nhung ky tu in duoc// 32 - 126 la nhung ky tu in duoc 
34A6:  MOVLB  5
34A8:  BTFSC  xAC.7
34AA:  BRA    3500
34AC:  MOVF   xAC,W
34AE:  SUBLW  20
34B0:  BC    3500
34B2:  MOVF   xAC,W
34B4:  SUBLW  7F
34B6:  BZ    3500
....................         { 
....................             sprintf(chuoitam, "%s%c", docurl, ch); 
34B8:  MOVLW  05
34BA:  MOVLB  2
34BC:  MOVWF  x3A
34BE:  MOVLW  47
34C0:  MOVWF  x39
34C2:  MOVFF  23A,FEA
34C6:  MOVFF  239,FE9
34CA:  CLRF   FEF
34CC:  MOVLW  04
34CE:  MOVWF  FEA
34D0:  MOVLW  E3
34D2:  MOVWF  FE9
34D4:  MOVLB  0
34D6:  RCALL  3408
34D8:  MOVFF  5AC,5AF
34DC:  RCALL  33E6
....................             sprintf(docurl, "%s", chuoitam); 
34DE:  MOVLW  04
34E0:  MOVLB  2
34E2:  MOVWF  x3A
34E4:  MOVLW  E3
34E6:  MOVWF  x39
34E8:  MOVFF  23A,FEA
34EC:  MOVFF  239,FE9
34F0:  CLRF   FEF
34F2:  MOVLW  05
34F4:  MOVWF  FEA
34F6:  MOVLW  47
34F8:  MOVWF  FE9
34FA:  MOVLB  0
34FC:  RCALL  3408
34FE:  MOVLB  5
....................         } 
....................     } while (ch != EOF); 
3500:  MOVF   xAC,W
3502:  SUBLW  FF
3504:  BNZ   3496
....................     dodaichuoi = strlen(docurl); 
3506:  MOVLW  04
3508:  MOVWF  xAE
350A:  MOVLW  E3
350C:  MOVWF  xAD
350E:  MOVLB  0
3510:  CALL   105E
3514:  MOVFF  01,5AB
....................     eeprom_write_string(0x04, docurl); 
3518:  MOVLW  04
351A:  MOVLB  5
351C:  MOVWF  xAD
351E:  MOVWF  xAF
3520:  MOVLW  E3
3522:  MOVWF  xAE
3524:  MOVLB  0
3526:  BRA    342C
....................     write_eeprom(0xA0, dodaichuoi); 
3528:  MOVF   FF2,W
352A:  MOVWF  00
352C:  BCF    FF2.7
352E:  MOVLW  A0
3530:  MOVWF  FA9
3532:  MOVFF  5AB,FA8
3536:  BCF    FA6.6
3538:  BCF    FA6.7
353A:  BSF    FA6.2
353C:  MOVLB  F
353E:  MOVLW  55
3540:  MOVWF  FA7
3542:  MOVLW  AA
3544:  MOVWF  FA7
3546:  BSF    FA6.1
3548:  BTFSC  FA6.1
354A:  BRA    3548
354C:  BCF    FA6.2
354E:  MOVF   00,W
3550:  IORWF  FF2,F
3552:  MOVLB  0
3554:  GOTO   3A54 (RETURN)
.................... } 
....................  
.................... void PrintURL(char *fileName) 
.................... { 
....................     FILE stream; 
....................     if (fatopen(fileName, "r", &stream) != GOODEC) 
*
3A1A:  MOVLW  72
3A1C:  MOVLB  4
3A1E:  MOVWF  xDF
3A20:  CLRF   xE0
3A22:  MOVFF  4A4,4E4
3A26:  MOVFF  4A3,4E3
3A2A:  MOVLW  04
3A2C:  MOVWF  xE6
3A2E:  MOVLW  DF
3A30:  MOVWF  xE5
3A32:  MOVLW  04
3A34:  MOVWF  xE8
3A36:  MOVLW  A5
3A38:  MOVWF  xE7
3A3A:  MOVLB  0
3A3C:  GOTO   2F26
3A40:  MOVF   01,F
3A42:  BZ    3A46
....................         return; 
3A44:  BRA    3A74
....................     tachdl2(&stream); 
3A46:  MOVLW  04
3A48:  MOVLB  4
3A4A:  MOVWF  xE2
3A4C:  MOVLW  A5
3A4E:  MOVWF  xE1
3A50:  MOVLB  0
3A52:  BRA    348E
....................     fatclose(&stream); 
3A54:  MOVLW  04
3A56:  MOVLB  4
3A58:  MOVWF  xE2
3A5A:  MOVLW  A5
3A5C:  MOVWF  xE1
3A5E:  MOVLB  0
3A60:  RCALL  36F4
....................  
....................     if (fatclose(&stream) != GOODEC) 
3A62:  MOVLW  04
3A64:  MOVLB  4
3A66:  MOVWF  xE2
3A68:  MOVLW  A5
3A6A:  MOVWF  xE1
3A6C:  MOVLB  0
3A6E:  RCALL  36F4
3A70:  MOVF   01,F
3A72:  BZ    3A74
....................         return; 
3A74:  GOTO   6D1E (RETURN)
.................... } 
.................... void tachdl3(FILE *stream) 
.................... { 
....................     char docurl[4] = ""; 
....................     char chuoitam[4] = ""; 
....................     // unsigned int dodaichuoi; 
....................     signed int ch; // character read in 
....................  
....................     // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................     do 
....................     { 
....................         ch = fatgetc(stream); 
....................         if ((ch > 32) && (ch < 127)) // 32 - 126 la nhung ky tu in duoc// 32 - 126 la nhung ky tu in duoc 
....................         { 
....................             sprintf(chuoitam, "%s%c", docurl, ch); 
....................             sprintf(docurl, "%s", chuoitam); 
....................         } 
....................     } while (ch != EOF); 
....................     //  dodaichuoi = strlen(docurl); 
....................     // fprintf(UART2,"Ghi %s - do dai:%u vao bo nho\n",docurl,dodaichuoi); 
....................     //  eeprom_write_string(0x74,docurl); 
....................     // write_eeprom(0xB0,dodaichuoi); 
.................... } 
....................  
.................... void PrintURL1(char *fileName) 
.................... { 
....................  
....................     FILE stream; 
....................  
....................     if (fatopen(fileName, "r", &stream) != GOODEC) 
....................     { 
....................         // fprintf(UART2,"\r\nKhong ton tai '%s'- lay phone cu",fileName); 
....................         return; 
....................     } 
....................  
....................     //printf("\r\n"); 
....................  
....................     //if(startFromEnd) 
....................     //fatseek(&stream, 80, SEEK_END); 
....................  
....................     //fatprintf(&stream); 
....................     tachdl3(&stream); 
....................     // fatclose(&stream); 
....................  
....................     // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................  
....................     fatclose(&stream); 
....................  
....................     if (fatclose(&stream) != GOODEC) 
....................     { 
....................         //fprintf(UART2,"Error closing file '%s'",fileName); 
....................         return; 
....................     } 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... char docduoc[20]; 
....................  
.................... // *********** BAUD 9600 *********** // 
.................... int read_rs485(unsigned char *str, unsigned int len) 
*
4BB8:  MOVLB  4
4BBA:  CLRF   xC8
.................... { 
....................     int kt485 = 0; // kiem tra = 0 : loi do timeout , kiem tra = 1 : OK, kiem tra = 2: loi do break 
....................  
....................     rcount2 = 0; 
4BBC:  MOVLB  2
4BBE:  CLRF   x42
4BC0:  CLRF   x41
....................     unsigned int i; 
....................     //= char doc; 
....................     while ((!kbhit(COM2)) && (rcount2 < 100)) 
4BC2:  BTFSS  F83.5
4BC4:  BRA    4BD2
4BC6:  MOVF   x42,F
4BC8:  BNZ   4BD2
4BCA:  MOVF   x41,W
4BCC:  SUBLW  63
4BCE:  BNC   4BD2
....................     { 
4BD0:  BRA    4BC2
....................         // delay_us(10); 
....................     } 
....................     if (rcount2 < 100) 
4BD2:  MOVF   x42,F
4BD4:  BNZ   4C3C
4BD6:  MOVF   x41,W
4BD8:  SUBLW  63
4BDA:  BNC   4C3C
....................     { 
....................         for (i = 0; i < len; i++) 
4BDC:  MOVLB  4
4BDE:  CLRF   xC9
4BE0:  MOVF   xC7,W
4BE2:  SUBWF  xC9,W
4BE4:  BC    4C2C
....................         { 
....................             if (rcount2 > 100) 
4BE6:  MOVLB  2
4BE8:  MOVF   x42,F
4BEA:  BNZ   4BF2
4BEC:  MOVF   x41,W
4BEE:  SUBLW  64
4BF0:  BC    4BFC
....................             { 
....................                 kt485 = 2; 
4BF2:  MOVLW  02
4BF4:  MOVLB  4
4BF6:  MOVWF  xC8
....................                 break; 
4BF8:  BRA    4C2C
4BFA:  MOVLB  2
....................             } 
....................  
....................             str[i] = fgetc(COM2); 
4BFC:  MOVLB  4
4BFE:  MOVF   xC9,W
4C00:  ADDWF  xC5,W
4C02:  MOVWF  FE9
4C04:  MOVLW  00
4C06:  ADDWFC xC6,W
4C08:  MOVWF  FEA
4C0A:  MOVFF  FEA,4CD
4C0E:  MOVFF  FE9,4CC
4C12:  MOVLB  0
4C14:  BRA    4B5A
4C16:  MOVFF  4CD,FEA
4C1A:  MOVFF  4CC,FE9
4C1E:  MOVFF  01,FEF
....................  
....................             kt485 = 1; 
4C22:  MOVLW  01
4C24:  MOVLB  4
4C26:  MOVWF  xC8
4C28:  INCF   xC9,F
4C2A:  BRA    4BE0
....................         } 
....................         //!      fprintf(UART2,"Doc Xong : "); 
....................  
....................         str[len] = 0; 
4C2C:  MOVF   xC7,W
4C2E:  ADDWF  xC5,W
4C30:  MOVWF  FE9
4C32:  MOVLW  00
4C34:  ADDWFC xC6,W
4C36:  MOVWF  FEA
4C38:  CLRF   FEF
4C3A:  MOVLB  2
....................     } 
....................     //fprintf(UART2,"kt:%u\n",kt); 
....................     return kt485; 
4C3C:  MOVLB  4
4C3E:  MOVFF  4C8,01
4C42:  MOVLB  0
4C44:  RETURN 0
.................... } 
....................  
.................... // *********** BAUD 4800 *********** // 
.................... int read_rs485_4800(unsigned char *str, unsigned int len) 
*
4CA6:  MOVLB  4
4CA8:  CLRF   xC8
.................... { 
....................     int kt485 = 0; // kiem tra = 0 : loi do timeout , kiem tra = 1 : OK, kiem tra = 2: loi do break 
....................     rcount2 = 0; 
4CAA:  MOVLB  2
4CAC:  CLRF   x42
4CAE:  CLRF   x41
....................     unsigned int i; 
....................     //= char doc; 
....................     while ((!kbhit(COM3)) && (rcount2 < 100)) 
4CB0:  BTFSS  F83.5
4CB2:  BRA    4CC0
4CB4:  MOVF   x42,F
4CB6:  BNZ   4CC0
4CB8:  MOVF   x41,W
4CBA:  SUBLW  63
4CBC:  BNC   4CC0
....................     { 
4CBE:  BRA    4CB0
....................         // delay_us(10); 
....................     } 
....................     if (rcount2 < 100) 
4CC0:  MOVF   x42,F
4CC2:  BNZ   4D2A
4CC4:  MOVF   x41,W
4CC6:  SUBLW  63
4CC8:  BNC   4D2A
....................     { 
....................         for (i = 0; i < len; i++) 
4CCA:  MOVLB  4
4CCC:  CLRF   xC9
4CCE:  MOVF   xC7,W
4CD0:  SUBWF  xC9,W
4CD2:  BC    4D1A
....................         { 
....................             if (rcount2 > 100) 
4CD4:  MOVLB  2
4CD6:  MOVF   x42,F
4CD8:  BNZ   4CE0
4CDA:  MOVF   x41,W
4CDC:  SUBLW  64
4CDE:  BC    4CEA
....................             { 
....................                 kt485 = 2; 
4CE0:  MOVLW  02
4CE2:  MOVLB  4
4CE4:  MOVWF  xC8
....................                 break; 
4CE6:  BRA    4D1A
4CE8:  MOVLB  2
....................             } 
....................  
....................             str[i] = fgetc(COM3); 
4CEA:  MOVLB  4
4CEC:  MOVF   xC9,W
4CEE:  ADDWF  xC5,W
4CF0:  MOVWF  FE9
4CF2:  MOVLW  00
4CF4:  ADDWFC xC6,W
4CF6:  MOVWF  FEA
4CF8:  MOVFF  FEA,4CD
4CFC:  MOVFF  FE9,4CC
4D00:  MOVLB  0
4D02:  BRA    4C46
4D04:  MOVFF  4CD,FEA
4D08:  MOVFF  4CC,FE9
4D0C:  MOVFF  01,FEF
....................  
....................             kt485 = 1; 
4D10:  MOVLW  01
4D12:  MOVLB  4
4D14:  MOVWF  xC8
4D16:  INCF   xC9,F
4D18:  BRA    4CCE
....................         } 
....................         //!      fprintf(UART2,"Doc Xong : "); 
....................  
....................         str[len] = 0; 
4D1A:  MOVF   xC7,W
4D1C:  ADDWF  xC5,W
4D1E:  MOVWF  FE9
4D20:  MOVLW  00
4D22:  ADDWFC xC6,W
4D24:  MOVWF  FEA
4D26:  CLRF   FEF
4D28:  MOVLB  2
....................     } 
....................     //fprintf(UART2,"kt:%u\n",kt); 
....................     return kt485; 
4D2A:  MOVLB  4
4D2C:  MOVFF  4C8,01
4D30:  MOVLB  0
4D32:  GOTO   5150 (RETURN)
.................... } 
....................  
.................... // *********** HAM GUI RS485 *********** // 
.................... // char a[8] = {0x01,0x06,0x01,0x00,0x00,0x03,0xC8,0x37}; 
.................... // set address 01 06 01 00 00 02 checksum 
.................... void send_hamSO2() 
.................... { 
....................     char a[8] = {0x04, 0x03, 0x00, 0x06, 0x00, 0x01, 0x64, 0x5E}; 
*
48C8:  MOVLW  04
48CA:  MOVLB  4
48CC:  MOVWF  xC5
48CE:  MOVLW  03
48D0:  MOVWF  xC6
48D2:  CLRF   xC7
48D4:  MOVLW  06
48D6:  MOVWF  xC8
48D8:  CLRF   xC9
48DA:  MOVLW  01
48DC:  MOVWF  xCA
48DE:  MOVLW  64
48E0:  MOVWF  xCB
48E2:  MOVLW  5E
48E4:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
48E6:  CLRF   xCD
48E8:  MOVF   xCD,W
48EA:  SUBLW  07
48EC:  BNC   490A
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
48EE:  CLRF   03
48F0:  MOVF   xCD,W
48F2:  ADDLW  C5
48F4:  MOVWF  FE9
48F6:  MOVLW  04
48F8:  ADDWFC 03,W
48FA:  MOVWF  FEA
48FC:  MOVFF  FEF,4CF
4900:  MOVLB  0
4902:  RCALL  4876
4904:  MOVLB  4
4906:  INCF   xCD,F
4908:  BRA    48E8
....................     } 
490A:  MOVLB  0
490C:  GOTO   50A0 (RETURN)
.................... } 
.................... void send_hamNO2() 
.................... { 
....................     char a[8] = {0x03, 0x03, 0x00, 0x06, 0x00, 0x01, 0x65, 0xE9}; 
4910:  MOVLW  03
4912:  MOVLB  4
4914:  MOVWF  xC5
4916:  MOVWF  xC6
4918:  CLRF   xC7
491A:  MOVLW  06
491C:  MOVWF  xC8
491E:  CLRF   xC9
4920:  MOVLW  01
4922:  MOVWF  xCA
4924:  MOVLW  65
4926:  MOVWF  xCB
4928:  MOVLW  E9
492A:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
492C:  CLRF   xCD
492E:  MOVF   xCD,W
4930:  SUBLW  07
4932:  BNC   4950
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
4934:  CLRF   03
4936:  MOVF   xCD,W
4938:  ADDLW  C5
493A:  MOVWF  FE9
493C:  MOVLW  04
493E:  ADDWFC 03,W
4940:  MOVWF  FEA
4942:  MOVFF  FEF,4CF
4946:  MOVLB  0
4948:  RCALL  4876
494A:  MOVLB  4
494C:  INCF   xCD,F
494E:  BRA    492E
....................     } 
4950:  MOVLB  0
4952:  GOTO   50B4 (RETURN)
.................... } 
.................... void send_hamCO() 
.................... { 
....................     char a[8] = {0x02, 0x03, 0x00, 0x06, 0x00, 0x01, 0x64, 0x38}; 
4956:  MOVLW  02
4958:  MOVLB  4
495A:  MOVWF  xC5
495C:  MOVLW  03
495E:  MOVWF  xC6
4960:  CLRF   xC7
4962:  MOVLW  06
4964:  MOVWF  xC8
4966:  CLRF   xC9
4968:  MOVLW  01
496A:  MOVWF  xCA
496C:  MOVLW  64
496E:  MOVWF  xCB
4970:  MOVLW  38
4972:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
4974:  CLRF   xCD
4976:  MOVF   xCD,W
4978:  SUBLW  07
497A:  BNC   4998
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
497C:  CLRF   03
497E:  MOVF   xCD,W
4980:  ADDLW  C5
4982:  MOVWF  FE9
4984:  MOVLW  04
4986:  ADDWFC 03,W
4988:  MOVWF  FEA
498A:  MOVFF  FEF,4CF
498E:  MOVLB  0
4990:  RCALL  4876
4992:  MOVLB  4
4994:  INCF   xCD,F
4996:  BRA    4976
....................     } 
4998:  MOVLB  0
499A:  GOTO   50CA (RETURN)
.................... } 
.................... void send_PM25() 
.................... { 
....................     char a[8] = {0x01, 0x03, 0x00, 0x04, 0x00, 0x02, 0x85, 0xCA}; 
499E:  MOVLW  01
49A0:  MOVLB  4
49A2:  MOVWF  xC5
49A4:  MOVLW  03
49A6:  MOVWF  xC6
49A8:  CLRF   xC7
49AA:  MOVLW  04
49AC:  MOVWF  xC8
49AE:  CLRF   xC9
49B0:  MOVLW  02
49B2:  MOVWF  xCA
49B4:  MOVLW  85
49B6:  MOVWF  xCB
49B8:  MOVLW  CA
49BA:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
49BC:  CLRF   xCD
49BE:  MOVF   xCD,W
49C0:  SUBLW  07
49C2:  BNC   49E0
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
49C4:  CLRF   03
49C6:  MOVF   xCD,W
49C8:  ADDLW  C5
49CA:  MOVWF  FE9
49CC:  MOVLW  04
49CE:  ADDWFC 03,W
49D0:  MOVWF  FEA
49D2:  MOVFF  FEF,4CF
49D6:  MOVLB  0
49D8:  RCALL  4876
49DA:  MOVLB  4
49DC:  INCF   xCD,F
49DE:  BRA    49BE
....................     } 
49E0:  MOVLB  0
49E2:  GOTO   5120 (RETURN)
.................... } 
.................... void send_PM10() 
.................... { 
....................     char a[8] = {0x01, 0x03, 0x00, 0x09, 0x00, 0x02, 0x14, 0x09}; 
49E6:  MOVLW  01
49E8:  MOVLB  4
49EA:  MOVWF  xC5
49EC:  MOVLW  03
49EE:  MOVWF  xC6
49F0:  CLRF   xC7
49F2:  MOVLW  09
49F4:  MOVWF  xC8
49F6:  CLRF   xC9
49F8:  MOVLW  02
49FA:  MOVWF  xCA
49FC:  MOVLW  14
49FE:  MOVWF  xCB
4A00:  MOVLW  09
4A02:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
4A04:  CLRF   xCD
4A06:  MOVF   xCD,W
4A08:  SUBLW  07
4A0A:  BNC   4A28
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
4A0C:  CLRF   03
4A0E:  MOVF   xCD,W
4A10:  ADDLW  C5
4A12:  MOVWF  FE9
4A14:  MOVLW  04
4A16:  ADDWFC 03,W
4A18:  MOVWF  FEA
4A1A:  MOVFF  FEF,4CF
4A1E:  MOVLB  0
4A20:  RCALL  4876
4A22:  MOVLB  4
4A24:  INCF   xCD,F
4A26:  BRA    4A06
....................     } 
4A28:  MOVLB  0
4A2A:  GOTO   5120 (RETURN)
.................... } 
.................... void send_LUX() 
.................... { 
....................     char a[8] = {0x01, 0x03, 0x00, 0x08, 0x00, 0x02, 0x45, 0xC9}; 
4A2E:  MOVLW  01
4A30:  MOVLB  4
4A32:  MOVWF  xC5
4A34:  MOVLW  03
4A36:  MOVWF  xC6
4A38:  CLRF   xC7
4A3A:  MOVLW  08
4A3C:  MOVWF  xC8
4A3E:  CLRF   xC9
4A40:  MOVLW  02
4A42:  MOVWF  xCA
4A44:  MOVLW  45
4A46:  MOVWF  xCB
4A48:  MOVLW  C9
4A4A:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
4A4C:  CLRF   xCD
4A4E:  MOVF   xCD,W
4A50:  SUBLW  07
4A52:  BNC   4A70
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
4A54:  CLRF   03
4A56:  MOVF   xCD,W
4A58:  ADDLW  C5
4A5A:  MOVWF  FE9
4A5C:  MOVLW  04
4A5E:  ADDWFC 03,W
4A60:  MOVWF  FEA
4A62:  MOVFF  FEF,4CF
4A66:  MOVLB  0
4A68:  RCALL  4876
4A6A:  MOVLB  4
4A6C:  INCF   xCD,F
4A6E:  BRA    4A4E
....................     } 
4A70:  MOVLB  0
4A72:  GOTO   5120 (RETURN)
.................... } 
.................... void send_Noise() 
.................... { 
....................     char a[8] = {0x01, 0x03, 0x00, 0x0C, 0x00, 0x02, 0x04, 0x08}; 
4A76:  MOVLW  01
4A78:  MOVLB  4
4A7A:  MOVWF  xC5
4A7C:  MOVLW  03
4A7E:  MOVWF  xC6
4A80:  CLRF   xC7
4A82:  MOVLW  0C
4A84:  MOVWF  xC8
4A86:  CLRF   xC9
4A88:  MOVLW  02
4A8A:  MOVWF  xCA
4A8C:  MOVLW  04
4A8E:  MOVWF  xCB
4A90:  MOVLW  08
4A92:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
4A94:  CLRF   xCD
4A96:  MOVF   xCD,W
4A98:  SUBLW  07
4A9A:  BNC   4AB8
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
4A9C:  CLRF   03
4A9E:  MOVF   xCD,W
4AA0:  ADDLW  C5
4AA2:  MOVWF  FE9
4AA4:  MOVLW  04
4AA6:  ADDWFC 03,W
4AA8:  MOVWF  FEA
4AAA:  MOVFF  FEF,4CF
4AAE:  MOVLB  0
4AB0:  RCALL  4876
4AB2:  MOVLB  4
4AB4:  INCF   xCD,F
4AB6:  BRA    4A96
....................     } 
4AB8:  MOVLB  0
4ABA:  GOTO   5120 (RETURN)
.................... } 
.................... void send_Wind() 
.................... { 
....................     char a[8] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x0B}; 
*
4B14:  MOVLW  01
4B16:  MOVLB  4
4B18:  MOVWF  xC5
4B1A:  MOVLW  03
4B1C:  MOVWF  xC6
4B1E:  CLRF   xC7
4B20:  CLRF   xC8
4B22:  CLRF   xC9
4B24:  MOVLW  02
4B26:  MOVWF  xCA
4B28:  MOVLW  C4
4B2A:  MOVWF  xCB
4B2C:  MOVLW  0B
4B2E:  MOVWF  xCC
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
4B30:  CLRF   xCD
4B32:  MOVF   xCD,W
4B34:  SUBLW  07
4B36:  BNC   4B54
....................     { 
....................         fprintf(COM3, "%c", a[ll]); 
4B38:  CLRF   03
4B3A:  MOVF   xCD,W
4B3C:  ADDLW  C5
4B3E:  MOVWF  FE9
4B40:  MOVLW  04
4B42:  ADDWFC 03,W
4B44:  MOVWF  FEA
4B46:  MOVFF  FEF,4CF
4B4A:  MOVLB  0
4B4C:  BRA    4ABE
4B4E:  MOVLB  4
4B50:  INCF   xCD,F
4B52:  BRA    4B32
....................     } 
4B54:  MOVLB  0
4B56:  GOTO   5120 (RETURN)
.................... } 
.................... void send_Temp_Humi() 
.................... { 
....................     char a[8] = {0xff, 0x03, 0x00, 0x00, 0x00, 0x02, 0xD1, 0xD5}; 
*
57B8:  MOVLB  4
57BA:  SETF   xC3
57BC:  MOVLW  03
57BE:  MOVWF  xC4
57C0:  CLRF   xC5
57C2:  CLRF   xC6
57C4:  CLRF   xC7
57C6:  MOVLW  02
57C8:  MOVWF  xC8
57CA:  MOVLW  D1
57CC:  MOVWF  xC9
57CE:  MOVLW  D5
57D0:  MOVWF  xCA
....................     int ll; 
....................     for (ll = 0; ll < 8; ll++) 
57D2:  CLRF   xCB
57D4:  MOVF   xCB,W
57D6:  SUBLW  07
57D8:  BNC   57F8
....................     { 
....................         fprintf(COM2, "%c", a[ll]); 
57DA:  CLRF   03
57DC:  MOVF   xCB,W
57DE:  ADDLW  C3
57E0:  MOVWF  FE9
57E2:  MOVLW  04
57E4:  ADDWFC 03,W
57E6:  MOVWF  FEA
57E8:  MOVFF  FEF,4CF
57EC:  MOVLB  0
57EE:  CALL   4876
57F2:  MOVLB  4
57F4:  INCF   xCB,F
57F6:  BRA    57D4
....................     } 
57F8:  MOVLB  0
57FA:  GOTO   5818 (RETURN)
.................... } 
....................  
.................... // *********** KET QUA DOC CAM BIEN RS485 *********** // 
.................... float _ketquars485(int id_sensor) 
*
5076:  MOVLB  4
5078:  CLRF   xB5
.................... { 
....................     int check = 0; 
.................... repead: 
....................     unsigned int16 ppm = 0; 
....................     int kiemtra = 0; 
....................     float ketqua = 0, ketqua1 = 0, ketqua2 = 0; 
507A:  CLRF   xB7
507C:  CLRF   xB6
507E:  CLRF   xB8
5080:  CLRF   xBC
5082:  CLRF   xBB
5084:  CLRF   xBA
5086:  CLRF   xB9
5088:  CLRF   xC0
508A:  CLRF   xBF
508C:  CLRF   xBE
508E:  CLRF   xBD
5090:  CLRF   xC4
5092:  CLRF   xC3
5094:  CLRF   xC2
5096:  CLRF   xC1
....................     if (id_sensor == 0) 
5098:  MOVF   xB4,F
509A:  BNZ   50AC
....................     { 
....................         send_hamSO2(); 
509C:  MOVLB  0
509E:  BRA    48C8
....................         ppm = 2857; 
50A0:  MOVLW  0B
50A2:  MOVLB  4
50A4:  MOVWF  xB7
50A6:  MOVLW  29
50A8:  MOVWF  xB6
....................     } 
50AA:  BRA    5122
....................     else if (id_sensor == 1) 
50AC:  DECFSZ xB4,W
50AE:  BRA    50C0
....................     { 
....................         send_hamNO2(); 
50B0:  MOVLB  0
50B2:  BRA    4910
....................         ppm = 2050; 
50B4:  MOVLW  08
50B6:  MOVLB  4
50B8:  MOVWF  xB7
50BA:  MOVLW  02
50BC:  MOVWF  xB6
....................     } 
50BE:  BRA    5122
....................     else if (id_sensor == 2) 
50C0:  MOVF   xB4,W
50C2:  SUBLW  02
50C4:  BNZ   50D6
....................     { 
....................         send_hamCO(); 
50C6:  MOVLB  0
50C8:  BRA    4956
....................         ppm = 1250; 
50CA:  MOVLW  04
50CC:  MOVLB  4
50CE:  MOVWF  xB7
50D0:  MOVLW  E2
50D2:  MOVWF  xB6
....................     } 
50D4:  BRA    5122
....................     else if (id_sensor == 3) 
50D6:  MOVF   xB4,W
50D8:  SUBLW  03
50DA:  BNZ   50E6
....................         send_PM25(); 
50DC:  MOVLB  0
50DE:  BRA    499E
50E0:  MOVLB  0
50E2:  BRA    5120
50E4:  MOVLB  4
....................     else if (id_sensor == 4) 
50E6:  MOVF   xB4,W
50E8:  SUBLW  04
50EA:  BNZ   50F6
....................         send_PM10(); 
50EC:  MOVLB  0
50EE:  BRA    49E6
50F0:  MOVLB  0
50F2:  BRA    5120
50F4:  MOVLB  4
....................     else if (id_sensor == 5) 
50F6:  MOVF   xB4,W
50F8:  SUBLW  05
50FA:  BNZ   5106
....................         send_LUX(); 
50FC:  MOVLB  0
50FE:  BRA    4A2E
5100:  MOVLB  0
5102:  BRA    5120
5104:  MOVLB  4
....................     else if (id_sensor == 6) 
5106:  MOVF   xB4,W
5108:  SUBLW  06
510A:  BNZ   5116
....................         send_Noise(); 
510C:  MOVLB  0
510E:  BRA    4A76
5110:  MOVLB  0
5112:  BRA    5120
5114:  MOVLB  4
....................     else if (id_sensor == 7) 
5116:  MOVF   xB4,W
5118:  SUBLW  07
511A:  BNZ   5122
....................         send_Wind(); 
511C:  MOVLB  0
511E:  BRA    4B14
5120:  MOVLB  4
....................  
....................     if (id_sensor != 7) 
5122:  MOVF   xB4,W
5124:  SUBLW  07
5126:  BZ    5140
....................         kiemtra = read_rs485(docduoc, 7); 
5128:  MOVLW  04
512A:  MOVWF  xC6
512C:  MOVLW  80
512E:  MOVWF  xC5
5130:  MOVLW  07
5132:  MOVWF  xC7
5134:  MOVLB  0
5136:  RCALL  4BB8
5138:  MOVFF  01,4B8
513C:  BRA    5154
513E:  MOVLB  4
....................     else  
....................         kiemtra = read_rs485_4800(docduoc, 7); 
5140:  MOVLW  04
5142:  MOVWF  xC6
5144:  MOVLW  80
5146:  MOVWF  xC5
5148:  MOVLW  07
514A:  MOVWF  xC7
514C:  MOVLB  0
514E:  BRA    4CA6
5150:  MOVFF  01,4B8
....................     //!           fprintf(UART2,"%x,%x,%x,%x,%x,%x,%x\n",docduoc[0],docduoc[1],docduoc[2],docduoc[3],docduoc[4],docduoc[5],docduoc[6]); 
....................     if (kiemtra == 1 && docduoc[0] == diachi1[id_sensor] && docduoc[1] == diachi2[id_sensor]) 
5154:  MOVLB  4
5156:  DECFSZ xB8,W
5158:  BRA    5396
515A:  CLRF   03
515C:  MOVF   xB4,W
515E:  ADDLW  52
5160:  MOVWF  FE9
5162:  MOVLW  02
5164:  ADDWFC 03,W
5166:  MOVWF  FEA
5168:  MOVF   FEF,W
516A:  SUBWF  x80,W
516C:  BTFSS  FD8.2
516E:  BRA    5396
5170:  CLRF   03
5172:  MOVF   xB4,W
5174:  ADDLW  5A
5176:  MOVWF  FE9
5178:  MOVLW  02
517A:  ADDWFC 03,W
517C:  MOVWF  FEA
517E:  MOVF   FEF,W
5180:  SUBWF  x81,W
5182:  BTFSS  FD8.2
5184:  BRA    5396
....................     { 
....................         kiemtra = 0; 
5186:  CLRF   xB8
....................         ketqua1 = ((docduoc[3] >> 4) * 4096) + ((docduoc[3] & 0x0F) * 256); 
5188:  SWAPF  x83,W
518A:  MOVWF  00
518C:  MOVLW  0F
518E:  ANDWF  00,F
5190:  MOVFF  00,4C7
5194:  CLRF   xCB
5196:  MOVFF  00,4CA
519A:  MOVLW  10
519C:  MOVWF  xCD
519E:  CLRF   xCC
51A0:  MOVLB  0
51A2:  CALL   0D32
51A6:  MOVFF  02,4C7
51AA:  MOVFF  01,4C6
51AE:  MOVLB  4
51B0:  MOVF   x83,W
51B2:  ANDLW  0F
51B4:  MOVWF  xC9
51B6:  CLRF   xCB
51B8:  MOVWF  xCA
51BA:  MOVLW  01
51BC:  MOVWF  xCD
51BE:  CLRF   xCC
51C0:  MOVLB  0
51C2:  CALL   0D32
51C6:  MOVFF  02,03
51CA:  MOVF   01,W
51CC:  MOVLB  4
51CE:  ADDWF  xC6,W
51D0:  MOVWF  01
51D2:  MOVF   xC7,W
51D4:  ADDWFC 03,F
51D6:  MOVFF  01,4C9
51DA:  MOVFF  03,4CA
51DE:  MOVLB  0
51E0:  CALL   44A8
51E4:  MOVFF  03,4C0
51E8:  MOVFF  02,4BF
51EC:  MOVFF  01,4BE
51F0:  MOVFF  00,4BD
....................         ketqua2 = ((docduoc[4] >> 4) * 16) + (docduoc[4] & 0x0F); 
51F4:  MOVLB  4
51F6:  SWAPF  x84,W
51F8:  MOVWF  00
51FA:  MOVLW  0F
51FC:  ANDWF  00,F
51FE:  MOVF   00,W
5200:  MULLW  10
5202:  MOVFF  FF3,4C6
5206:  MOVF   x84,W
5208:  ANDLW  0F
520A:  ADDWF  xC6,W
520C:  CLRF   xCA
520E:  MOVWF  xC9
5210:  MOVLB  0
5212:  CALL   44A8
5216:  MOVFF  03,4C4
521A:  MOVFF  02,4C3
521E:  MOVFF  01,4C2
5222:  MOVFF  00,4C1
....................         if (id_sensor < 3) 
5226:  MOVLB  4
5228:  MOVF   xB4,W
522A:  SUBLW  02
522C:  BNC   52DC
....................             ketqua = ((ketqua1 + ketqua2) * ppm) / 100; 
522E:  BCF    FD8.1
5230:  MOVFF  4C0,4CA
5234:  MOVFF  4BF,4C9
5238:  MOVFF  4BE,4C8
523C:  MOVFF  4BD,4C7
5240:  MOVFF  4C4,4CE
5244:  MOVFF  4C3,4CD
5248:  MOVFF  4C2,4CC
524C:  MOVFF  4C1,4CB
5250:  MOVLB  0
5252:  RCALL  4D36
5254:  MOVFF  03,4C8
5258:  MOVFF  02,4C7
525C:  MOVFF  01,4C6
5260:  MOVFF  00,4C5
5264:  MOVFF  4B7,4CA
5268:  MOVFF  4B6,4C9
526C:  CALL   44A8
5270:  MOVFF  4C8,4CC
5274:  MOVFF  4C7,4CB
5278:  MOVFF  4C6,4CA
527C:  MOVFF  4C5,4C9
5280:  MOVFF  03,4D0
5284:  MOVFF  02,4CF
5288:  MOVFF  01,4CE
528C:  MOVFF  00,4CD
5290:  CALL   44DE
5294:  MOVFF  03,4C8
5298:  MOVFF  02,4C7
529C:  MOVFF  01,4C6
52A0:  MOVFF  00,4C5
52A4:  MOVFF  03,4CC
52A8:  MOVFF  02,4CB
52AC:  MOVFF  01,4CA
52B0:  MOVFF  00,4C9
52B4:  MOVLB  4
52B6:  CLRF   xD0
52B8:  CLRF   xCF
52BA:  MOVLW  48
52BC:  MOVWF  xCE
52BE:  MOVLW  85
52C0:  MOVWF  xCD
52C2:  MOVLB  0
52C4:  CALL   45D4
52C8:  MOVFF  03,4BC
52CC:  MOVFF  02,4BB
52D0:  MOVFF  01,4BA
52D4:  MOVFF  00,4B9
52D8:  BRA    5392
52DA:  MOVLB  4
....................         else if (id_sensor >= 3 && id_sensor <= 7) 
52DC:  MOVF   xB4,W
52DE:  SUBLW  02
52E0:  BC    5394
52E2:  MOVF   xB4,W
52E4:  SUBLW  07
52E6:  BNC   5394
....................         { 
....................             if (id_sensor != 6) 
52E8:  MOVF   xB4,W
52EA:  SUBLW  06
52EC:  BZ    5328
....................                 ketqua = ketqua1 + ketqua2; 
52EE:  BCF    FD8.1
52F0:  MOVFF  4C0,4CA
52F4:  MOVFF  4BF,4C9
52F8:  MOVFF  4BE,4C8
52FC:  MOVFF  4BD,4C7
5300:  MOVFF  4C4,4CE
5304:  MOVFF  4C3,4CD
5308:  MOVFF  4C2,4CC
530C:  MOVFF  4C1,4CB
5310:  MOVLB  0
5312:  RCALL  4D36
5314:  MOVFF  03,4BC
5318:  MOVFF  02,4BB
531C:  MOVFF  01,4BA
5320:  MOVFF  00,4B9
5324:  BRA    5392
5326:  MOVLB  4
....................             else  
....................                 ketqua = (ketqua1 + ketqua2) / 10; 
5328:  BCF    FD8.1
532A:  MOVFF  4C0,4CA
532E:  MOVFF  4BF,4C9
5332:  MOVFF  4BE,4C8
5336:  MOVFF  4BD,4C7
533A:  MOVFF  4C4,4CE
533E:  MOVFF  4C3,4CD
5342:  MOVFF  4C2,4CC
5346:  MOVFF  4C1,4CB
534A:  MOVLB  0
534C:  RCALL  4D36
534E:  MOVFF  03,4C8
5352:  MOVFF  02,4C7
5356:  MOVFF  01,4C6
535A:  MOVFF  00,4C5
535E:  MOVFF  03,4CC
5362:  MOVFF  02,4CB
5366:  MOVFF  01,4CA
536A:  MOVFF  00,4C9
536E:  MOVLB  4
5370:  CLRF   xD0
5372:  CLRF   xCF
5374:  MOVLW  20
5376:  MOVWF  xCE
5378:  MOVLW  82
537A:  MOVWF  xCD
537C:  MOVLB  0
537E:  CALL   45D4
5382:  MOVFF  03,4BC
5386:  MOVFF  02,4BB
538A:  MOVFF  01,4BA
538E:  MOVFF  00,4B9
5392:  MOVLB  4
....................         } 
....................     } 
5394:  BRA    53D8
....................     else 
....................     { 
....................         check++; 
5396:  INCF   xB5,F
....................         // fprintf(UART2,"Check :  %d !!!\n",check); 
....................         if (check < 3) 
5398:  MOVF   xB5,W
539A:  SUBLW  02
539C:  BNC   53A2
....................             goto repead; 
539E:  BRA    507A
53A0:  BRA    53D8
....................         else 
....................             fprintf(UART2, "Loi Cam Bien %d !!!\n", id_sensor); 
53A2:  MOVLW  5E
53A4:  MOVWF  FF6
53A6:  MOVLW  03
53A8:  MOVWF  FF7
53AA:  MOVLW  0D
53AC:  MOVWF  xC5
53AE:  MOVLB  0
53B0:  CALL   3AD8
53B4:  MOVFF  4B4,4C5
53B8:  MOVLW  18
53BA:  MOVLB  4
53BC:  MOVWF  xC6
53BE:  MOVLB  0
53C0:  RCALL  4FAE
53C2:  MOVLW  6D
53C4:  MOVWF  FF6
53C6:  MOVLW  03
53C8:  MOVWF  FF7
53CA:  MOVLW  05
53CC:  MOVLB  4
53CE:  MOVWF  xC5
53D0:  MOVLB  0
53D2:  CALL   3AD8
53D6:  MOVLB  4
....................     } 
....................     return ketqua; 
53D8:  MOVFF  4B9,00
53DC:  MOVFF  4BA,01
53E0:  MOVFF  4BB,02
53E4:  MOVFF  4BC,03
53E8:  MOVLB  0
53EA:  RETURN 0
.................... } 
....................  
.................... // *********** KET QUA NHIET DO RS485 *********** // 
.................... float *_ketquars485_Temp_Humi(int id_sensor) 
*
57FE:  MOVLB  4
5800:  CLRF   xB1
.................... { 
....................     int check = 0; 
.................... repead: 
....................     int kiemtra = 0; 
....................     float ketqua1 = 0, ketqua2 = 0, Nhietdo_doam[2]; 
5802:  CLRF   xB2
5804:  CLRF   xB6
5806:  CLRF   xB5
5808:  CLRF   xB4
580A:  CLRF   xB3
580C:  CLRF   xBA
580E:  CLRF   xB9
5810:  CLRF   xB8
5812:  CLRF   xB7
....................     send_Temp_Humi(); 
5814:  MOVLB  0
5816:  BRA    57B8
....................     kiemtra = read_rs485(docduoc, 9); 
5818:  MOVLW  04
581A:  MOVLB  4
581C:  MOVWF  xC6
581E:  MOVLW  80
5820:  MOVWF  xC5
5822:  MOVLW  09
5824:  MOVWF  xC7
5826:  MOVLB  0
5828:  CALL   4BB8
582C:  MOVFF  01,4B2
....................     //!     fprintf(UART2,"%x,%x,%x,%x,%x,%x,%x,%x,%x\n",docduoc[0],docduoc[1],docduoc[2],docduoc[3],docduoc[4],docduoc[5],docduoc[6],docduoc[7],docduoc[8]); 
....................     if (kiemtra == 1 && docduoc[0] == 0xff && docduoc[1] == 0x03) 
5830:  MOVLB  4
5832:  DECFSZ xB2,W
5834:  BRA    5B30
5836:  INCFSZ x80,W
5838:  BRA    5B30
583A:  MOVF   x81,W
583C:  SUBLW  03
583E:  BTFSS  FD8.2
5840:  BRA    5B30
....................     { 
....................         kiemtra = 0; 
5842:  CLRF   xB2
....................         ketqua1 = ((docduoc[3] >> 4) * 4096) + ((docduoc[3] & 0x0F) * 256); 
5844:  SWAPF  x83,W
5846:  MOVWF  00
5848:  MOVLW  0F
584A:  ANDWF  00,F
584C:  MOVFF  00,4C5
5850:  CLRF   xCB
5852:  MOVFF  00,4CA
5856:  MOVLW  10
5858:  MOVWF  xCD
585A:  CLRF   xCC
585C:  MOVLB  0
585E:  CALL   0D32
5862:  MOVFF  02,4C5
5866:  MOVFF  01,4C4
586A:  MOVLB  4
586C:  MOVF   x83,W
586E:  ANDLW  0F
5870:  MOVWF  xC7
5872:  CLRF   xCB
5874:  MOVWF  xCA
5876:  MOVLW  01
5878:  MOVWF  xCD
587A:  CLRF   xCC
587C:  MOVLB  0
587E:  CALL   0D32
5882:  MOVFF  02,03
5886:  MOVF   01,W
5888:  MOVLB  4
588A:  ADDWF  xC4,W
588C:  MOVWF  01
588E:  MOVF   xC5,W
5890:  ADDWFC 03,F
5892:  MOVFF  01,4C9
5896:  MOVFF  03,4CA
589A:  MOVLB  0
589C:  CALL   44A8
58A0:  MOVFF  03,4B6
58A4:  MOVFF  02,4B5
58A8:  MOVFF  01,4B4
58AC:  MOVFF  00,4B3
....................         ketqua2 = ((docduoc[4] >> 4) * 16) + (docduoc[4] & 0x0F); 
58B0:  MOVLB  4
58B2:  SWAPF  x84,W
58B4:  MOVWF  00
58B6:  MOVLW  0F
58B8:  ANDWF  00,F
58BA:  MOVF   00,W
58BC:  MULLW  10
58BE:  MOVFF  FF3,4C4
58C2:  MOVF   x84,W
58C4:  ANDLW  0F
58C6:  ADDWF  xC4,W
58C8:  CLRF   xCA
58CA:  MOVWF  xC9
58CC:  MOVLB  0
58CE:  CALL   44A8
58D2:  MOVFF  03,4BA
58D6:  MOVFF  02,4B9
58DA:  MOVFF  01,4B8
58DE:  MOVFF  00,4B7
....................         ketqua1 = ((docduoc[3] >> 4) * 4096) + ((docduoc[3] & 0x0F) * 256); 
58E2:  MOVLB  4
58E4:  SWAPF  x83,W
58E6:  MOVWF  00
58E8:  MOVLW  0F
58EA:  ANDWF  00,F
58EC:  MOVFF  00,4C5
58F0:  CLRF   xCB
58F2:  MOVFF  00,4CA
58F6:  MOVLW  10
58F8:  MOVWF  xCD
58FA:  CLRF   xCC
58FC:  MOVLB  0
58FE:  CALL   0D32
5902:  MOVFF  02,4C5
5906:  MOVFF  01,4C4
590A:  MOVLB  4
590C:  MOVF   x83,W
590E:  ANDLW  0F
5910:  MOVWF  xC7
5912:  CLRF   xCB
5914:  MOVWF  xCA
5916:  MOVLW  01
5918:  MOVWF  xCD
591A:  CLRF   xCC
591C:  MOVLB  0
591E:  CALL   0D32
5922:  MOVFF  02,03
5926:  MOVF   01,W
5928:  MOVLB  4
592A:  ADDWF  xC4,W
592C:  MOVWF  01
592E:  MOVF   xC5,W
5930:  ADDWFC 03,F
5932:  MOVFF  01,4C9
5936:  MOVFF  03,4CA
593A:  MOVLB  0
593C:  CALL   44A8
5940:  MOVFF  03,4B6
5944:  MOVFF  02,4B5
5948:  MOVFF  01,4B4
594C:  MOVFF  00,4B3
....................         ketqua2 = ((docduoc[4] >> 4) * 16) + (docduoc[4] & 0x0F); 
5950:  MOVLB  4
5952:  SWAPF  x84,W
5954:  MOVWF  00
5956:  MOVLW  0F
5958:  ANDWF  00,F
595A:  MOVF   00,W
595C:  MULLW  10
595E:  MOVFF  FF3,4C4
5962:  MOVF   x84,W
5964:  ANDLW  0F
5966:  ADDWF  xC4,W
5968:  CLRF   xCA
596A:  MOVWF  xC9
596C:  MOVLB  0
596E:  CALL   44A8
5972:  MOVFF  03,4BA
5976:  MOVFF  02,4B9
597A:  MOVFF  01,4B8
597E:  MOVFF  00,4B7
....................         Nhietdo_doam[0] = (ketqua1 + ketqua2) / 100 - 40; 
5982:  BCF    FD8.1
5984:  MOVFF  4B6,4CA
5988:  MOVFF  4B5,4C9
598C:  MOVFF  4B4,4C8
5990:  MOVFF  4B3,4C7
5994:  MOVFF  4BA,4CE
5998:  MOVFF  4B9,4CD
599C:  MOVFF  4B8,4CC
59A0:  MOVFF  4B7,4CB
59A4:  CALL   4D36
59A8:  MOVFF  03,4C6
59AC:  MOVFF  02,4C5
59B0:  MOVFF  01,4C4
59B4:  MOVFF  00,4C3
59B8:  MOVFF  03,4CC
59BC:  MOVFF  02,4CB
59C0:  MOVFF  01,4CA
59C4:  MOVFF  00,4C9
59C8:  MOVLB  4
59CA:  CLRF   xD0
59CC:  CLRF   xCF
59CE:  MOVLW  48
59D0:  MOVWF  xCE
59D2:  MOVLW  85
59D4:  MOVWF  xCD
59D6:  MOVLB  0
59D8:  CALL   45D4
59DC:  MOVFF  03,4C6
59E0:  MOVFF  02,4C5
59E4:  MOVFF  01,4C4
59E8:  MOVFF  00,4C3
59EC:  BSF    FD8.1
59EE:  MOVFF  03,4CA
59F2:  MOVFF  02,4C9
59F6:  MOVFF  01,4C8
59FA:  MOVFF  00,4C7
59FE:  MOVLB  4
5A00:  CLRF   xCE
5A02:  CLRF   xCD
5A04:  MOVLW  20
5A06:  MOVWF  xCC
5A08:  MOVLW  84
5A0A:  MOVWF  xCB
5A0C:  MOVLB  0
5A0E:  CALL   4D36
5A12:  MOVFF  03,4BE
5A16:  MOVFF  02,4BD
5A1A:  MOVFF  01,4BC
5A1E:  MOVFF  00,4BB
....................         ketqua1 = ((docduoc[5] >> 4) * 4096) + ((docduoc[5] & 0x0F) * 256); 
5A22:  MOVLB  4
5A24:  SWAPF  x85,W
5A26:  MOVWF  00
5A28:  MOVLW  0F
5A2A:  ANDWF  00,F
5A2C:  MOVFF  00,4C5
5A30:  CLRF   xCB
5A32:  MOVFF  00,4CA
5A36:  MOVLW  10
5A38:  MOVWF  xCD
5A3A:  CLRF   xCC
5A3C:  MOVLB  0
5A3E:  CALL   0D32
5A42:  MOVFF  02,4C5
5A46:  MOVFF  01,4C4
5A4A:  MOVLB  4
5A4C:  MOVF   x85,W
5A4E:  ANDLW  0F
5A50:  MOVWF  xC7
5A52:  CLRF   xCB
5A54:  MOVWF  xCA
5A56:  MOVLW  01
5A58:  MOVWF  xCD
5A5A:  CLRF   xCC
5A5C:  MOVLB  0
5A5E:  CALL   0D32
5A62:  MOVFF  02,03
5A66:  MOVF   01,W
5A68:  MOVLB  4
5A6A:  ADDWF  xC4,W
5A6C:  MOVWF  01
5A6E:  MOVF   xC5,W
5A70:  ADDWFC 03,F
5A72:  MOVFF  01,4C9
5A76:  MOVFF  03,4CA
5A7A:  MOVLB  0
5A7C:  CALL   44A8
5A80:  MOVFF  03,4B6
5A84:  MOVFF  02,4B5
5A88:  MOVFF  01,4B4
5A8C:  MOVFF  00,4B3
....................         ketqua2 = ((docduoc[6] >> 4) * 16) + (docduoc[6] & 0x0F); 
5A90:  MOVLB  4
5A92:  SWAPF  x86,W
5A94:  MOVWF  00
5A96:  MOVLW  0F
5A98:  ANDWF  00,F
5A9A:  MOVF   00,W
5A9C:  MULLW  10
5A9E:  MOVFF  FF3,4C4
5AA2:  MOVF   x86,W
5AA4:  ANDLW  0F
5AA6:  ADDWF  xC4,W
5AA8:  CLRF   xCA
5AAA:  MOVWF  xC9
5AAC:  MOVLB  0
5AAE:  CALL   44A8
5AB2:  MOVFF  03,4BA
5AB6:  MOVFF  02,4B9
5ABA:  MOVFF  01,4B8
5ABE:  MOVFF  00,4B7
....................         Nhietdo_doam[1] = (ketqua1 + ketqua2) / 100; 
5AC2:  BCF    FD8.1
5AC4:  MOVFF  4B6,4CA
5AC8:  MOVFF  4B5,4C9
5ACC:  MOVFF  4B4,4C8
5AD0:  MOVFF  4B3,4C7
5AD4:  MOVFF  4BA,4CE
5AD8:  MOVFF  4B9,4CD
5ADC:  MOVFF  4B8,4CC
5AE0:  MOVFF  4B7,4CB
5AE4:  CALL   4D36
5AE8:  MOVFF  03,4C6
5AEC:  MOVFF  02,4C5
5AF0:  MOVFF  01,4C4
5AF4:  MOVFF  00,4C3
5AF8:  MOVFF  03,4CC
5AFC:  MOVFF  02,4CB
5B00:  MOVFF  01,4CA
5B04:  MOVFF  00,4C9
5B08:  MOVLB  4
5B0A:  CLRF   xD0
5B0C:  CLRF   xCF
5B0E:  MOVLW  48
5B10:  MOVWF  xCE
5B12:  MOVLW  85
5B14:  MOVWF  xCD
5B16:  MOVLB  0
5B18:  CALL   45D4
5B1C:  MOVFF  03,4C2
5B20:  MOVFF  02,4C1
5B24:  MOVFF  01,4C0
5B28:  MOVFF  00,4BF
....................     } 
5B2C:  BRA    5B72
5B2E:  MOVLB  4
....................     else 
....................     { 
....................         check++; 
5B30:  INCF   xB1,F
....................         //!        fprintf(UART2,"Check :  %d !!!\n",check); 
....................         if (check < 3) 
5B32:  MOVF   xB1,W
5B34:  SUBLW  02
5B36:  BNC   5B3C
....................             goto repead; 
5B38:  BRA    5802
5B3A:  BRA    5B74
....................         else 
....................             fprintf(UART2, "Loi Cam Bien %d !!!\n", id_sensor); 
5B3C:  MOVLW  74
5B3E:  MOVWF  FF6
5B40:  MOVLW  03
5B42:  MOVWF  FF7
5B44:  MOVLW  0D
5B46:  MOVWF  xC5
5B48:  MOVLB  0
5B4A:  CALL   3AD8
5B4E:  MOVFF  4B0,4C5
5B52:  MOVLW  18
5B54:  MOVLB  4
5B56:  MOVWF  xC6
5B58:  MOVLB  0
5B5A:  CALL   4FAE
5B5E:  MOVLW  83
5B60:  MOVWF  FF6
5B62:  MOVLW  03
5B64:  MOVWF  FF7
5B66:  MOVLW  05
5B68:  MOVLB  4
5B6A:  MOVWF  xC5
5B6C:  MOVLB  0
5B6E:  CALL   3AD8
5B72:  MOVLB  4
....................     } 
....................     return Nhietdo_doam; 
5B74:  MOVLW  BB
5B76:  MOVWF  01
5B78:  MOVLW  04
5B7A:  MOVWF  02
5B7C:  MOVLB  0
5B7E:  GOTO   66DA (RETURN)
.................... } 
....................  
.................... // ********* Ham chuyen doi ********* // 
.................... int BCD_2_DEC(int to_convert) 
.................... { 
....................     return (to_convert >> 4) * 10 + (to_convert & 0x0F); 
*
4330:  MOVLB  4
4332:  SWAPF  xA2,W
4334:  MOVWF  00
4336:  MOVLW  0F
4338:  ANDWF  00,F
433A:  MOVF   00,W
433C:  MULLW  0A
433E:  MOVFF  FF3,4A3
4342:  MOVF   xA2,W
4344:  ANDLW  0F
4346:  ADDWF  xA3,W
4348:  MOVWF  01
434A:  MOVLB  0
434C:  RETURN 0
.................... } 
.................... int DEC_2_BCD(int to_convert) 
.................... { 
....................     return ((to_convert / 10) << 4) + (to_convert % 10); 
*
4008:  MOVFF  4AA,4CB
400C:  MOVLW  0A
400E:  MOVLB  4
4010:  MOVWF  xCC
4012:  MOVLB  0
4014:  RCALL  3EF0
4016:  SWAPF  01,W
4018:  MOVLB  4
401A:  MOVWF  xAB
401C:  MOVLW  F0
401E:  ANDWF  xAB,F
4020:  MOVFF  4AA,4CB
4024:  MOVLW  0A
4026:  MOVWF  xCC
4028:  MOVLB  0
402A:  RCALL  3EF0
402C:  MOVF   00,W
402E:  MOVLB  4
4030:  ADDWF  xAB,W
4032:  MOVWF  01
4034:  MOVLB  0
4036:  RETURN 0
.................... } 
....................  
.................... // ********* Ham cap nhap gio vao DS ********* // 
.................... void Set_Time_Date(BYTE day, BYTE mth, BYTE year, BYTE hr, BYTE min, BYTE sec) 
.................... { 
....................     i2c_start(); 
4038:  BSF    F92.3
403A:  BRA    403C
403C:  BRA    403E
403E:  NOP   
4040:  BSF    F93.3
4042:  BRA    4044
4044:  BRA    4046
4046:  BRA    4048
4048:  BCF    F89.3
404A:  BCF    F92.3
404C:  BRA    404E
404E:  BRA    4050
4050:  NOP   
4052:  BCF    F8A.3
4054:  BCF    F93.3
....................     i2c_write(0xD0); 
4056:  MOVLW  D0
4058:  MOVLB  4
405A:  MOVWF  xAB
405C:  MOVLB  0
405E:  RCALL  3F9E
....................     i2c_write(0); 
4060:  MOVLB  4
4062:  CLRF   xAB
4064:  MOVLB  0
4066:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(sec));  //update sec 
4068:  MOVFF  4A9,4AA
406C:  RCALL  4008
406E:  MOVFF  01,4AA
4072:  MOVFF  01,4AB
4076:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(min));  //update min 
4078:  MOVFF  4A8,4AA
407C:  RCALL  4008
407E:  MOVFF  01,4AA
4082:  MOVFF  01,4AB
4086:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(hr));   //update hour 
4088:  MOVFF  4A7,4AA
408C:  RCALL  4008
408E:  MOVFF  01,4AA
4092:  MOVFF  01,4AB
4096:  RCALL  3F9E
....................     i2c_write(1);               //ignore updating day 
4098:  MOVLW  01
409A:  MOVLB  4
409C:  MOVWF  xAB
409E:  MOVLB  0
40A0:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(day));  //update date 
40A2:  MOVFF  4A4,4AA
40A6:  RCALL  4008
40A8:  MOVFF  01,4AA
40AC:  MOVFF  01,4AB
40B0:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(mth));  //update month 
40B2:  MOVFF  4A5,4AA
40B6:  RCALL  4008
40B8:  MOVFF  01,4AA
40BC:  MOVFF  01,4AB
40C0:  RCALL  3F9E
....................     i2c_write(DEC_2_BCD(year)); //update year 
40C2:  MOVFF  4A6,4AA
40C6:  RCALL  4008
40C8:  MOVFF  01,4AA
40CC:  MOVFF  01,4AB
40D0:  RCALL  3F9E
....................     i2c_stop(); 
40D2:  BCF    F92.3
40D4:  NOP   
40D6:  BSF    F93.3
40D8:  BTFSS  F81.3
40DA:  BRA    40D8
40DC:  BRA    40DE
40DE:  BRA    40E0
40E0:  NOP   
40E2:  BRA    40E4
40E4:  NOP   
40E6:  BSF    F92.3
40E8:  BRA    40EA
40EA:  BRA    40EC
40EC:  NOP   
40EE:  GOTO   42B6 (RETURN)
.................... } 
....................  
.................... // ********* Ham lay thoi gian ********* // 
.................... void Update_Current_Date_Time() 
.................... { 
....................     //START to Read 
....................     i2c_start(); 
*
434E:  BSF    F92.3
4350:  BRA    4352
4352:  BRA    4354
4354:  NOP   
4356:  BSF    F93.3
4358:  BRA    435A
435A:  BRA    435C
435C:  BRA    435E
435E:  BCF    F89.3
4360:  BCF    F92.3
4362:  BRA    4364
4364:  BRA    4366
4366:  NOP   
4368:  BCF    F8A.3
436A:  BCF    F93.3
....................     i2c_write(0xD0); 
436C:  MOVLW  D0
436E:  MOVLB  4
4370:  MOVWF  xAB
4372:  MOVLB  0
4374:  RCALL  3F9E
....................     i2c_write(0); 
4376:  MOVLB  4
4378:  CLRF   xAB
437A:  MOVLB  0
437C:  RCALL  3F9E
....................     i2c_stop(); 
437E:  BCF    F92.3
4380:  NOP   
4382:  BSF    F93.3
4384:  BTFSS  F81.3
4386:  BRA    4384
4388:  BRA    438A
438A:  BRA    438C
438C:  NOP   
438E:  BRA    4390
4390:  NOP   
4392:  BSF    F92.3
4394:  BRA    4396
4396:  BRA    4398
4398:  NOP   
....................  
....................     //READ 
....................     i2c_start(); 
439A:  BSF    F92.3
439C:  BRA    439E
439E:  BRA    43A0
43A0:  NOP   
43A2:  BSF    F93.3
43A4:  BRA    43A6
43A6:  BRA    43A8
43A8:  BRA    43AA
43AA:  BCF    F89.3
43AC:  BCF    F92.3
43AE:  BRA    43B0
43B0:  BRA    43B2
43B2:  NOP   
43B4:  BCF    F8A.3
43B6:  BCF    F93.3
....................     i2c_write(0xD1); // Initialize data read 
43B8:  MOVLW  D1
43BA:  MOVLB  4
43BC:  MOVWF  xAB
43BE:  MOVLB  0
43C0:  RCALL  3F9E
....................     sec = BCD_2_DEC(i2c_read(1)); 
43C2:  MOVLW  01
43C4:  MOVWF  00
43C6:  RCALL  42D0
43C8:  MOVFF  01,4A1
43CC:  MOVFF  01,4A2
43D0:  RCALL  4330
43D2:  MOVFF  01,262
....................     min = BCD_2_DEC(i2c_read(1)); // Read sec from register 
43D6:  MOVLW  01
43D8:  MOVWF  00
43DA:  RCALL  42D0
43DC:  MOVFF  01,4A1
43E0:  MOVFF  01,4A2
43E4:  RCALL  4330
43E6:  MOVFF  01,263
....................     hrs = BCD_2_DEC(i2c_read(1)); 
43EA:  MOVLW  01
43EC:  MOVWF  00
43EE:  RCALL  42D0
43F0:  MOVFF  01,4A1
43F4:  MOVFF  01,4A2
43F8:  RCALL  4330
43FA:  MOVFF  01,264
....................     i2c_read(1); 
43FE:  MOVLW  01
4400:  MOVWF  00
4402:  RCALL  42D0
....................     day = BCD_2_DEC(i2c_read(1)); 
4404:  MOVLW  01
4406:  MOVWF  00
4408:  RCALL  42D0
440A:  MOVFF  01,4A1
440E:  MOVFF  01,4A2
4412:  RCALL  4330
4414:  MOVFF  01,265
....................     month = BCD_2_DEC(i2c_read(1)); 
4418:  MOVLW  01
441A:  MOVWF  00
441C:  RCALL  42D0
441E:  MOVFF  01,4A1
4422:  MOVFF  01,4A2
4426:  RCALL  4330
4428:  MOVFF  01,266
....................     yr = BCD_2_DEC(i2c_read(1)); 
442C:  MOVLW  01
442E:  MOVWF  00
4430:  RCALL  42D0
4432:  MOVFF  01,4A1
4436:  MOVFF  01,4A2
443A:  RCALL  4330
443C:  MOVFF  01,267
....................     i2c_stop(); 
4440:  BCF    F92.3
4442:  NOP   
4444:  BSF    F93.3
4446:  BTFSS  F81.3
4448:  BRA    4446
444A:  BRA    444C
444C:  BRA    444E
444E:  NOP   
4450:  BRA    4452
4452:  NOP   
4454:  BSF    F92.3
4456:  BRA    4458
4458:  BRA    445A
445A:  NOP   
....................  
....................     //END Reading 
....................     i2c_start(); 
445C:  BSF    F92.3
445E:  BRA    4460
4460:  BRA    4462
4462:  NOP   
4464:  BSF    F93.3
4466:  BRA    4468
4468:  BRA    446A
446A:  BRA    446C
446C:  BCF    F89.3
446E:  BCF    F92.3
4470:  BRA    4472
4472:  BRA    4474
4474:  NOP   
4476:  BCF    F8A.3
4478:  BCF    F93.3
....................     i2c_write(0xD1); // Initialize data read 
447A:  MOVLW  D1
447C:  MOVLB  4
447E:  MOVWF  xAB
4480:  MOVLB  0
4482:  RCALL  3F9E
....................     i2c_read(1); 
4484:  MOVLW  01
4486:  MOVWF  00
4488:  RCALL  42D0
....................     i2c_stop(); 
448A:  BCF    F92.3
448C:  NOP   
448E:  BSF    F93.3
4490:  BTFSS  F81.3
4492:  BRA    4490
4494:  BRA    4496
4496:  BRA    4498
4498:  NOP   
449A:  BRA    449C
449C:  NOP   
449E:  BSF    F92.3
44A0:  BRA    44A2
44A2:  BRA    44A4
44A4:  NOP   
44A6:  RETURN 0
.................... } 
....................  
.................... // ********* Ham cap nhap gio ********* // 
.................... void capnhat_gio() 
.................... { 
....................     fprintf(PORT1SIM, "*time#"); 
*
40F2:  MOVLW  8A
40F4:  MOVWF  FF6
40F6:  MOVLW  03
40F8:  MOVWF  FF7
40FA:  RCALL  3B28
....................     kt_time = 0; 
40FC:  MOVLB  2
40FE:  CLRF   x4D
....................     rcount_TOUT = 0; 
4100:  CLRF   x46
4102:  CLRF   x45
....................     while ((kt_time == 0) && (rcount_TOUT <= 600)); 
4104:  MOVF   x4D,F
4106:  BNZ   4116
4108:  MOVF   x46,W
410A:  SUBLW  02
410C:  BNC   4116
410E:  BNZ   4104
4110:  MOVF   x45,W
4112:  SUBLW  58
4114:  BC    4104
....................     if (kt_time == 1) 
4116:  DECFSZ x4D,W
4118:  BRA    42BA
....................     { 
....................         kt_time = 0; 
411A:  CLRF   x4D
....................         toInt = buff + 1; // xoa ky tu dau tien cua chuoi buff 
411C:  MOVLW  03
411E:  MOVLB  3
4120:  MOVWF  x40
4122:  MOVLW  04
4124:  MOVWF  x3F
....................                           //  fprintf(UART2, "time=%s \n", toInt); 
....................         delay_ms(700); 
4126:  MOVLB  4
4128:  MOVWF  xA4
412A:  MOVLW  AF
412C:  MOVWF  xBA
412E:  MOVLB  0
4130:  CALL   0482
4134:  MOVLB  4
4136:  DECFSZ xA4,F
4138:  BRA    412A
....................         ptr = strtok(toInt, ";"); 
413A:  MOVLW  3B
413C:  MOVWF  xA2
413E:  CLRF   xA3
4140:  MOVFF  340,4A7
4144:  MOVFF  33F,4A6
4148:  MOVLW  04
414A:  MOVWF  xA9
414C:  MOVLW  A2
414E:  MOVWF  xA8
4150:  MOVLB  0
4152:  RCALL  3C54
4154:  MOVFF  02,342
4158:  MOVFF  01,341
....................         gg = 0; 
415C:  MOVLB  3
415E:  CLRF   x47
....................         while (ptr != 0) 
4160:  MOVF   x41,F
4162:  BNZ   4168
4164:  MOVF   x42,F
4166:  BZ    41BA
....................         { 
....................             tachdata_time[gg] = atoi(ptr); 
4168:  CLRF   03
416A:  MOVF   x47,W
416C:  ADDLW  9C
416E:  MOVWF  01
4170:  MOVLW  03
4172:  ADDWFC 03,F
4174:  MOVFF  01,4A4
4178:  MOVFF  03,4A5
417C:  MOVFF  342,4A7
4180:  MOVFF  341,4A6
4184:  MOVLB  0
4186:  RCALL  3D5E
4188:  MOVFF  4A5,FEA
418C:  MOVFF  4A4,FE9
4190:  MOVFF  01,FEF
....................             ptr = strtok(0, ";"); 
4194:  MOVLW  3B
4196:  MOVLB  4
4198:  MOVWF  xA2
419A:  CLRF   xA3
419C:  CLRF   xA7
419E:  CLRF   xA6
41A0:  MOVLW  04
41A2:  MOVWF  xA9
41A4:  MOVLW  A2
41A6:  MOVWF  xA8
41A8:  MOVLB  0
41AA:  RCALL  3C54
41AC:  MOVFF  02,342
41B0:  MOVFF  01,341
....................             gg++; 
41B4:  MOVLB  3
41B6:  INCF   x47,F
41B8:  BRA    4160
....................         } 
....................         sec = tachdata_time[5]; 
41BA:  MOVFF  3A1,262
....................         min = tachdata_time[4]; 
41BE:  MOVFF  3A0,263
....................         hrs = tachdata_time[3]; 
41C2:  MOVFF  39F,264
....................         day = tachdata_time[2]; 
41C6:  MOVFF  39E,265
....................         month = tachdata_time[1]; 
41CA:  MOVFF  39D,266
....................         yr = tachdata_time[0]; 
41CE:  MOVFF  39C,267
....................         fprintf(UART2, "%u-%u-%u-%u-%u-%u \n", day, month, yr, hrs, min, sec); 
41D2:  MOVFF  265,4A4
41D6:  MOVLW  1B
41D8:  MOVLB  4
41DA:  MOVWF  xA5
41DC:  MOVLB  0
41DE:  RCALL  3F1C
41E0:  MOVLW  2D
41E2:  MOVLB  4
41E4:  MOVWF  xCB
41E6:  MOVLB  0
41E8:  CALL   04AC
41EC:  MOVFF  266,4A4
41F0:  MOVLW  1B
41F2:  MOVLB  4
41F4:  MOVWF  xA5
41F6:  MOVLB  0
41F8:  RCALL  3F1C
41FA:  MOVLW  2D
41FC:  MOVLB  4
41FE:  MOVWF  xCB
4200:  MOVLB  0
4202:  CALL   04AC
4206:  MOVFF  267,4A4
420A:  MOVLW  1B
420C:  MOVLB  4
420E:  MOVWF  xA5
4210:  MOVLB  0
4212:  RCALL  3F1C
4214:  MOVLW  2D
4216:  MOVLB  4
4218:  MOVWF  xCB
421A:  MOVLB  0
421C:  CALL   04AC
4220:  MOVFF  264,4A4
4224:  MOVLW  1B
4226:  MOVLB  4
4228:  MOVWF  xA5
422A:  MOVLB  0
422C:  RCALL  3F1C
422E:  MOVLW  2D
4230:  MOVLB  4
4232:  MOVWF  xCB
4234:  MOVLB  0
4236:  CALL   04AC
423A:  MOVFF  263,4A4
423E:  MOVLW  1B
4240:  MOVLB  4
4242:  MOVWF  xA5
4244:  MOVLB  0
4246:  RCALL  3F1C
4248:  MOVLW  2D
424A:  MOVLB  4
424C:  MOVWF  xCB
424E:  MOVLB  0
4250:  CALL   04AC
4254:  MOVFF  262,4A4
4258:  MOVLW  1B
425A:  MOVLB  4
425C:  MOVWF  xA5
425E:  MOVLB  0
4260:  RCALL  3F1C
4262:  MOVLW  20
4264:  MOVLB  4
4266:  MOVWF  xCB
4268:  MOVLB  0
426A:  CALL   04AC
426E:  MOVLW  0A
4270:  MOVLB  4
4272:  MOVWF  xCB
4274:  MOVLB  0
4276:  CALL   04AC
....................         //fprintf(UART2,"get time=%u \n",kt_time); 
....................         if ((month <= 12) || (day <= 31) || (hrs < 24) || (min < 60) || (sec < 60)) 
427A:  MOVLB  2
427C:  MOVF   x66,W
427E:  SUBLW  0C
4280:  BC    429A
4282:  MOVF   x65,W
4284:  SUBLW  1F
4286:  BC    429A
4288:  MOVF   x64,W
428A:  SUBLW  17
428C:  BC    429A
428E:  MOVF   x63,W
4290:  SUBLW  3B
4292:  BC    429A
4294:  MOVF   x62,W
4296:  SUBLW  3B
4298:  BNC   42B8
....................         { 
....................             Set_Time_Date(day, month, yr, hrs, min, sec); 
429A:  MOVFF  265,4A4
429E:  MOVFF  266,4A5
42A2:  MOVFF  267,4A6
42A6:  MOVFF  264,4A7
42AA:  MOVFF  263,4A8
42AE:  MOVFF  262,4A9
42B2:  MOVLB  0
42B4:  BRA    4038
42B6:  MOVLB  2
....................         } 
....................     } 
42B8:  BRA    42CC
....................     else 
....................     { 
....................         fprintf(UART2, "loi get time"); 
42BA:  MOVLW  92
42BC:  MOVWF  FF6
42BE:  MOVLW  03
42C0:  MOVWF  FF7
42C2:  MOVLB  0
42C4:  CALL   0FE8
....................         error_get++; 
42C8:  MOVLB  2
42CA:  INCF   x4B,F
....................     } 
42CC:  MOVLB  0
42CE:  RETURN 0
.................... } 
....................  
.................... // ********* Ham chon gia tri ngau nhien ********* // 
.................... float Random(float a, float b) 
.................... { 
....................     return a + (b - a) * rand() / RAND_MAX; 
*
54A6:  BSF    FD8.1
54A8:  MOVFF  4B7,4CA
54AC:  MOVFF  4B6,4C9
54B0:  MOVFF  4B5,4C8
54B4:  MOVFF  4B4,4C7
54B8:  MOVFF  4B3,4CE
54BC:  MOVFF  4B2,4CD
54C0:  MOVFF  4B1,4CC
54C4:  MOVFF  4B0,4CB
54C8:  RCALL  4D36
54CA:  MOVFF  03,4BB
54CE:  MOVFF  02,4BA
54D2:  MOVFF  01,4B9
54D6:  MOVFF  00,4B8
54DA:  BRA    5432
54DC:  MOVFF  02,4CA
54E0:  MOVFF  01,4C9
54E4:  MOVLB  0
54E6:  CALL   44A8
54EA:  MOVFF  4BB,4CC
54EE:  MOVFF  4BA,4CB
54F2:  MOVFF  4B9,4CA
54F6:  MOVFF  4B8,4C9
54FA:  MOVFF  03,4D0
54FE:  MOVFF  02,4CF
5502:  MOVFF  01,4CE
5506:  MOVFF  00,4CD
550A:  CALL   44DE
550E:  MOVFF  03,4BB
5512:  MOVFF  02,4BA
5516:  MOVFF  01,4B9
551A:  MOVFF  00,4B8
551E:  MOVFF  03,4CC
5522:  MOVFF  02,4CB
5526:  MOVFF  01,4CA
552A:  MOVFF  00,4C9
552E:  MOVLB  4
5530:  CLRF   xD0
5532:  MOVLW  FE
5534:  MOVWF  xCF
5536:  MOVLW  7F
5538:  MOVWF  xCE
553A:  MOVLW  8D
553C:  MOVWF  xCD
553E:  MOVLB  0
5540:  CALL   45D4
5544:  MOVFF  FEA,4B9
5548:  MOVFF  FE9,4B8
554C:  BCF    FD8.1
554E:  MOVFF  4B3,4CA
5552:  MOVFF  4B2,4C9
5556:  MOVFF  4B1,4C8
555A:  MOVFF  4B0,4C7
555E:  MOVFF  03,4CE
5562:  MOVFF  02,4CD
5566:  MOVFF  01,4CC
556A:  MOVFF  00,4CB
556E:  CALL   4D36
5572:  MOVFF  4B9,FEA
5576:  MOVFF  4B8,FE9
557A:  RETURN 0
.................... } 
....................  
.................... // ********* Ham lay gia tri cam bien ********* // 
.................... void Value_Sensor_RS485() 
*
5B82:  MOVLB  4
5B84:  CLRF   xA4
5B86:  CLRF   xA3
5B88:  CLRF   xA2
5B8A:  CLRF   xA1
5B8C:  CLRF   xA8
5B8E:  CLRF   xA7
5B90:  CLRF   xA6
5B92:  CLRF   xA5
5B94:  CLRF   xAC
5B96:  CLRF   xAB
5B98:  CLRF   xAA
5B9A:  CLRF   xA9
5B9C:  CLRF   xAD
.................... { 
....................     float so2 = 0, no2 = 0, co = 0; 
....................     int count_a = 0; 
....................     // --------- Kiem tra loi tra ve NULL --------- // 
.................... repead_so2: 
....................     so2 = _ketquars485(0); 
5B9E:  CLRF   xB4
5BA0:  MOVLB  0
5BA2:  CALL   5076
5BA6:  MOVFF  03,4A4
5BAA:  MOVFF  02,4A3
5BAE:  MOVFF  01,4A2
5BB2:  MOVFF  00,4A1
....................     if (abs(buf_so2 - so2) >= 1000 || so2 > 3500) 
5BB6:  BSF    FD8.1
5BB8:  MOVFF  2D4,4CA
5BBC:  MOVFF  2D3,4C9
5BC0:  MOVFF  2D2,4C8
5BC4:  MOVFF  2D1,4C7
5BC8:  MOVFF  4A4,4CE
5BCC:  MOVFF  4A3,4CD
5BD0:  MOVFF  4A2,4CC
5BD4:  MOVFF  4A1,4CB
5BD8:  CALL   4D36
5BDC:  MOVFF  03,4B3
5BE0:  MOVFF  02,4B2
5BE4:  MOVFF  01,4B1
5BE8:  MOVFF  00,4B0
5BEC:  MOVFF  00,00
5BF0:  MOVFF  01,01
5BF4:  MOVFF  02,02
5BF8:  MOVFF  03,03
5BFC:  BCF    01.7
5BFE:  MOVFF  03,4B3
5C02:  MOVFF  02,4B2
5C06:  MOVFF  01,4B1
5C0A:  MOVFF  00,4B0
5C0E:  MOVLB  4
5C10:  CLRF   xB7
5C12:  CLRF   xB6
5C14:  MOVLW  7A
5C16:  MOVWF  xB5
5C18:  MOVLW  88
5C1A:  MOVWF  xB4
5C1C:  MOVFF  03,4BB
5C20:  MOVFF  02,4BA
5C24:  MOVFF  01,4B9
5C28:  MOVFF  00,4B8
5C2C:  MOVLB  0
5C2E:  CALL   47FC
5C32:  BC    5C5E
5C34:  BZ    5C5E
5C36:  MOVLB  4
5C38:  CLRF   xB7
5C3A:  MOVLW  C0
5C3C:  MOVWF  xB6
5C3E:  MOVLW  5A
5C40:  MOVWF  xB5
5C42:  MOVLW  8A
5C44:  MOVWF  xB4
5C46:  MOVFF  4A4,4BB
5C4A:  MOVFF  4A3,4BA
5C4E:  MOVFF  4A2,4B9
5C52:  MOVFF  4A1,4B8
5C56:  MOVLB  0
5C58:  CALL   47FC
5C5C:  BNC   5CFA
....................     { 
....................         count_a++; 
5C5E:  MOVLB  4
5C60:  INCF   xAD,F
....................         delay_ms(2000); 
5C62:  MOVLW  08
5C64:  MOVWF  xB0
5C66:  MOVLW  FA
5C68:  MOVWF  xBA
5C6A:  MOVLB  0
5C6C:  CALL   0482
5C70:  MOVLB  4
5C72:  DECFSZ xB0,F
5C74:  BRA    5C66
....................         if (count_a < 3) 
5C76:  MOVF   xAD,W
5C78:  SUBLW  02
5C7A:  BNC   5C80
....................             goto repead_so2; 
5C7C:  BRA    5B9E
5C7E:  BRA    5CF6
....................         else if (count_a >= 3 && Tb_so2 == 0 && so2 > 3500) 
5C80:  MOVF   xAD,W
5C82:  SUBLW  02
5C84:  BC    5CF6
5C86:  MOVFF  2CC,4B7
5C8A:  MOVFF  2CB,4B6
5C8E:  MOVFF  2CA,4B5
5C92:  MOVFF  2C9,4B4
5C96:  CLRF   xBB
5C98:  CLRF   xBA
5C9A:  CLRF   xB9
5C9C:  CLRF   xB8
5C9E:  MOVLB  0
5CA0:  CALL   47FC
5CA4:  BTFSC  FD8.2
5CA6:  BRA    5CAC
5CA8:  MOVLB  4
5CAA:  BRA    5CF6
5CAC:  MOVLB  4
5CAE:  CLRF   xB7
5CB0:  MOVLW  C0
5CB2:  MOVWF  xB6
5CB4:  MOVLW  5A
5CB6:  MOVWF  xB5
5CB8:  MOVLW  8A
5CBA:  MOVWF  xB4
5CBC:  MOVFF  4A4,4BB
5CC0:  MOVFF  4A3,4BA
5CC4:  MOVFF  4A2,4B9
5CC8:  MOVFF  4A1,4B8
5CCC:  MOVLB  0
5CCE:  CALL   47FC
5CD2:  BTFSC  FD8.0
5CD4:  BRA    5CDA
5CD6:  MOVLB  4
5CD8:  BRA    5CF6
....................             strcpy(So2, "null"); 
5CDA:  MOVLW  02
5CDC:  MOVWF  FEA
5CDE:  MOVLW  E9
5CE0:  MOVWF  FE9
5CE2:  MOVLW  00
5CE4:  CALL   00C6
5CE8:  TBLRD*-
5CEA:  TBLRD*+
5CEC:  MOVF   FF5,W
5CEE:  MOVWF  FEE
5CF0:  IORLW  00
5CF2:  BNZ   5CEA
5CF4:  MOVLB  4
....................     } 
5CF6:  BRA    5E60
5CF8:  MOVLB  0
....................     else 
....................     { 
....................         num_so2++; 
5CFA:  MOVLB  2
5CFC:  INCF   x50,F
....................         so2 = (so2 != 0) ? so2 : Random(0.01, 5); 
5CFE:  MOVFF  4A4,4B7
5D02:  MOVFF  4A3,4B6
5D06:  MOVFF  4A2,4B5
5D0A:  MOVFF  4A1,4B4
5D0E:  MOVLB  4
5D10:  CLRF   xBB
5D12:  CLRF   xBA
5D14:  CLRF   xB9
5D16:  CLRF   xB8
5D18:  MOVLB  0
5D1A:  CALL   47FC
5D1E:  BZ    5D32
5D20:  MOVFF  4A1,00
5D24:  MOVFF  4A2,01
5D28:  MOVFF  4A3,02
5D2C:  MOVFF  4A4,03
5D30:  BRA    5D56
5D32:  MOVLW  0A
5D34:  MOVLB  4
5D36:  MOVWF  xB3
5D38:  MOVLW  D7
5D3A:  MOVWF  xB2
5D3C:  MOVLW  23
5D3E:  MOVWF  xB1
5D40:  MOVLW  78
5D42:  MOVWF  xB0
5D44:  CLRF   xB7
5D46:  CLRF   xB6
5D48:  MOVLW  20
5D4A:  MOVWF  xB5
5D4C:  MOVLW  81
5D4E:  MOVWF  xB4
5D50:  MOVLB  0
5D52:  CALL   54A6
5D56:  MOVFF  03,4A4
5D5A:  MOVFF  02,4A3
5D5E:  MOVFF  01,4A2
5D62:  MOVFF  00,4A1
....................         buf_so2 = so2; 
5D66:  MOVFF  4A4,2D4
5D6A:  MOVFF  4A3,2D3
5D6E:  MOVFF  4A2,2D2
5D72:  MOVFF  4A1,2D1
....................         Tb_so2 = (Tb_so2 * (num_so2 - 1) + so2) / num_so2; 
5D76:  MOVLW  01
5D78:  MOVLB  2
5D7A:  SUBWF  x50,W
5D7C:  MOVLB  4
5D7E:  CLRF   xCA
5D80:  MOVWF  xC9
5D82:  MOVLB  0
5D84:  CALL   44A8
5D88:  MOVFF  2CC,4CC
5D8C:  MOVFF  2CB,4CB
5D90:  MOVFF  2CA,4CA
5D94:  MOVFF  2C9,4C9
5D98:  MOVFF  03,4D0
5D9C:  MOVFF  02,4CF
5DA0:  MOVFF  01,4CE
5DA4:  MOVFF  00,4CD
5DA8:  CALL   44DE
5DAC:  MOVFF  03,4B3
5DB0:  MOVFF  02,4B2
5DB4:  MOVFF  01,4B1
5DB8:  MOVFF  00,4B0
5DBC:  BCF    FD8.1
5DBE:  MOVFF  03,4CA
5DC2:  MOVFF  02,4C9
5DC6:  MOVFF  01,4C8
5DCA:  MOVFF  00,4C7
5DCE:  MOVFF  4A4,4CE
5DD2:  MOVFF  4A3,4CD
5DD6:  MOVFF  4A2,4CC
5DDA:  MOVFF  4A1,4CB
5DDE:  CALL   4D36
5DE2:  MOVFF  03,4B3
5DE6:  MOVFF  02,4B2
5DEA:  MOVFF  01,4B1
5DEE:  MOVFF  00,4B0
5DF2:  MOVLB  4
5DF4:  CLRF   xCA
5DF6:  MOVFF  250,4C9
5DFA:  MOVLB  0
5DFC:  CALL   44A8
5E00:  MOVFF  4B3,4CC
5E04:  MOVFF  4B2,4CB
5E08:  MOVFF  4B1,4CA
5E0C:  MOVFF  4B0,4C9
5E10:  MOVFF  03,4D0
5E14:  MOVFF  02,4CF
5E18:  MOVFF  01,4CE
5E1C:  MOVFF  00,4CD
5E20:  CALL   45D4
5E24:  MOVFF  03,2CC
5E28:  MOVFF  02,2CB
5E2C:  MOVFF  01,2CA
5E30:  MOVFF  00,2C9
....................         sprintf(So2, "%f", Tb_so2); 
5E34:  MOVLW  02
5E36:  MOVLB  2
5E38:  MOVWF  x3A
5E3A:  MOVLW  E9
5E3C:  MOVWF  x39
5E3E:  MOVLW  89
5E40:  MOVWF  FE9
5E42:  MOVFF  2CC,4B3
5E46:  MOVFF  2CB,4B2
5E4A:  MOVFF  2CA,4B1
5E4E:  MOVFF  2C9,4B0
5E52:  MOVLW  02
5E54:  MOVLB  4
5E56:  MOVWF  xB4
5E58:  MOVLB  0
5E5A:  CALL   55C0
5E5E:  MOVLB  4
....................     } 
....................     count_a = 0; 
5E60:  CLRF   xAD
....................     delay_ms(2000); 
5E62:  MOVLW  08
5E64:  MOVWF  xB0
5E66:  MOVLW  FA
5E68:  MOVWF  xBA
5E6A:  MOVLB  0
5E6C:  CALL   0482
5E70:  MOVLB  4
5E72:  DECFSZ xB0,F
5E74:  BRA    5E66
....................     // --------- Kiem tra loi tra ve NULL --------- // 
.................... repead_no2: 
....................     no2 = _ketquars485(1); 
5E76:  MOVLW  01
5E78:  MOVWF  xB4
5E7A:  MOVLB  0
5E7C:  CALL   5076
5E80:  MOVFF  03,4A8
5E84:  MOVFF  02,4A7
5E88:  MOVFF  01,4A6
5E8C:  MOVFF  00,4A5
....................     if (abs(buf_no2 - no2) > 1200 || no2 > 4500) 
5E90:  BSF    FD8.1
5E92:  MOVFF  2D8,4CA
5E96:  MOVFF  2D7,4C9
5E9A:  MOVFF  2D6,4C8
5E9E:  MOVFF  2D5,4C7
5EA2:  MOVFF  4A8,4CE
5EA6:  MOVFF  4A7,4CD
5EAA:  MOVFF  4A6,4CC
5EAE:  MOVFF  4A5,4CB
5EB2:  CALL   4D36
5EB6:  MOVFF  03,4B3
5EBA:  MOVFF  02,4B2
5EBE:  MOVFF  01,4B1
5EC2:  MOVFF  00,4B0
5EC6:  MOVFF  00,00
5ECA:  MOVFF  01,01
5ECE:  MOVFF  02,02
5ED2:  MOVFF  03,03
5ED6:  BCF    01.7
5ED8:  MOVFF  03,4B3
5EDC:  MOVFF  02,4B2
5EE0:  MOVFF  01,4B1
5EE4:  MOVFF  00,4B0
5EE8:  MOVLB  4
5EEA:  CLRF   xB7
5EEC:  CLRF   xB6
5EEE:  MOVLW  16
5EF0:  MOVWF  xB5
5EF2:  MOVLW  89
5EF4:  MOVWF  xB4
5EF6:  MOVFF  03,4BB
5EFA:  MOVFF  02,4BA
5EFE:  MOVFF  01,4B9
5F02:  MOVFF  00,4B8
5F06:  MOVLB  0
5F08:  CALL   47FC
5F0C:  BC    5F36
5F0E:  MOVLB  4
5F10:  CLRF   xB7
5F12:  MOVLW  A0
5F14:  MOVWF  xB6
5F16:  MOVLW  0C
5F18:  MOVWF  xB5
5F1A:  MOVLW  8B
5F1C:  MOVWF  xB4
5F1E:  MOVFF  4A8,4BB
5F22:  MOVFF  4A7,4BA
5F26:  MOVFF  4A6,4B9
5F2A:  MOVFF  4A5,4B8
5F2E:  MOVLB  0
5F30:  CALL   47FC
5F34:  BNC   5FD2
....................     { 
....................         count_a++; 
5F36:  MOVLB  4
5F38:  INCF   xAD,F
....................         delay_ms(2000); 
5F3A:  MOVLW  08
5F3C:  MOVWF  xB0
5F3E:  MOVLW  FA
5F40:  MOVWF  xBA
5F42:  MOVLB  0
5F44:  CALL   0482
5F48:  MOVLB  4
5F4A:  DECFSZ xB0,F
5F4C:  BRA    5F3E
....................         if (count_a < 3) 
5F4E:  MOVF   xAD,W
5F50:  SUBLW  02
5F52:  BNC   5F58
....................             goto repead_no2; 
5F54:  BRA    5E76
5F56:  BRA    5FCE
....................         else if (count_a >= 3 && Tb_no2 == 0 && no2 > 4500) 
5F58:  MOVF   xAD,W
5F5A:  SUBLW  02
5F5C:  BC    5FCE
5F5E:  MOVFF  2C8,4B7
5F62:  MOVFF  2C7,4B6
5F66:  MOVFF  2C6,4B5
5F6A:  MOVFF  2C5,4B4
5F6E:  CLRF   xBB
5F70:  CLRF   xBA
5F72:  CLRF   xB9
5F74:  CLRF   xB8
5F76:  MOVLB  0
5F78:  CALL   47FC
5F7C:  BTFSC  FD8.2
5F7E:  BRA    5F84
5F80:  MOVLB  4
5F82:  BRA    5FCE
5F84:  MOVLB  4
5F86:  CLRF   xB7
5F88:  MOVLW  A0
5F8A:  MOVWF  xB6
5F8C:  MOVLW  0C
5F8E:  MOVWF  xB5
5F90:  MOVLW  8B
5F92:  MOVWF  xB4
5F94:  MOVFF  4A8,4BB
5F98:  MOVFF  4A7,4BA
5F9C:  MOVFF  4A6,4B9
5FA0:  MOVFF  4A5,4B8
5FA4:  MOVLB  0
5FA6:  CALL   47FC
5FAA:  BTFSC  FD8.0
5FAC:  BRA    5FB2
5FAE:  MOVLB  4
5FB0:  BRA    5FCE
....................             strcpy(No2, "null"); 
5FB2:  MOVLW  02
5FB4:  MOVWF  FEA
5FB6:  MOVLW  DF
5FB8:  MOVWF  FE9
5FBA:  MOVLW  00
5FBC:  CALL   00C6
5FC0:  TBLRD*-
5FC2:  TBLRD*+
5FC4:  MOVF   FF5,W
5FC6:  MOVWF  FEE
5FC8:  IORLW  00
5FCA:  BNZ   5FC2
5FCC:  MOVLB  4
....................     } 
5FCE:  BRA    6132
5FD0:  MOVLB  0
....................     else 
....................     { 
....................         num_no2++; 
5FD2:  MOVLB  2
5FD4:  INCF   x4F,F
....................         no2 = (no2 != 0) ? no2 : Random(2, 21); 
5FD6:  MOVFF  4A8,4B7
5FDA:  MOVFF  4A7,4B6
5FDE:  MOVFF  4A6,4B5
5FE2:  MOVFF  4A5,4B4
5FE6:  MOVLB  4
5FE8:  CLRF   xBB
5FEA:  CLRF   xBA
5FEC:  CLRF   xB9
5FEE:  CLRF   xB8
5FF0:  MOVLB  0
5FF2:  CALL   47FC
5FF6:  BZ    600A
5FF8:  MOVFF  4A5,00
5FFC:  MOVFF  4A6,01
6000:  MOVFF  4A7,02
6004:  MOVFF  4A8,03
6008:  BRA    6028
600A:  MOVLB  4
600C:  CLRF   xB3
600E:  CLRF   xB2
6010:  CLRF   xB1
6012:  MOVLW  80
6014:  MOVWF  xB0
6016:  CLRF   xB7
6018:  CLRF   xB6
601A:  MOVLW  28
601C:  MOVWF  xB5
601E:  MOVLW  83
6020:  MOVWF  xB4
6022:  MOVLB  0
6024:  CALL   54A6
6028:  MOVFF  03,4A8
602C:  MOVFF  02,4A7
6030:  MOVFF  01,4A6
6034:  MOVFF  00,4A5
....................         buf_no2 = no2; 
6038:  MOVFF  4A8,2D8
603C:  MOVFF  4A7,2D7
6040:  MOVFF  4A6,2D6
6044:  MOVFF  4A5,2D5
....................         Tb_no2 = (Tb_no2 * (num_no2 - 1) + no2) / num_no2; 
6048:  MOVLW  01
604A:  MOVLB  2
604C:  SUBWF  x4F,W
604E:  MOVLB  4
6050:  CLRF   xCA
6052:  MOVWF  xC9
6054:  MOVLB  0
6056:  CALL   44A8
605A:  MOVFF  2C8,4CC
605E:  MOVFF  2C7,4CB
6062:  MOVFF  2C6,4CA
6066:  MOVFF  2C5,4C9
606A:  MOVFF  03,4D0
606E:  MOVFF  02,4CF
6072:  MOVFF  01,4CE
6076:  MOVFF  00,4CD
607A:  CALL   44DE
607E:  MOVFF  03,4B3
6082:  MOVFF  02,4B2
6086:  MOVFF  01,4B1
608A:  MOVFF  00,4B0
608E:  BCF    FD8.1
6090:  MOVFF  03,4CA
6094:  MOVFF  02,4C9
6098:  MOVFF  01,4C8
609C:  MOVFF  00,4C7
60A0:  MOVFF  4A8,4CE
60A4:  MOVFF  4A7,4CD
60A8:  MOVFF  4A6,4CC
60AC:  MOVFF  4A5,4CB
60B0:  CALL   4D36
60B4:  MOVFF  03,4B3
60B8:  MOVFF  02,4B2
60BC:  MOVFF  01,4B1
60C0:  MOVFF  00,4B0
60C4:  MOVLB  4
60C6:  CLRF   xCA
60C8:  MOVFF  24F,4C9
60CC:  MOVLB  0
60CE:  CALL   44A8
60D2:  MOVFF  4B3,4CC
60D6:  MOVFF  4B2,4CB
60DA:  MOVFF  4B1,4CA
60DE:  MOVFF  4B0,4C9
60E2:  MOVFF  03,4D0
60E6:  MOVFF  02,4CF
60EA:  MOVFF  01,4CE
60EE:  MOVFF  00,4CD
60F2:  CALL   45D4
60F6:  MOVFF  03,2C8
60FA:  MOVFF  02,2C7
60FE:  MOVFF  01,2C6
6102:  MOVFF  00,2C5
....................         sprintf(No2, "%f", Tb_no2); 
6106:  MOVLW  02
6108:  MOVLB  2
610A:  MOVWF  x3A
610C:  MOVLW  DF
610E:  MOVWF  x39
6110:  MOVLW  89
6112:  MOVWF  FE9
6114:  MOVFF  2C8,4B3
6118:  MOVFF  2C7,4B2
611C:  MOVFF  2C6,4B1
6120:  MOVFF  2C5,4B0
6124:  MOVLW  02
6126:  MOVLB  4
6128:  MOVWF  xB4
612A:  MOVLB  0
612C:  CALL   55C0
6130:  MOVLB  4
....................     } 
....................     count_a = 0; 
6132:  CLRF   xAD
....................     delay_ms(2000); 
6134:  MOVLW  08
6136:  MOVWF  xB0
6138:  MOVLW  FA
613A:  MOVWF  xBA
613C:  MOVLB  0
613E:  CALL   0482
6142:  MOVLB  4
6144:  DECFSZ xB0,F
6146:  BRA    6138
....................     // --------- Kiem tra loi tra ve NULL --------- // 
.................... repead_co: 
....................     co = _ketquars485(2); 
6148:  MOVLW  02
614A:  MOVWF  xB4
614C:  MOVLB  0
614E:  CALL   5076
6152:  MOVFF  03,4AC
6156:  MOVFF  02,4AB
615A:  MOVFF  01,4AA
615E:  MOVFF  00,4A9
....................     if (abs(buf_co - co) > 11000 || co > 200000) 
6162:  BSF    FD8.1
6164:  MOVFF  2DC,4CA
6168:  MOVFF  2DB,4C9
616C:  MOVFF  2DA,4C8
6170:  MOVFF  2D9,4C7
6174:  MOVFF  4AC,4CE
6178:  MOVFF  4AB,4CD
617C:  MOVFF  4AA,4CC
6180:  MOVFF  4A9,4CB
6184:  CALL   4D36
6188:  MOVFF  03,4B3
618C:  MOVFF  02,4B2
6190:  MOVFF  01,4B1
6194:  MOVFF  00,4B0
6198:  MOVFF  00,00
619C:  MOVFF  01,01
61A0:  MOVFF  02,02
61A4:  MOVFF  03,03
61A8:  BCF    01.7
61AA:  MOVFF  03,4B3
61AE:  MOVFF  02,4B2
61B2:  MOVFF  01,4B1
61B6:  MOVFF  00,4B0
61BA:  MOVLB  4
61BC:  CLRF   xB7
61BE:  MOVLW  E0
61C0:  MOVWF  xB6
61C2:  MOVLW  2B
61C4:  MOVWF  xB5
61C6:  MOVLW  8C
61C8:  MOVWF  xB4
61CA:  MOVFF  03,4BB
61CE:  MOVFF  02,4BA
61D2:  MOVFF  01,4B9
61D6:  MOVFF  00,4B8
61DA:  MOVLB  0
61DC:  CALL   47FC
61E0:  BC    620A
61E2:  MOVLB  4
61E4:  CLRF   xB7
61E6:  MOVLW  50
61E8:  MOVWF  xB6
61EA:  MOVLW  43
61EC:  MOVWF  xB5
61EE:  MOVLW  90
61F0:  MOVWF  xB4
61F2:  MOVFF  4AC,4BB
61F6:  MOVFF  4AB,4BA
61FA:  MOVFF  4AA,4B9
61FE:  MOVFF  4A9,4B8
6202:  MOVLB  0
6204:  CALL   47FC
6208:  BNC   62A6
....................     { 
....................         count_a++; 
620A:  MOVLB  4
620C:  INCF   xAD,F
....................         delay_ms(2000); 
620E:  MOVLW  08
6210:  MOVWF  xB0
6212:  MOVLW  FA
6214:  MOVWF  xBA
6216:  MOVLB  0
6218:  CALL   0482
621C:  MOVLB  4
621E:  DECFSZ xB0,F
6220:  BRA    6212
....................         if (count_a < 3) 
6222:  MOVF   xAD,W
6224:  SUBLW  02
6226:  BNC   622C
....................             goto repead_co; 
6228:  BRA    6148
622A:  BRA    62A2
....................         else if (count_a >= 3 && Tb_co == 0 && co > 200000) 
622C:  MOVF   xAD,W
622E:  SUBLW  02
6230:  BC    62A2
6232:  MOVFF  2D0,4B7
6236:  MOVFF  2CF,4B6
623A:  MOVFF  2CE,4B5
623E:  MOVFF  2CD,4B4
6242:  CLRF   xBB
6244:  CLRF   xBA
6246:  CLRF   xB9
6248:  CLRF   xB8
624A:  MOVLB  0
624C:  CALL   47FC
6250:  BTFSC  FD8.2
6252:  BRA    6258
6254:  MOVLB  4
6256:  BRA    62A2
6258:  MOVLB  4
625A:  CLRF   xB7
625C:  MOVLW  50
625E:  MOVWF  xB6
6260:  MOVLW  43
6262:  MOVWF  xB5
6264:  MOVLW  90
6266:  MOVWF  xB4
6268:  MOVFF  4AC,4BB
626C:  MOVFF  4AB,4BA
6270:  MOVFF  4AA,4B9
6274:  MOVFF  4A9,4B8
6278:  MOVLB  0
627A:  CALL   47FC
627E:  BTFSC  FD8.0
6280:  BRA    6286
6282:  MOVLB  4
6284:  BRA    62A2
....................             strcpy(Co, "null"); 
6286:  MOVLW  02
6288:  MOVWF  FEA
628A:  MOVLW  F3
628C:  MOVWF  FE9
628E:  MOVLW  00
6290:  CALL   00C6
6294:  TBLRD*-
6296:  TBLRD*+
6298:  MOVF   FF5,W
629A:  MOVWF  FEE
629C:  IORLW  00
629E:  BNZ   6296
62A0:  MOVLB  4
....................     } 
62A2:  BRA    640C
62A4:  MOVLB  0
....................     else 
....................     { 
....................         num_co++; 
62A6:  MOVLB  2
62A8:  INCF   x51,F
....................         co = (co != 0) ? co : Random(0.01, 21); 
62AA:  MOVFF  4AC,4B7
62AE:  MOVFF  4AB,4B6
62B2:  MOVFF  4AA,4B5
62B6:  MOVFF  4A9,4B4
62BA:  MOVLB  4
62BC:  CLRF   xBB
62BE:  CLRF   xBA
62C0:  CLRF   xB9
62C2:  CLRF   xB8
62C4:  MOVLB  0
62C6:  CALL   47FC
62CA:  BZ    62DE
62CC:  MOVFF  4A9,00
62D0:  MOVFF  4AA,01
62D4:  MOVFF  4AB,02
62D8:  MOVFF  4AC,03
62DC:  BRA    6302
62DE:  MOVLW  0A
62E0:  MOVLB  4
62E2:  MOVWF  xB3
62E4:  MOVLW  D7
62E6:  MOVWF  xB2
62E8:  MOVLW  23
62EA:  MOVWF  xB1
62EC:  MOVLW  78
62EE:  MOVWF  xB0
62F0:  CLRF   xB7
62F2:  CLRF   xB6
62F4:  MOVLW  28
62F6:  MOVWF  xB5
62F8:  MOVLW  83
62FA:  MOVWF  xB4
62FC:  MOVLB  0
62FE:  CALL   54A6
6302:  MOVFF  03,4AC
6306:  MOVFF  02,4AB
630A:  MOVFF  01,4AA
630E:  MOVFF  00,4A9
....................         buf_co = co; 
6312:  MOVFF  4AC,2DC
6316:  MOVFF  4AB,2DB
631A:  MOVFF  4AA,2DA
631E:  MOVFF  4A9,2D9
....................         Tb_co = (Tb_co * (num_co - 1) + co) / num_co; 
6322:  MOVLW  01
6324:  MOVLB  2
6326:  SUBWF  x51,W
6328:  MOVLB  4
632A:  CLRF   xCA
632C:  MOVWF  xC9
632E:  MOVLB  0
6330:  CALL   44A8
6334:  MOVFF  2D0,4CC
6338:  MOVFF  2CF,4CB
633C:  MOVFF  2CE,4CA
6340:  MOVFF  2CD,4C9
6344:  MOVFF  03,4D0
6348:  MOVFF  02,4CF
634C:  MOVFF  01,4CE
6350:  MOVFF  00,4CD
6354:  CALL   44DE
6358:  MOVFF  03,4B3
635C:  MOVFF  02,4B2
6360:  MOVFF  01,4B1
6364:  MOVFF  00,4B0
6368:  BCF    FD8.1
636A:  MOVFF  03,4CA
636E:  MOVFF  02,4C9
6372:  MOVFF  01,4C8
6376:  MOVFF  00,4C7
637A:  MOVFF  4AC,4CE
637E:  MOVFF  4AB,4CD
6382:  MOVFF  4AA,4CC
6386:  MOVFF  4A9,4CB
638A:  CALL   4D36
638E:  MOVFF  03,4B3
6392:  MOVFF  02,4B2
6396:  MOVFF  01,4B1
639A:  MOVFF  00,4B0
639E:  MOVLB  4
63A0:  CLRF   xCA
63A2:  MOVFF  251,4C9
63A6:  MOVLB  0
63A8:  CALL   44A8
63AC:  MOVFF  4B3,4CC
63B0:  MOVFF  4B2,4CB
63B4:  MOVFF  4B1,4CA
63B8:  MOVFF  4B0,4C9
63BC:  MOVFF  03,4D0
63C0:  MOVFF  02,4CF
63C4:  MOVFF  01,4CE
63C8:  MOVFF  00,4CD
63CC:  CALL   45D4
63D0:  MOVFF  03,2D0
63D4:  MOVFF  02,2CF
63D8:  MOVFF  01,2CE
63DC:  MOVFF  00,2CD
....................         sprintf(Co, "%f", Tb_co); 
63E0:  MOVLW  02
63E2:  MOVLB  2
63E4:  MOVWF  x3A
63E6:  MOVLW  F3
63E8:  MOVWF  x39
63EA:  MOVLW  89
63EC:  MOVWF  FE9
63EE:  MOVFF  2D0,4B3
63F2:  MOVFF  2CF,4B2
63F6:  MOVFF  2CE,4B1
63FA:  MOVFF  2CD,4B0
63FE:  MOVLW  02
6400:  MOVLB  4
6402:  MOVWF  xB4
6404:  MOVLB  0
6406:  CALL   55C0
640A:  MOVLB  4
....................     } 
....................     count_a = 0; 
640C:  CLRF   xAD
....................     // --------- Ket Thuc kiem tra loi tra ve NULL --------- // 
....................     delay_ms(2000); 
640E:  MOVLW  08
6410:  MOVWF  xB0
6412:  MOVLW  FA
6414:  MOVWF  xBA
6416:  MOVLB  0
6418:  CALL   0482
641C:  MOVLB  4
641E:  DECFSZ xB0,F
6420:  BRA    6412
....................     num++; 
6422:  MOVLB  2
6424:  INCF   x4E,F
....................     PM25 = (PM25 * (num - 1) + _ketquars485(3)) / num; 
6426:  MOVLW  01
6428:  SUBWF  x4E,W
642A:  MOVLB  4
642C:  CLRF   xCA
642E:  MOVWF  xC9
6430:  MOVLB  0
6432:  CALL   44A8
6436:  MOVFF  2B0,4CC
643A:  MOVFF  2AF,4CB
643E:  MOVFF  2AE,4CA
6442:  MOVFF  2AD,4C9
6446:  MOVFF  03,4D0
644A:  MOVFF  02,4CF
644E:  MOVFF  01,4CE
6452:  MOVFF  00,4CD
6456:  CALL   44DE
645A:  MOVFF  03,4B3
645E:  MOVFF  02,4B2
6462:  MOVFF  01,4B1
6466:  MOVFF  00,4B0
646A:  MOVLW  03
646C:  MOVLB  4
646E:  MOVWF  xB4
6470:  MOVLB  0
6472:  CALL   5076
6476:  MOVFF  FEA,4B5
647A:  MOVFF  FE9,4B4
647E:  BCF    FD8.1
6480:  MOVFF  4B3,4CA
6484:  MOVFF  4B2,4C9
6488:  MOVFF  4B1,4C8
648C:  MOVFF  4B0,4C7
6490:  MOVFF  03,4CE
6494:  MOVFF  02,4CD
6498:  MOVFF  01,4CC
649C:  MOVFF  00,4CB
64A0:  CALL   4D36
64A4:  MOVFF  4B5,FEA
64A8:  MOVFF  4B4,FE9
64AC:  MOVFF  03,4B3
64B0:  MOVFF  02,4B2
64B4:  MOVFF  01,4B1
64B8:  MOVFF  00,4B0
64BC:  MOVLB  4
64BE:  CLRF   xCA
64C0:  MOVFF  24E,4C9
64C4:  MOVLB  0
64C6:  CALL   44A8
64CA:  MOVFF  4B3,4CC
64CE:  MOVFF  4B2,4CB
64D2:  MOVFF  4B1,4CA
64D6:  MOVFF  4B0,4C9
64DA:  MOVFF  03,4D0
64DE:  MOVFF  02,4CF
64E2:  MOVFF  01,4CE
64E6:  MOVFF  00,4CD
64EA:  CALL   45D4
64EE:  MOVFF  03,2B0
64F2:  MOVFF  02,2AF
64F6:  MOVFF  01,2AE
64FA:  MOVFF  00,2AD
....................     delay_ms(2000); 
64FE:  MOVLW  08
6500:  MOVLB  4
6502:  MOVWF  xB0
6504:  MOVLW  FA
6506:  MOVWF  xBA
6508:  MOVLB  0
650A:  CALL   0482
650E:  MOVLB  4
6510:  DECFSZ xB0,F
6512:  BRA    6504
....................     PM10 = (PM10 * (num - 1) + _ketquars485(4)) / num; 
6514:  MOVLW  01
6516:  MOVLB  2
6518:  SUBWF  x4E,W
651A:  MOVLB  4
651C:  CLRF   xCA
651E:  MOVWF  xC9
6520:  MOVLB  0
6522:  CALL   44A8
6526:  MOVFF  2B4,4CC
652A:  MOVFF  2B3,4CB
652E:  MOVFF  2B2,4CA
6532:  MOVFF  2B1,4C9
6536:  MOVFF  03,4D0
653A:  MOVFF  02,4CF
653E:  MOVFF  01,4CE
6542:  MOVFF  00,4CD
6546:  CALL   44DE
654A:  MOVFF  03,4B3
654E:  MOVFF  02,4B2
6552:  MOVFF  01,4B1
6556:  MOVFF  00,4B0
655A:  MOVLW  04
655C:  MOVLB  4
655E:  MOVWF  xB4
6560:  MOVLB  0
6562:  CALL   5076
6566:  MOVFF  FEA,4B5
656A:  MOVFF  FE9,4B4
656E:  BCF    FD8.1
6570:  MOVFF  4B3,4CA
6574:  MOVFF  4B2,4C9
6578:  MOVFF  4B1,4C8
657C:  MOVFF  4B0,4C7
6580:  MOVFF  03,4CE
6584:  MOVFF  02,4CD
6588:  MOVFF  01,4CC
658C:  MOVFF  00,4CB
6590:  CALL   4D36
6594:  MOVFF  4B5,FEA
6598:  MOVFF  4B4,FE9
659C:  MOVFF  03,4B3
65A0:  MOVFF  02,4B2
65A4:  MOVFF  01,4B1
65A8:  MOVFF  00,4B0
65AC:  MOVLB  4
65AE:  CLRF   xCA
65B0:  MOVFF  24E,4C9
65B4:  MOVLB  0
65B6:  CALL   44A8
65BA:  MOVFF  4B3,4CC
65BE:  MOVFF  4B2,4CB
65C2:  MOVFF  4B1,4CA
65C6:  MOVFF  4B0,4C9
65CA:  MOVFF  03,4D0
65CE:  MOVFF  02,4CF
65D2:  MOVFF  01,4CE
65D6:  MOVFF  00,4CD
65DA:  CALL   45D4
65DE:  MOVFF  03,2B4
65E2:  MOVFF  02,2B3
65E6:  MOVFF  01,2B2
65EA:  MOVFF  00,2B1
....................     delay_ms(2000); 
65EE:  MOVLW  08
65F0:  MOVLB  4
65F2:  MOVWF  xB0
65F4:  MOVLW  FA
65F6:  MOVWF  xBA
65F8:  MOVLB  0
65FA:  CALL   0482
65FE:  MOVLB  4
6600:  DECFSZ xB0,F
6602:  BRA    65F4
....................     LUX = _ketquars485(5); 
6604:  MOVLW  05
6606:  MOVWF  xB4
6608:  MOVLB  0
660A:  CALL   5076
660E:  MOVFF  03,2B8
6612:  MOVFF  02,2B7
6616:  MOVFF  01,2B6
661A:  MOVFF  00,2B5
....................     delay_ms(2000); 
661E:  MOVLW  08
6620:  MOVLB  4
6622:  MOVWF  xB0
6624:  MOVLW  FA
6626:  MOVWF  xBA
6628:  MOVLB  0
662A:  CALL   0482
662E:  MOVLB  4
6630:  DECFSZ xB0,F
6632:  BRA    6624
....................     Noise = _ketquars485(6); 
6634:  MOVLW  06
6636:  MOVWF  xB4
6638:  MOVLB  0
663A:  CALL   5076
663E:  MOVFF  03,2C4
6642:  MOVFF  02,2C3
6646:  MOVFF  01,2C2
664A:  MOVFF  00,2C1
....................     delay_ms(2000); 
664E:  MOVLW  08
6650:  MOVLB  4
6652:  MOVWF  xB0
6654:  MOVLW  FA
6656:  MOVWF  xBA
6658:  MOVLB  0
665A:  CALL   0482
665E:  MOVLB  4
6660:  DECFSZ xB0,F
6662:  BRA    6654
....................     Wind = (int)_ketquars485(7); 
6664:  MOVLW  07
6666:  MOVWF  xB4
6668:  MOVLB  0
666A:  CALL   5076
666E:  MOVFF  03,4B3
6672:  MOVFF  02,4B2
6676:  MOVFF  01,4B1
667A:  MOVFF  00,4B0
667E:  CALL   577C
6682:  MOVFF  01,2DD
....................     delay_ms(2000); 
6686:  MOVLW  08
6688:  MOVLB  4
668A:  MOVWF  xB0
668C:  MOVLW  FA
668E:  MOVWF  xBA
6690:  MOVLB  0
6692:  CALL   0482
6696:  MOVLB  4
6698:  DECFSZ xB0,F
669A:  BRA    668C
....................     PA = Random(1010, 1014); 
669C:  CLRF   xB3
669E:  MOVLW  80
66A0:  MOVWF  xB2
66A2:  MOVLW  7C
66A4:  MOVWF  xB1
66A6:  MOVLW  88
66A8:  MOVWF  xB0
66AA:  CLRF   xB7
66AC:  MOVLW  80
66AE:  MOVWF  xB6
66B0:  MOVLW  7D
66B2:  MOVWF  xB5
66B4:  MOVLW  88
66B6:  MOVWF  xB4
66B8:  MOVLB  0
66BA:  CALL   54A6
66BE:  MOVFF  03,2AC
66C2:  MOVFF  02,2AB
66C6:  MOVFF  01,2AA
66CA:  MOVFF  00,2A9
....................     float *Value = _ketquars485_Temp_Humi(9); 
66CE:  MOVLW  09
66D0:  MOVLB  4
66D2:  MOVWF  xB0
66D4:  MOVLB  0
66D6:  GOTO   57FE
66DA:  MOVFF  02,4AF
66DE:  MOVFF  01,4AE
....................     Temp_485 = Value[0]; 
66E2:  MOVLB  4
66E4:  MOVFF  4AE,FE9
66E8:  MOVFF  4AF,FEA
66EC:  MOVFF  FEF,2B9
66F0:  MOVFF  FEC,2BA
66F4:  MOVFF  FEC,2BB
66F8:  MOVFF  FEC,2BC
....................     Humi_485 = Value[1]; 
66FC:  MOVLW  04
66FE:  ADDWF  xAE,W
6700:  MOVWF  FE9
6702:  MOVLW  00
6704:  ADDWFC xAF,W
6706:  MOVWF  FEA
6708:  MOVFF  FEF,2BD
670C:  MOVFF  FEC,2BE
6710:  MOVFF  FEC,2BF
6714:  MOVFF  FEC,2C0
6718:  MOVLB  0
671A:  RETURN 0
.................... } 
....................  
.................... // ********* Ham cap nhap gio sau 1 ngay ********* // 
.................... void update_time_1day(BYTE hour) 
.................... { 
....................     if (hour != 0) 
*
6ADE:  MOVLB  4
6AE0:  MOVF   xA1,F
6AE2:  BZ    6AF2
....................         check_hour == 1; 
6AE4:  MOVLB  2
6AE6:  DECFSZ xDE,W
6AE8:  BRA    6AEC
6AEA:  BRA    6AEE
6AEC:  MOVLW  00
6AEE:  BRA    6B0C
6AF0:  MOVLB  4
....................     else if (hour == 0 && check_hour == 1) 
6AF2:  MOVF   xA1,F
6AF4:  BNZ   6B0E
6AF6:  MOVLB  2
6AF8:  DECFSZ xDE,W
6AFA:  BRA    6AFE
6AFC:  BRA    6B02
6AFE:  MOVLB  4
6B00:  BRA    6B0E
....................     { 
....................         capnhat_gio(); 
6B02:  MOVLB  0
6B04:  CALL   40F2
....................         check_hour = 0; 
6B08:  MOVLB  2
6B0A:  CLRF   xDE
6B0C:  MOVLB  4
....................     } 
6B0E:  MOVLB  0
6B10:  GOTO   731C (RETURN)
.................... } 
....................  
.................... void main(void) 
*
6B66:  CLRF   FF8
6B68:  BCF    FD0.7
6B6A:  BSF    07.7
6B6C:  BCF    F95.4
6B6E:  BSF    F8C.4
6B70:  BCF    F95.4
6B72:  BSF    F8C.4
6B74:  BCF    F94.0
6B76:  BSF    F8B.0
6B78:  BSF    FB8.3
6B7A:  MOVLW  E1
6B7C:  MOVWF  FAF
6B7E:  MOVLW  04
6B80:  MOVWF  FB0
6B82:  MOVLW  A6
6B84:  MOVWF  FAC
6B86:  MOVLW  90
6B88:  MOVWF  FAB
6B8A:  BSF    F96.2
6B8C:  BCF    F96.0
6B8E:  BCF    F96.1
6B90:  BCF    F8D.1
6B92:  MOVLB  2
6B94:  CLRF   x3A
6B96:  CLRF   x39
6B98:  CLRF   x40
6B9A:  CLRF   x3F
6B9C:  CLRF   x42
6B9E:  CLRF   x41
6BA0:  CLRF   x44
6BA2:  CLRF   x43
6BA4:  CLRF   x46
6BA6:  CLRF   x45
6BA8:  CLRF   x47
6BAA:  CLRF   x48
6BAC:  CLRF   x49
6BAE:  CLRF   x4A
6BB0:  CLRF   x4B
6BB2:  CLRF   x4C
6BB4:  CLRF   x4D
6BB6:  CLRF   x4E
6BB8:  CLRF   x4F
6BBA:  CLRF   x50
6BBC:  CLRF   x51
6BBE:  CLRF   xA8
6BC0:  CLRF   xAC
6BC2:  CLRF   xAB
6BC4:  CLRF   xAA
6BC6:  CLRF   xA9
6BC8:  CLRF   xB0
6BCA:  CLRF   xAF
6BCC:  CLRF   xAE
6BCE:  CLRF   xAD
6BD0:  CLRF   xB4
6BD2:  CLRF   xB3
6BD4:  CLRF   xB2
6BD6:  CLRF   xB1
6BD8:  CLRF   xB8
6BDA:  CLRF   xB7
6BDC:  CLRF   xB6
6BDE:  CLRF   xB5
6BE0:  CLRF   xBC
6BE2:  CLRF   xBB
6BE4:  CLRF   xBA
6BE6:  CLRF   xB9
6BE8:  CLRF   xC0
6BEA:  CLRF   xBF
6BEC:  CLRF   xBE
6BEE:  CLRF   xBD
6BF0:  CLRF   xC4
6BF2:  CLRF   xC3
6BF4:  CLRF   xC2
6BF6:  CLRF   xC1
6BF8:  CLRF   xC8
6BFA:  CLRF   xC7
6BFC:  CLRF   xC6
6BFE:  CLRF   xC5
6C00:  CLRF   xCC
6C02:  CLRF   xCB
6C04:  CLRF   xCA
6C06:  CLRF   xC9
6C08:  CLRF   xD0
6C0A:  CLRF   xCF
6C0C:  CLRF   xCE
6C0E:  CLRF   xCD
6C10:  CLRF   xD4
6C12:  CLRF   xD3
6C14:  CLRF   xD2
6C16:  CLRF   xD1
6C18:  CLRF   xD8
6C1A:  CLRF   xD7
6C1C:  CLRF   xD6
6C1E:  CLRF   xD5
6C20:  CLRF   xDC
6C22:  CLRF   xDB
6C24:  CLRF   xDA
6C26:  CLRF   xD9
6C28:  CLRF   xDD
6C2A:  CLRF   xDE
6C2C:  MOVLB  3
6C2E:  CLRF   x43
6C30:  CLRF   x46
6C32:  CLRF   x48
6C34:  CLRF   x49
6C36:  CLRF   x4A
6C38:  CLRF   x4B
6C3A:  MOVLW  01
6C3C:  MOVWF  xA2
6C3E:  CLRF   xA3
6C40:  MOVLB  2
6C42:  BCF    x20.4
6C44:  BCF    x20.5
6C46:  MOVF   FC1,W
6C48:  ANDLW  C0
6C4A:  IORLW  0F
6C4C:  MOVWF  FC1
6C4E:  MOVLW  07
6C50:  MOVWF  FB4
6C52:  CLRF   1A
6C54:  CLRF   1B
6C56:  MOVLW  04
6C58:  MOVWF  x52
6C5A:  MOVLW  03
6C5C:  MOVWF  x53
6C5E:  MOVLW  02
6C60:  MOVWF  x54
6C62:  MOVLW  01
6C64:  MOVWF  x55
6C66:  MOVWF  x56
6C68:  MOVWF  x57
6C6A:  MOVWF  x58
6C6C:  MOVWF  x59
6C6E:  MOVLW  03
6C70:  MOVWF  x5A
6C72:  MOVWF  x5B
6C74:  MOVWF  x5C
6C76:  MOVWF  x5D
6C78:  MOVWF  x5E
6C7A:  MOVWF  x5F
6C7C:  MOVWF  x60
6C7E:  MOVWF  x61
.................... { 
....................     port_b_pullups(TRUE); 
6C80:  BCF    FF1.7
....................     output_high(PIN_C2); 
6C82:  BCF    F94.2
6C84:  BSF    F8B.2
....................     delay_ms(2000); 
6C86:  MOVLW  08
6C88:  MOVLB  4
6C8A:  MOVWF  xA1
6C8C:  MOVLW  FA
6C8E:  MOVWF  xBA
6C90:  MOVLB  0
6C92:  CALL   0482
6C96:  MOVLB  4
6C98:  DECFSZ xA1,F
6C9A:  BRA    6C8C
....................     output_low(PIN_C2); 
6C9C:  BCF    F94.2
6C9E:  BCF    F8B.2
....................     output_high(PIN_A4); 
6CA0:  BCF    F92.4
6CA2:  BSF    F89.4
....................     for (int y = 0; y < 29; y++) 
6CA4:  CLRF   x94
6CA6:  MOVF   x94,W
6CA8:  SUBLW  1C
6CAA:  BNC   6CD0
....................     { 
....................         delay_ms(1000); 
6CAC:  MOVLW  04
6CAE:  MOVWF  xA1
6CB0:  MOVLW  FA
6CB2:  MOVWF  xBA
6CB4:  MOVLB  0
6CB6:  CALL   0482
6CBA:  MOVLB  4
6CBC:  DECFSZ xA1,F
6CBE:  BRA    6CB0
....................         fprintf(UART2, "."); 
6CC0:  MOVLW  2E
6CC2:  MOVWF  xCB
6CC4:  MOVLB  0
6CC6:  CALL   04AC
6CCA:  MOVLB  4
6CCC:  INCF   x94,F
6CCE:  BRA    6CA6
....................     } 
....................  
....................     // fprintf(UART2, "Sim7600 On\n"); 
....................     caidatngatvatimer(); 
6CD0:  MOVLB  0
6CD2:  GOTO   04FE
....................     int1 kiemtraSD = 0; 
6CD6:  MOVLB  4
6CD8:  BCF    x95.0
....................     kiemtraSD = checkthesd(); 
6CDA:  MOVLB  0
6CDC:  GOTO   100A
6CE0:  MOVLB  4
6CE2:  BCF    x95.0
6CE4:  BTFSC  01.0
6CE6:  BSF    x95.0
....................     // testsdhc(); 
....................     if (kiemtraSD == 1) 
6CE8:  BTFSS  x95.0
6CEA:  BRA    6D20
....................     { 
....................         PrintURL("/url.txt"); 
6CEC:  MOVLW  04
6CEE:  MOVWF  FEA
6CF0:  MOVLW  96
6CF2:  MOVWF  FE9
6CF4:  MOVLW  09
6CF6:  MOVWF  01
6CF8:  CLRF   FF7
6CFA:  MOVLW  00
6CFC:  MOVLB  0
6CFE:  CALL   00DC
6D02:  TBLRD*-
6D04:  TBLRD*+
6D06:  MOVFF  FF5,FEE
6D0A:  DECFSZ 01,F
6D0C:  BRA    6D04
6D0E:  MOVLW  04
6D10:  MOVLB  4
6D12:  MOVWF  xA4
6D14:  MOVLW  96
6D16:  MOVWF  xA3
6D18:  MOVLB  0
6D1A:  GOTO   3A1A
6D1E:  MOVLB  4
....................     } 
....................     dodaiURL = read_eeprom(0xA0); 
6D20:  MOVFF  FF2,4A1
6D24:  BCF    FF2.7
6D26:  MOVLW  A0
6D28:  MOVWF  FA9
6D2A:  BCF    FA6.6
6D2C:  BCF    FA6.7
6D2E:  BSF    FA6.0
6D30:  MOVF   FA8,W
6D32:  BTFSC  xA1.7
6D34:  BSF    FF2.7
6D36:  MOVLB  2
6D38:  MOVWF  xA8
....................     eeprom_read_string(0x04, URLeeprom, dodaiURL); 
6D3A:  MOVLW  04
6D3C:  MOVLB  4
6D3E:  MOVWF  xA1
6D40:  MOVLW  02
6D42:  MOVWF  xA3
6D44:  MOVLW  71
6D46:  MOVWF  xA2
6D48:  MOVFF  2A8,4A4
6D4C:  MOVLB  0
6D4E:  GOTO   3A78
....................     fprintf(UART2, "URLeeprom: *%s*\n", URLeeprom); 
6D52:  MOVLW  A0
6D54:  MOVWF  FF6
6D56:  MOVLW  03
6D58:  MOVWF  FF7
6D5A:  MOVLW  0C
6D5C:  MOVLB  4
6D5E:  MOVWF  xC5
6D60:  MOVLB  0
6D62:  CALL   3AD8
6D66:  MOVLW  02
6D68:  MOVWF  FEA
6D6A:  MOVLW  71
6D6C:  MOVWF  FE9
6D6E:  CALL   3B02
6D72:  MOVLW  2A
6D74:  MOVLB  4
6D76:  MOVWF  xCB
6D78:  MOVLB  0
6D7A:  CALL   04AC
6D7E:  MOVLW  0A
6D80:  MOVLB  4
6D82:  MOVWF  xCB
6D84:  MOVLB  0
6D86:  CALL   04AC
....................     rcount1 = 1; 
6D8A:  MOVLW  01
6D8C:  MOVLB  2
6D8E:  MOVWF  x47
....................     rcount3 = 0; 
6D90:  CLRF   x49
....................     rcount4 = 1; 
6D92:  MOVWF  x48
....................     rcount5 = 1; 
6D94:  MOVWF  x4A
....................     setcapnhat = 1; //setcapnhat =30 //60 : mac dinh 30 // 60 phut truyen du lieu 1 lan, neu module sim khong phan hoi 
6D96:  MOVLB  3
6D98:  MOVWF  xA2
....................     setup_wdt(WDT_128S); 
6D9A:  BSF    FD1.0
....................     error_get = 0; 
6D9C:  MOVLB  2
6D9E:  CLRF   x4B
....................     capnhat_gio(); 
6DA0:  MOVLB  0
6DA2:  CALL   40F2
....................     Update_Current_Date_Time(); 
6DA6:  CALL   434E
....................     while (1) 
....................     { 
....................         restart_wdt(); 
6DAA:  CLRWDT
....................         kiemtraread = 0; 
6DAC:  MOVLB  2
6DAE:  BCF    x20.4
....................         docadc(); 
6DB0:  MOVLB  0
6DB2:  GOTO   4732
....................         Update_Current_Date_Time(); 
6DB6:  CALL   434E
....................         // fprintf(UART2,"%u-%u-%u-%u-%u-%u-setcapnhat=%u\n",day,  month, yr, hrs, min,  sec,setcapnhat); 
....................         if ((month > 12) || (day > 31) || (hrs > 24) || (min > 60) || (sec > 60)) 
6DBA:  MOVLB  2
6DBC:  MOVF   x66,W
6DBE:  SUBLW  0C
6DC0:  BNC   6DDA
6DC2:  MOVF   x65,W
6DC4:  SUBLW  1F
6DC6:  BNC   6DDA
6DC8:  MOVF   x64,W
6DCA:  SUBLW  18
6DCC:  BNC   6DDA
6DCE:  MOVF   x63,W
6DD0:  SUBLW  3C
6DD2:  BNC   6DDA
6DD4:  MOVF   x62,W
6DD6:  SUBLW  3C
6DD8:  BC    6E2C
....................         { 
....................             if (setcapnhat < 3) 
6DDA:  MOVLB  3
6DDC:  MOVF   xA2,W
6DDE:  SUBLW  02
6DE0:  BNC   6DEC
....................                 capnhat_gio(); 
6DE2:  MOVLB  0
6DE4:  CALL   40F2
6DE8:  BRA    6E2E
6DEA:  MOVLB  3
....................             else 
....................             { 
....................                 // output_high(PIN_A4); 
....................                 fprintf(PORT1SIM, "*ondata#"); 
6DEC:  MOVLW  B2
6DEE:  MOVWF  FF6
6DF0:  MOVLW  03
6DF2:  MOVWF  FF7
6DF4:  MOVLB  0
6DF6:  CALL   3B28
....................                 rcount3 = (check_rc3 == 0) ? 0 : rcount3; 
6DFA:  MOVLB  3
6DFC:  MOVF   x4B,F
6DFE:  BNZ   6E04
6E00:  MOVLW  00
6E02:  BRA    6E08
6E04:  MOVLB  2
6E06:  MOVF   x49,W
6E08:  MOVLB  2
6E0A:  MOVWF  x49
....................                 check_rc3 = 1; 
6E0C:  MOVLW  01
6E0E:  MOVLB  3
6E10:  MOVWF  x4B
....................                 if (rcount3 == 1) 
6E12:  MOVLB  2
6E14:  DECFSZ x49,W
6E16:  BRA    6E2C
....................                 { 
....................                     capnhat_gio(); 
6E18:  MOVLB  0
6E1A:  CALL   40F2
....................                     // output_low(PIN_A4); 
....................                     rcount3 = 0; 
6E1E:  MOVLB  2
6E20:  CLRF   x49
....................                     rcount = 0; 
6E22:  CLRF   x40
6E24:  CLRF   x3F
....................                     check_rc3 = 0; 
6E26:  MOVLB  3
6E28:  CLRF   x4B
6E2A:  MOVLB  2
6E2C:  MOVLB  0
....................                 } 
....................             } 
....................         } 
....................         delay_ms(1000); 
6E2E:  MOVLW  04
6E30:  MOVLB  4
6E32:  MOVWF  xA1
6E34:  MOVLW  FA
6E36:  MOVWF  xBA
6E38:  MOVLB  0
6E3A:  CALL   0482
6E3E:  MOVLB  4
6E40:  DECFSZ xA1,F
6E42:  BRA    6E34
....................         // ------ Kiem tra acquy ------ // 
....................         if (power1 > 11) 
6E44:  CLRF   xB7
6E46:  CLRF   xB6
6E48:  MOVLW  30
6E4A:  MOVWF  xB5
6E4C:  MOVLW  82
6E4E:  MOVWF  xB4
6E50:  MOVFF  23E,4BB
6E54:  MOVFF  23D,4BA
6E58:  MOVFF  23C,4B9
6E5C:  MOVFF  23B,4B8
6E60:  MOVLB  0
6E62:  CALL   47FC
6E66:  BNC   6E72
....................             Check_Pin = 1; 
6E68:  MOVLW  01
6E6A:  MOVLB  3
6E6C:  MOVWF  x4A
6E6E:  BRA    6E78
6E70:  MOVLB  0
....................         else 
....................             Check_Pin = 2; 
6E72:  MOVLW  02
6E74:  MOVLB  3
6E76:  MOVWF  x4A
....................         // Lay gia tri TB 
....................         if (min % 2 == 0 && rcount5 != 0 && min % setcapnhat != 0 && setcapnhat >= 5) 
6E78:  MOVLB  2
6E7A:  MOVF   x63,W
6E7C:  ANDLW  01
6E7E:  BNZ   6EBA
6E80:  MOVF   x4A,F
6E82:  BZ    6EBA
6E84:  MOVFF  263,4CB
6E88:  MOVFF  3A2,4CC
6E8C:  MOVLB  0
6E8E:  CALL   3EF0
6E92:  MOVF   00,F
6E94:  BTFSS  FD8.2
6E96:  BRA    6E9C
6E98:  MOVLB  2
6E9A:  BRA    6EBA
6E9C:  MOVLB  3
6E9E:  MOVF   xA2,W
6EA0:  SUBLW  04
6EA2:  BTFSS  FD8.0
6EA4:  BRA    6EAA
6EA6:  MOVLB  2
6EA8:  BRA    6EBA
....................         { 
....................             rcount5 = 0; 
6EAA:  MOVLB  2
6EAC:  CLRF   x4A
....................             rcount = 0; 
6EAE:  CLRF   x40
6EB0:  CLRF   x3F
....................             Value_Sensor_RS485(); 
6EB2:  MOVLB  0
6EB4:  CALL   5B82
6EB8:  MOVLB  2
....................             //!            fprintf(UART2, "SO2 : %s\nNO2: %s\nCO : %s\nPM25 : %f\nPM10 : %f\nLUX : %f\nNoise : %f\nPA : %f\nHuong Gio : %d\nNhietdo : %f\nDoam : %f\n", So2, No2, Co, PM25, PM10, LUX, Noise, PA, Wind, Temp_485, Humi_485); 
....................         } 
....................  
....................         // ------ Doc cam bien va bat data sim truoc 1 phut ------ // 
....................         if ((((min == 59) ? 0 : (min + 1)) % setcapnhat == 0) && rcount4 != 0) 
6EBA:  MOVF   x63,W
6EBC:  SUBLW  3B
6EBE:  BNZ   6EC6
6EC0:  CLRF   03
6EC2:  MOVLW  00
6EC4:  BRA    6ECC
6EC6:  MOVLW  01
6EC8:  ADDWF  x63,W
6ECA:  CLRF   03
6ECC:  MOVLB  4
6ECE:  MOVWF  xA1
6ED0:  MOVFF  03,4A2
6ED4:  MOVFF  03,4C0
6ED8:  MOVWF  xBF
6EDA:  CLRF   xC2
6EDC:  MOVFF  3A2,4C1
6EE0:  MOVLB  0
6EE2:  CALL   53EC
6EE6:  MOVFF  00,4A1
6EEA:  MOVLB  4
6EEC:  MOVFF  03,4A2
6EF0:  MOVF   xA1,F
6EF2:  BNZ   6F98
6EF4:  MOVF   xA2,F
6EF6:  BNZ   6F98
6EF8:  MOVLB  2
6EFA:  MOVF   x48,F
6EFC:  BTFSS  FD8.2
6EFE:  BRA    6F04
6F00:  MOVLB  4
6F02:  BRA    6F98
....................         { 
....................             // ------ Acquy day, doc cam bien dung thoi gian cap nhap ------ // 
....................             if (Check_Pin == 1) 
6F04:  MOVLB  3
6F06:  DECFSZ x4A,W
6F08:  BRA    6F3A
....................             { 
....................                 if (setcapnhat >= 3) 
6F0A:  MOVF   xA2,W
6F0C:  SUBLW  02
6F0E:  BC    6F20
....................                     fprintf(PORT1SIM, "*ondata#"); 
6F10:  MOVLW  BC
6F12:  MOVWF  FF6
6F14:  MOVLW  03
6F16:  MOVWF  FF7
6F18:  MOVLB  0
6F1A:  CALL   3B28
6F1E:  MOVLB  3
....................                 if (setcapnhat < 5) 
6F20:  MOVF   xA2,W
6F22:  SUBLW  04
6F24:  BNC   6F2E
....................                     Value_Sensor_RS485(); 
6F26:  MOVLB  0
6F28:  CALL   5B82
6F2C:  MOVLB  3
.................... //!                  fprintf(UART2, "SO2 : %s\nNO2: %s\nCO : %s\nPM25 : %f\nPM10 : %f\nLUX : %f\nNoise : %f\nPA : %f\nHuong Gio : %d\nNhietdo : %f\nDoam : %f\n", So2, No2, Co, PM25, PM10, LUX, Noise, PA, Wind, Temp_485, Humi_485); 
....................                 // output_high(PIN_A4); 
....................                 rcount4 = 0; 
6F2E:  MOVLB  2
6F30:  CLRF   x48
....................                 rcount = 0; 
6F32:  CLRF   x40
6F34:  CLRF   x3F
....................             } 
6F36:  BRA    6F94
6F38:  MOVLB  3
....................             // ------ Acquy yeu, doc cam bien gap doi thoi gian cap nhap ------ // 
....................             else if (Check_Pin == 2) 
6F3A:  MOVF   x4A,W
6F3C:  SUBLW  02
6F3E:  BNZ   6F96
....................             { 
....................                 count_check++; 
6F40:  INCF   x48,F
....................                 fprintf(UART2, "Count check : %d", count_check); 
6F42:  MOVLW  C6
6F44:  MOVWF  FF6
6F46:  MOVLW  03
6F48:  MOVWF  FF7
6F4A:  MOVLW  0E
6F4C:  MOVLB  4
6F4E:  MOVWF  xC5
6F50:  MOVLB  0
6F52:  CALL   3AD8
6F56:  MOVFF  348,4C5
6F5A:  MOVLW  18
6F5C:  MOVLB  4
6F5E:  MOVWF  xC6
6F60:  MOVLB  0
6F62:  CALL   4FAE
....................                 if (count_check == 2) 
6F66:  MOVLB  3
6F68:  MOVF   x48,W
6F6A:  SUBLW  02
6F6C:  BNZ   6F8C
....................                 { 
....................                     if (setcapnhat >= 3) 
6F6E:  MOVF   xA2,W
6F70:  SUBLW  02
6F72:  BC    6F84
....................                         fprintf(PORT1SIM, "*ondata#"); 
6F74:  MOVLW  D8
6F76:  MOVWF  FF6
6F78:  MOVLW  03
6F7A:  MOVWF  FF7
6F7C:  MOVLB  0
6F7E:  CALL   3B28
6F82:  MOVLB  3
....................                     // output_high(PIN_A4); 
....................                     Value_Sensor_RS485(); 
6F84:  MOVLB  0
6F86:  CALL   5B82
6F8A:  MOVLB  3
....................                     // fprintf(UART2, "SO2 : %s\nNO2: %s\nCO : %s\nPM25 : %f\nPM10 : %f\nLUX : %f\nNoise : %f\nPA : %f\nHuong Gio : %d\nNhietdo : %f\nDoam : %f\n", So2, No2, Co, PM25, PM10, LUX, Noise, PA, Wind, Temp_485, Humi_485); 
....................                 } 
....................                 rcount4 = 0; 
6F8C:  MOVLB  2
6F8E:  CLRF   x48
....................                 rcount = 0; 
6F90:  CLRF   x40
6F92:  CLRF   x3F
6F94:  MOVLB  3
6F96:  MOVLB  4
....................             } 
....................         } 
....................  
....................         // ------ Gui du lieu cam bien qua sim ------ // 
....................         if ((min % setcapnhat == 0) && (rcount1 != 0)) 
6F98:  MOVFF  263,4CB
6F9C:  MOVFF  3A2,4CC
6FA0:  MOVLB  0
6FA2:  CALL   3EF0
6FA6:  MOVF   00,F
6FA8:  BNZ   6FEA
6FAA:  MOVLB  2
6FAC:  MOVF   x47,F
6FAE:  BTFSS  FD8.2
6FB0:  BRA    6FB6
6FB2:  MOVLB  0
6FB4:  BRA    6FEA
....................         { 
....................             // ------ Acquy day, gui du lieu dung thoi gian cap nhap ------ // 
....................             if (Check_Pin == 1) 
6FB6:  MOVLB  3
6FB8:  DECFSZ x4A,W
6FBA:  BRA    6FCC
....................             { 
....................                 bit_binhthuong = 1; 
6FBC:  MOVLW  01
6FBE:  MOVWF  xA3
....................                 rcount1 = 0; 
6FC0:  MOVLB  2
6FC2:  CLRF   x47
....................                 rcount = 0; 
6FC4:  CLRF   x40
6FC6:  CLRF   x3F
....................             } 
6FC8:  BRA    6FE6
6FCA:  MOVLB  3
....................             // ------ Acquy yeu, gui du lieu gap doi thoi gian cap nhap ------ // 
....................             else if (Check_Pin == 2) 
6FCC:  MOVF   x4A,W
6FCE:  SUBLW  02
6FD0:  BNZ   6FE8
....................             { 
....................                 count_check1++; 
6FD2:  INCF   x49,F
....................                 if (count_check1 == 2) 
6FD4:  MOVF   x49,W
6FD6:  SUBLW  02
6FD8:  BNZ   6FDE
....................                     bit_binhthuong = 1; 
6FDA:  MOVLW  01
6FDC:  MOVWF  xA3
....................                 rcount1 = 0; 
6FDE:  MOVLB  2
6FE0:  CLRF   x47
....................                 rcount = 0; 
6FE2:  CLRF   x40
6FE4:  CLRF   x3F
6FE6:  MOVLB  3
6FE8:  MOVLB  0
....................             } 
....................         } 
....................  
....................         if (bit_binhthuong == 1) 
6FEA:  MOVLB  3
6FEC:  DECFSZ xA3,W
6FEE:  BRA    72FC
....................         { 
....................             bit_binhthuong = 0; 
6FF0:  CLRF   xA3
....................             kiemtraread = 0; 
6FF2:  MOVLB  2
6FF4:  BCF    x20.4
....................             count_check1 = 0; 
6FF6:  MOVLB  3
6FF8:  CLRF   x49
....................             count_check = 0; 
6FFA:  CLRF   x48
....................             docdht22(); 
6FFC:  MOVLB  0
6FFE:  BRA    6834
....................             sprintf(querystring, "&url;%s?temp=%f&humi=%f&light=%f&noise=%f&pa=%f&pm25=%f&so2=%s&no2=%s&co=%s&pm10=%f&wind=%d&power=%f&tempin=%lu&humiin=%lu#", URLeeprom, Temp_485, Humi_485, LUX, Noise, PA, PM25, So2, No2, Co, PM10, Wind, power1, Temp, RH); 
7000:  MOVLW  03
7002:  MOVLB  2
7004:  MOVWF  x3A
7006:  MOVLW  A4
7008:  MOVWF  x39
700A:  MOVLW  E2
700C:  MOVWF  FF6
700E:  MOVLW  03
7010:  MOVWF  FF7
7012:  MOVLW  05
7014:  MOVLB  4
7016:  MOVWF  xA1
7018:  MOVLB  0
701A:  RCALL  68FA
701C:  MOVFF  23A,FEA
7020:  MOVFF  239,FE9
7024:  CLRF   FEF
7026:  MOVLW  02
7028:  MOVWF  FEA
702A:  MOVLW  71
702C:  MOVWF  FE9
702E:  CALL   3408
7032:  MOVLW  E9
7034:  MOVWF  FF6
7036:  MOVLW  03
7038:  MOVWF  FF7
703A:  MOVLW  06
703C:  MOVLB  4
703E:  MOVWF  xA1
7040:  MOVLB  0
7042:  RCALL  68FA
7044:  MOVLW  89
7046:  MOVWF  FE9
7048:  MOVFF  2BC,4B3
704C:  MOVFF  2BB,4B2
7050:  MOVFF  2BA,4B1
7054:  MOVFF  2B9,4B0
7058:  MOVLW  02
705A:  MOVLB  4
705C:  MOVWF  xB4
705E:  MOVLB  0
7060:  CALL   55C0
7064:  MOVLW  F1
7066:  MOVWF  FF6
7068:  MOVLW  03
706A:  MOVWF  FF7
706C:  MOVLW  06
706E:  MOVLB  4
7070:  MOVWF  xA1
7072:  MOVLB  0
7074:  RCALL  68FA
7076:  MOVLW  89
7078:  MOVWF  FE9
707A:  MOVFF  2C0,4B3
707E:  MOVFF  2BF,4B2
7082:  MOVFF  2BE,4B1
7086:  MOVFF  2BD,4B0
708A:  MOVLW  02
708C:  MOVLB  4
708E:  MOVWF  xB4
7090:  MOVLB  0
7092:  CALL   55C0
7096:  MOVLW  F9
7098:  MOVWF  FF6
709A:  MOVLW  03
709C:  MOVWF  FF7
709E:  MOVLW  07
70A0:  MOVLB  4
70A2:  MOVWF  xA1
70A4:  MOVLB  0
70A6:  RCALL  68FA
70A8:  MOVLW  89
70AA:  MOVWF  FE9
70AC:  MOVFF  2B8,4B3
70B0:  MOVFF  2B7,4B2
70B4:  MOVFF  2B6,4B1
70B8:  MOVFF  2B5,4B0
70BC:  MOVLW  02
70BE:  MOVLB  4
70C0:  MOVWF  xB4
70C2:  MOVLB  0
70C4:  CALL   55C0
70C8:  MOVLW  02
70CA:  MOVWF  FF6
70CC:  MOVLW  04
70CE:  MOVWF  FF7
70D0:  MOVLW  07
70D2:  MOVLB  4
70D4:  MOVWF  xA1
70D6:  MOVLB  0
70D8:  RCALL  68FA
70DA:  MOVLW  89
70DC:  MOVWF  FE9
70DE:  MOVFF  2C4,4B3
70E2:  MOVFF  2C3,4B2
70E6:  MOVFF  2C2,4B1
70EA:  MOVFF  2C1,4B0
70EE:  MOVLW  02
70F0:  MOVLB  4
70F2:  MOVWF  xB4
70F4:  MOVLB  0
70F6:  CALL   55C0
70FA:  MOVLW  0B
70FC:  MOVWF  FF6
70FE:  MOVLW  04
7100:  MOVWF  FF7
7102:  MOVLW  04
7104:  MOVLB  4
7106:  MOVWF  xA1
7108:  MOVLB  0
710A:  CALL   68FA
710E:  MOVLW  89
7110:  MOVWF  FE9
7112:  MOVFF  2AC,4B3
7116:  MOVFF  2AB,4B2
711A:  MOVFF  2AA,4B1
711E:  MOVFF  2A9,4B0
7122:  MOVLW  02
7124:  MOVLB  4
7126:  MOVWF  xB4
7128:  MOVLB  0
712A:  CALL   55C0
712E:  MOVLW  11
7130:  MOVWF  FF6
7132:  MOVLW  04
7134:  MOVWF  FF7
7136:  MOVLW  06
7138:  MOVLB  4
713A:  MOVWF  xA1
713C:  MOVLB  0
713E:  CALL   68FA
7142:  MOVLW  89
7144:  MOVWF  FE9
7146:  MOVFF  2B0,4B3
714A:  MOVFF  2AF,4B2
714E:  MOVFF  2AE,4B1
7152:  MOVFF  2AD,4B0
7156:  MOVLW  02
7158:  MOVLB  4
715A:  MOVWF  xB4
715C:  MOVLB  0
715E:  CALL   55C0
7162:  MOVLW  19
7164:  MOVWF  FF6
7166:  MOVLW  04
7168:  MOVWF  FF7
716A:  MOVLW  05
716C:  MOVLB  4
716E:  MOVWF  xA1
7170:  MOVLB  0
7172:  CALL   68FA
7176:  MOVFF  23A,FEA
717A:  MOVFF  239,FE9
717E:  CLRF   FEF
7180:  MOVLW  02
7182:  MOVWF  FEA
7184:  MOVLW  E9
7186:  MOVWF  FE9
7188:  CALL   3408
718C:  MOVLW  20
718E:  MOVWF  FF6
7190:  MOVLW  04
7192:  MOVWF  FF7
7194:  MOVLW  05
7196:  MOVLB  4
7198:  MOVWF  xA1
719A:  MOVLB  0
719C:  CALL   68FA
71A0:  MOVFF  23A,FEA
71A4:  MOVFF  239,FE9
71A8:  CLRF   FEF
71AA:  MOVLW  02
71AC:  MOVWF  FEA
71AE:  MOVLW  DF
71B0:  MOVWF  FE9
71B2:  CALL   3408
71B6:  MOVLW  27
71B8:  MOVWF  FF6
71BA:  MOVLW  04
71BC:  MOVWF  FF7
71BE:  MOVLW  04
71C0:  MOVLB  4
71C2:  MOVWF  xA1
71C4:  MOVLB  0
71C6:  CALL   68FA
71CA:  MOVFF  23A,FEA
71CE:  MOVFF  239,FE9
71D2:  CLRF   FEF
71D4:  MOVLW  02
71D6:  MOVWF  FEA
71D8:  MOVLW  F3
71DA:  MOVWF  FE9
71DC:  CALL   3408
71E0:  MOVLW  2D
71E2:  MOVWF  FF6
71E4:  MOVLW  04
71E6:  MOVWF  FF7
71E8:  MOVLW  06
71EA:  MOVLB  4
71EC:  MOVWF  xA1
71EE:  MOVLB  0
71F0:  CALL   68FA
71F4:  MOVLW  89
71F6:  MOVWF  FE9
71F8:  MOVFF  2B4,4B3
71FC:  MOVFF  2B3,4B2
7200:  MOVFF  2B2,4B1
7204:  MOVFF  2B1,4B0
7208:  MOVLW  02
720A:  MOVLB  4
720C:  MOVWF  xB4
720E:  MOVLB  0
7210:  CALL   55C0
7214:  MOVLW  35
7216:  MOVWF  FF6
7218:  MOVLW  04
721A:  MOVWF  FF7
721C:  MOVLW  06
721E:  MOVLB  4
7220:  MOVWF  xA1
7222:  MOVLB  0
7224:  CALL   68FA
7228:  MOVFF  2DD,4A1
722C:  MOVLW  18
722E:  MOVLB  4
7230:  MOVWF  xA2
7232:  MOVLB  0
7234:  GOTO   6924
7238:  MOVLW  3D
723A:  MOVWF  FF6
723C:  MOVLW  04
723E:  MOVWF  FF7
7240:  MOVLW  07
7242:  MOVLB  4
7244:  MOVWF  xA1
7246:  MOVLB  0
7248:  CALL   68FA
724C:  MOVLW  89
724E:  MOVWF  FE9
7250:  MOVFF  23E,4B3
7254:  MOVFF  23D,4B2
7258:  MOVFF  23C,4B1
725C:  MOVFF  23B,4B0
7260:  MOVLW  02
7262:  MOVLB  4
7264:  MOVWF  xB4
7266:  MOVLB  0
7268:  CALL   55C0
726C:  MOVLW  46
726E:  MOVWF  FF6
7270:  MOVLW  04
7272:  MOVWF  FF7
7274:  MOVLW  08
7276:  MOVLB  4
7278:  MOVWF  xA1
727A:  MOVLB  0
727C:  CALL   68FA
7280:  MOVLW  10
7282:  MOVWF  FE9
7284:  MOVFF  269,4A2
7288:  MOVFF  268,4A1
728C:  CALL   69EE
7290:  MOVLW  51
7292:  MOVWF  FF6
7294:  MOVLW  04
7296:  MOVWF  FF7
7298:  MOVLW  08
729A:  MOVLB  4
729C:  MOVWF  xA1
729E:  MOVLB  0
72A0:  CALL   68FA
72A4:  MOVLW  10
72A6:  MOVWF  FE9
72A8:  MOVFF  26B,4A2
72AC:  MOVFF  26A,4A1
72B0:  CALL   69EE
72B4:  MOVLW  23
72B6:  MOVLB  5
72B8:  MOVWF  xAF
72BA:  MOVLB  0
72BC:  CALL   33E6
.................... //!            fprintf(UART2, querystring); 
....................             fprintf(PORT1SIM, "%s", querystring); 
72C0:  MOVLW  03
72C2:  MOVWF  FEA
72C4:  MOVLW  A4
72C6:  MOVWF  FE9
72C8:  GOTO   6AB6
....................             rcount1 = 0; 
72CC:  MOVLB  2
72CE:  CLRF   x47
....................             rcount = 0; 
72D0:  CLRF   x40
72D2:  CLRF   x3F
....................             rcount6 = 0; 
72D4:  CLRF   x44
72D6:  CLRF   x43
....................             num = 0; 
72D8:  CLRF   x4E
....................             num_co = 0; 
72DA:  CLRF   x51
....................             num_no2 = 0; 
72DC:  CLRF   x4F
....................             num_so2 = 0; 
72DE:  CLRF   x50
....................             Tb_co = 0; 
72E0:  CLRF   xD0
72E2:  CLRF   xCF
72E4:  CLRF   xCE
72E6:  CLRF   xCD
....................             Tb_no2 = 0; 
72E8:  CLRF   xC8
72EA:  CLRF   xC7
72EC:  CLRF   xC6
72EE:  CLRF   xC5
....................             Tb_so2 = 0; 
72F0:  CLRF   xCC
72F2:  CLRF   xCB
72F4:  CLRF   xCA
72F6:  CLRF   xC9
....................             Wait = 1; 
72F8:  BSF    x20.5
72FA:  MOVLB  3
....................         } 
....................         // ------ Cho 5s va nhan du lieu cap nhap tra ve ------ // 
....................         if (rcount6 >= 250 && Wait == 1) 
72FC:  MOVLB  2
72FE:  MOVF   x44,F
7300:  BNZ   7308
7302:  MOVF   x43,W
7304:  SUBLW  F9
7306:  BC    7384
7308:  BTFSS  x20.5
730A:  BRA    7384
....................         { 
....................             Wait = 0; 
730C:  BCF    x20.5
....................             rcount6 = 0; 
730E:  CLRF   x44
7310:  CLRF   x43
....................             update_time_1day(hrs); 
7312:  MOVFF  264,4A1
7316:  MOVLB  0
7318:  GOTO   6ADE
....................             fprintf(PORT1SIM, "*get#"); 
731C:  MOVLW  5E
731E:  MOVWF  FF6
7320:  MOVLW  04
7322:  MOVWF  FF7
7324:  CALL   3B28
....................             rcount_TOUT = 0; 
7328:  MOVLB  2
732A:  CLRF   x46
732C:  CLRF   x45
....................             kt_time = 0; 
732E:  CLRF   x4D
....................             while ((kt_time == 0) && (rcount_TOUT <= 500)); 
7330:  MOVF   x4D,F
7332:  BNZ   7342
7334:  MOVF   x46,W
7336:  SUBLW  01
7338:  BNC   7342
733A:  BNZ   7330
733C:  MOVF   x45,W
733E:  SUBLW  F4
7340:  BC    7330
....................             if ((kt_time == 1) && (rcount_TOUT <= 600)) 
7342:  DECFSZ x4D,W
7344:  BRA    736A
7346:  MOVF   x46,W
7348:  SUBLW  02
734A:  BNC   736A
734C:  BNZ   7354
734E:  MOVF   x45,W
7350:  SUBLW  58
7352:  BNC   736A
....................             { 
....................                 fprintf(UART2, "Finish getdata"); 
7354:  MOVLW  64
7356:  MOVWF  FF6
7358:  MOVLW  04
735A:  MOVWF  FF7
735C:  MOVLB  0
735E:  CALL   0FE8
....................                 kt_time = 0; 
7362:  MOVLB  2
7364:  CLRF   x4D
....................                 kiemtraread = 1; 
7366:  BSF    x20.4
....................             } 
7368:  BRA    7384
....................             else 
....................             { 
....................                 fprintf(UART2, "Error getdata"); 
736A:  MOVLW  74
736C:  MOVWF  FF6
736E:  MOVLW  04
7370:  MOVWF  FF7
7372:  MOVLB  0
7374:  CALL   0FE8
....................                 error_get1++; 
7378:  MOVLB  2
737A:  INCF   x4C,F
....................                 if (error_get1 >= 3) 
737C:  MOVF   x4C,W
737E:  SUBLW  02
7380:  BC    7384
....................                     while (1); 
7382:  BRA    7382
....................             } 
....................         } 
....................         // ------ Tach gia tri thoi gian cap nhap tu choi tra ve ------ // 
....................         if (kiemtraread == 1) 
7384:  BTFSS  x20.4
7386:  BRA    74B8
....................         { 
....................             kiemtraread = 0; 
7388:  BCF    x20.4
....................             toInt = buff + 1; // xoa ky tu dau tien cua chuoi buff 
738A:  MOVLW  03
738C:  MOVLB  3
738E:  MOVWF  x40
7390:  MOVLW  04
7392:  MOVWF  x3F
....................             fprintf(UART2, "%s \n", toInt); 
7394:  MOVFF  340,FEA
7398:  MOVFF  33F,FE9
739C:  MOVLB  0
739E:  CALL   3B02
73A2:  MOVLW  20
73A4:  MOVLB  4
73A6:  MOVWF  xCB
73A8:  MOVLB  0
73AA:  CALL   04AC
73AE:  MOVLW  0A
73B0:  MOVLB  4
73B2:  MOVWF  xCB
73B4:  MOVLB  0
73B6:  CALL   04AC
....................             delay_ms(700); 
73BA:  MOVLW  04
73BC:  MOVLB  4
73BE:  MOVWF  xA1
73C0:  MOVLW  AF
73C2:  MOVWF  xBA
73C4:  MOVLB  0
73C6:  CALL   0482
73CA:  MOVLB  4
73CC:  DECFSZ xA1,F
73CE:  BRA    73C0
....................             ptr = strtok(toInt, ";"); 
73D0:  MOVLW  3B
73D2:  MOVWF  x9F
73D4:  CLRF   xA0
73D6:  MOVFF  340,4A7
73DA:  MOVFF  33F,4A6
73DE:  MOVLW  04
73E0:  MOVWF  xA9
73E2:  MOVLW  9F
73E4:  MOVWF  xA8
73E6:  MOVLB  0
73E8:  CALL   3C54
73EC:  MOVFF  02,342
73F0:  MOVFF  01,341
....................             gg = 0; 
73F4:  MOVLB  3
73F6:  CLRF   x47
....................             while (ptr != 0) 
73F8:  MOVF   x41,F
73FA:  BNZ   7400
73FC:  MOVF   x42,F
73FE:  BZ    7478
....................             { 
....................                 tachdata[gg] = atoi(ptr); 
7400:  MOVF   x47,W
7402:  MULLW  04
7404:  MOVF   FF3,W
7406:  CLRF   03
7408:  ADDLW  4C
740A:  MOVWF  01
740C:  MOVLW  03
740E:  ADDWFC 03,F
7410:  MOVFF  01,4A1
7414:  MOVFF  03,4A2
7418:  MOVFF  342,4A7
741C:  MOVFF  341,4A6
7420:  MOVLB  0
7422:  CALL   3D5E
7426:  MOVLB  4
7428:  CLRF   xA4
742A:  MOVFF  01,4A3
742E:  BTFSC  xA3.7
7430:  DECF   xA4,F
7432:  MOVLB  0
7434:  GOTO   6B14
7438:  MOVFF  4A2,FEA
743C:  MOVFF  4A1,FE9
7440:  MOVFF  00,FEF
7444:  MOVFF  01,FEC
7448:  MOVFF  02,FEC
744C:  MOVFF  03,FEC
....................                 ptr = strtok(0, ";"); 
7450:  MOVLW  3B
7452:  MOVLB  4
7454:  MOVWF  x9F
7456:  CLRF   xA0
7458:  CLRF   xA7
745A:  CLRF   xA6
745C:  MOVLW  04
745E:  MOVWF  xA9
7460:  MOVLW  9F
7462:  MOVWF  xA8
7464:  MOVLB  0
7466:  CALL   3C54
746A:  MOVFF  02,342
746E:  MOVFF  01,341
....................                 gg++; 
7472:  MOVLB  3
7474:  INCF   x47,F
7476:  BRA    73F8
....................             } 
....................             setcapnhat = tachdata[0]; 
7478:  MOVFF  34F,4B3
747C:  MOVFF  34E,4B2
7480:  MOVFF  34D,4B1
7484:  MOVFF  34C,4B0
7488:  MOVLB  0
748A:  CALL   577C
748E:  MOVFF  01,3A2
....................             //!            reset Pic 
....................             if (tachdata[1] == 1) 
7492:  MOVFF  353,4B7
7496:  MOVFF  352,4B6
749A:  MOVFF  351,4B5
749E:  MOVFF  350,4B4
74A2:  MOVLB  4
74A4:  CLRF   xBB
74A6:  CLRF   xBA
74A8:  CLRF   xB9
74AA:  MOVLW  7F
74AC:  MOVWF  xB8
74AE:  MOVLB  0
74B0:  CALL   47FC
74B4:  BNZ   74B8
....................                 while (1); 
74B6:  BRA    74B6
....................             // if (setcapnhat >= 5) 
....................             //     output_low(PIN_A4); 
....................         } 
74B8:  MOVLB  0
74BA:  BRA    6DAA
....................     } 
.................... } 
....................  
74BC:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1F3E   PUT BROWNOUT BORV21 VREGEN WDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
